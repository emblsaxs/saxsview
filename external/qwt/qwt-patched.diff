Index: qwt_raster_data.cpp
===================================================================
--- qwt_raster_data.cpp	(revision 382)
+++ qwt_raster_data.cpp	(working copy)
@@ -93,7 +93,7 @@
             break;
         case 6:
             // e(-1,1,0), e(1,0,-1)
-            line[0] = vertex[1].toPoint();
+            line[0] = vertex[2].toPoint();
             line[1] = intersection( vertex[0], vertex[1] );
             break;
         case 7:
@@ -180,11 +180,11 @@
 /*!
   \brief Initialize a raster
 
-  Before the composition of an image QwtPlotSpectrogram calls initRaster,
+  Before the composition of an image QwtPlotSpectrogram calls initRaster(),
   announcing the area and its resolution that will be requested.
 
   The default implementation does nothing, but for data sets that
-  are stored in files, it might be good idea to reimplement initRaster,
+  are stored in files, it might be good idea to reimplement initRaster(),
   where the data is resampled and loaded into memory.
 
   \param area Area of the raster
@@ -220,7 +220,7 @@
    representing the data. 
    
    Width and height of the hint need to be the horizontal  
-   and vertical distances between 2 neighboured points. 
+   and vertical distances between 2 neighbored points. 
    The center of the hint has to be the position of any point 
    ( it doesn't matter which one ).
 
@@ -247,6 +247,13 @@
 /*!
    Calculate contour lines
 
+   \param rect Bounding rectangle for the contour lines
+   \param raster Number of data pixels of the raster data
+   \param levels List of limits, where to insert contour lines
+   \param flags Flags to customize the contouring algorithm
+
+   \return Calculated contour lines
+
    An adaption of CONREC, a simple contouring algorithm.
    http://local.wasp.uwa.edu.au/~pbourke/papers/conrec/
 */
Index: qwt_scale_widget.cpp
===================================================================
--- qwt_scale_widget.cpp	(revision 382)
+++ qwt_scale_widget.cpp	(working copy)
@@ -14,6 +14,7 @@
 #include "qwt_math.h"
 #include "qwt_scale_div.h"
 #include "qwt_text.h"
+#include "qwt_scale_engine.h"
 #include <qpainter.h>
 #include <qevent.h>
 #include <qmath.h>
@@ -106,6 +107,9 @@
     d_data->scaleDraw->setAlignment( align );
     d_data->scaleDraw->setLength( 10 );
 
+    d_data->scaleDraw->setScaleDiv(
+        QwtLinearScaleEngine().divideScale( 0.0, 100.0, 10, 5 ) );
+
     d_data->colorBar.colorMap = new QwtLinearColorMap();
     d_data->colorBar.isEnabled = false;
     d_data->colorBar.width = 10;
@@ -306,28 +310,41 @@
 
 /*!
   Set a scale draw
-  sd has to be created with new and will be deleted in
+
+  scaleDraw has to be created with new and will be deleted in
   ~QwtScaleWidget() or the next call of setScaleDraw().
+  scaleDraw will be initialized with the attributes of
+  the previous scaleDraw object.
 
-  \param sd ScaleDraw object
+  \param scaleDraw ScaleDraw object
   \sa scaleDraw()
 */
-void QwtScaleWidget::setScaleDraw( QwtScaleDraw *sd )
+void QwtScaleWidget::setScaleDraw( QwtScaleDraw *scaleDraw )
 {
-    if ( sd == NULL || sd == d_data->scaleDraw )
+    if ( ( scaleDraw == NULL ) || ( scaleDraw == d_data->scaleDraw ) )
         return;
 
-    if ( d_data->scaleDraw )
-        sd->setAlignment( d_data->scaleDraw->alignment() );
+    const QwtScaleDraw* sd = d_data->scaleDraw;
+    if ( sd )
+    {
+        scaleDraw->setAlignment( sd->alignment() );
+        scaleDraw->setScaleDiv( sd->scaleDiv() );
 
+        QwtTransform *transform = NULL;
+        if ( sd->scaleMap().transformation() )
+            transform = sd->scaleMap().transformation()->copy();
+
+        scaleDraw->setTransformation( transform );
+    }
+
     delete d_data->scaleDraw;
-    d_data->scaleDraw = sd;
+    d_data->scaleDraw = scaleDraw;
 
     layoutScale();
 }
 
 /*!
-    scaleDraw of this scale
+    \return scaleDraw of this scale
     \sa setScaleDraw(), QwtScaleDraw::setScaleDraw()
 */
 const QwtScaleDraw *QwtScaleWidget::scaleDraw() const
@@ -336,7 +353,7 @@
 }
 
 /*!
-    scaleDraw of this scale
+    \return scaleDraw of this scale
     \sa QwtScaleDraw::setScaleDraw()
 */
 QwtScaleDraw *QwtScaleWidget::scaleDraw()
@@ -437,7 +454,7 @@
   Calculate the the rectangle for the color bar
 
   \param rect Bounding rectangle for all components of the scale
-  \return Rectabgle for the color bar
+  \return Rectangle for the color bar
 */
 QRectF QwtScaleWidget::colorBarRect( const QRectF& rect ) const
 {
@@ -491,7 +508,7 @@
 }
 
 /*!
-  Event handler for resize event
+  Event handler for resize events
   \param event Resize event
 */
 void QwtScaleWidget::resizeEvent( QResizeEvent *event )
@@ -502,7 +519,7 @@
 
 /*!
   Recalculate the scale's geometry and layout based on
-  the current rect and fonts.
+  the current geometry and fonts.
 
   \param update_geometry Notify the layout system and call update
                          to redraw the scale
@@ -750,6 +767,11 @@
   The maximum of this distance an the minimum border distance
   is returned.
 
+  \param start Return parameter for the border width at 
+               the beginning of the scale
+  \param end Return parameter for the border width at the 
+             end of the scale
+
   \warning
   <ul> <li>The minimum border distance depends on the font.</ul>
   \sa setMinBorderDist(), getMinBorderDist(), setBorderDist()
@@ -785,6 +807,11 @@
   Get the minimum value for the distances of the scale's endpoints from
   the widget borders.
 
+  \param start Return parameter for the border width at 
+               the beginning of the scale
+  \param end Return parameter for the border width at the 
+             end of the scale
+
   \sa setMinBorderDist(), getBorderDistHint()
 */
 void QwtScaleWidget::getMinBorderDist( int &start, int &end ) const
@@ -798,35 +825,31 @@
 
   The scale division determines where to set the tick marks.
 
-  \param transformation Transformation, needed to translate between
-                        scale and pixal values
   \param scaleDiv Scale Division
   \sa For more information about scale divisions, see QwtScaleDiv.
 */
-void QwtScaleWidget::setScaleDiv(
-    QwtScaleTransformation *transformation,
-    const QwtScaleDiv &scaleDiv )
+void QwtScaleWidget::setScaleDiv( const QwtScaleDiv &scaleDiv )
 {
     QwtScaleDraw *sd = d_data->scaleDraw;
-    if ( sd->scaleDiv() != scaleDiv ||
-        sd->scaleMap().transformation()->type() != transformation->type() )
+    if ( sd->scaleDiv() != scaleDiv )
     {
-        sd->setTransformation( transformation );
         sd->setScaleDiv( scaleDiv );
         layoutScale();
 
         Q_EMIT scaleDivChanged();
     }
-    else
-    {
-        /*
-          The transformation doesn't anything different as the 
-          previous one. So we better throw it silently away instead of 
-          initiating heavy updates
-         */
+}
 
-        delete transformation;
-    }
+/*!
+  Set the transformation
+
+  \param transformation Transformation
+  \sa QwtAbstractScaleDraw::scaleDraw(), QwtScaleMap
+ */
+void QwtScaleWidget::setTransformation( QwtTransform *transformation )
+{
+    d_data->scaleDraw->setTransformation( transformation );
+    layoutScale();
 }
 
 /*!
Index: qwt_plot_directpainter.cpp
===================================================================
--- qwt_plot_directpainter.cpp	(revision 382)
+++ qwt_plot_directpainter.cpp	(working copy)
@@ -17,7 +17,7 @@
 #include <qapplication.h>
 #include <qpixmap.h>
 
-static inline void renderItem( 
+static inline void qwtRenderItem( 
     QPainter *painter, const QRect &canvasRect,
     QwtPlotSeriesItem *seriesItem, int from, int to )
 {
@@ -33,6 +33,12 @@
     seriesItem->drawSeries( painter, xMap, yMap, canvasRect, from, to );
 }
 
+static inline bool qwtHasBackingStore( const QwtPlotCanvas *canvas )
+{
+    return canvas->testPaintAttribute( QwtPlotCanvas::BackingStore )
+        && canvas->backingStore() && !canvas->backingStore()->isNull();
+}
+
 class QwtPlotDirectPainter::PrivateData
 {
 public:
@@ -91,8 +97,7 @@
 }
 
 /*!
-  Check if a attribute is set.
-
+  \return True, when attribute is enabled
   \param attribute Attribute to be tested
   \sa Attribute, setAttribute()
 */
@@ -151,7 +156,7 @@
   \brief Draw a set of points of a seriesItem.
 
   When observing an measurement while it is running, new points have to be
-  added to an existing seriesItem. drawSeries can be used to display them avoiding
+  added to an existing seriesItem. drawSeries() can be used to display them avoiding
   a complete redraw of the canvas.
 
   Setting plot()->canvas()->setAttribute(Qt::WA_PaintOutsidePaintEvent, true);
@@ -169,39 +174,38 @@
     if ( seriesItem == NULL || seriesItem->plot() == NULL )
         return;
 
-    QwtPlotCanvas *canvas = seriesItem->plot()->canvas();
+    QWidget *canvas = seriesItem->plot()->canvas();
     const QRect canvasRect = canvas->contentsRect();
 
-    const bool hasBackingStore = 
-        canvas->testPaintAttribute( QwtPlotCanvas::BackingStore ) 
-        && canvas->backingStore() && !canvas->backingStore()->isNull();
+    QwtPlotCanvas *plotCanvas = qobject_cast<QwtPlotCanvas *>( canvas );
 
-    if ( hasBackingStore )
+    if ( plotCanvas && qwtHasBackingStore( plotCanvas ) )
     {
-        QPainter painter( const_cast<QPixmap *>( canvas->backingStore() ) );
+        QPainter painter( const_cast<QPixmap *>( plotCanvas->backingStore() ) );
 
         if ( d_data->hasClipping )
             painter.setClipRegion( d_data->clipRegion );
 
-        renderItem( &painter, canvasRect, seriesItem, from, to );
+        qwtRenderItem( &painter, canvasRect, seriesItem, from, to );
 
         if ( testAttribute( QwtPlotDirectPainter::FullRepaint ) )
         {
-            canvas->repaint();
+            plotCanvas->repaint();
             return;
         }
     }
 
     bool immediatePaint = true;
-    if ( !canvas->testAttribute( Qt::WA_WState_InPaintEvent ) &&
-        !canvas->testAttribute( Qt::WA_PaintOutsidePaintEvent ) )
+    if ( !canvas->testAttribute( Qt::WA_WState_InPaintEvent ) ) 
     {
-        immediatePaint = false;
+#if QT_VERSION < 0x050000
+        if ( !canvas->testAttribute( Qt::WA_PaintOutsidePaintEvent ) )
+#endif
+            immediatePaint = false;
     }
 
     if ( immediatePaint )
     {
-        QwtPlotCanvas *canvas = seriesItem->plot()->canvas();
         if ( !d_data->painter.isActive() )
         {
             reset();
@@ -221,7 +225,7 @@
                 d_data->painter.setClipRect( canvasRect );
         }
 
-        renderItem( &d_data->painter, canvasRect, seriesItem, from, to );
+        qwtRenderItem( &d_data->painter, canvasRect, seriesItem, from, to );
 
         if ( d_data->attributes & QwtPlotDirectPainter::AtomicPainter )
         {
@@ -277,30 +281,31 @@
         {
             const QPaintEvent *pe = static_cast< QPaintEvent *>( event );
 
-            QwtPlotCanvas *canvas = d_data->seriesItem->plot()->canvas();
+            QWidget *canvas = d_data->seriesItem->plot()->canvas();
 
             QPainter painter( canvas );
             painter.setClipRegion( pe->region() );
 
-            bool copyCache = testAttribute( CopyBackingStore )
-                && canvas->testPaintAttribute( QwtPlotCanvas::BackingStore );
+            bool doCopyCache = testAttribute( CopyBackingStore );
 
-            if ( copyCache )
+            if ( doCopyCache )
             {
-                // is something valid in the cache ?
-                copyCache = ( canvas->backingStore() != NULL )
-                    && !canvas->backingStore()->isNull();
+                QwtPlotCanvas *plotCanvas = 
+                    qobject_cast<QwtPlotCanvas *>( canvas );
+                if ( plotCanvas )
+                {
+                    doCopyCache = qwtHasBackingStore( plotCanvas );
+                    if ( doCopyCache )
+                    {
+                        painter.drawPixmap( plotCanvas->contentsRect().topLeft(), 
+                            *plotCanvas->backingStore() );
+                    }
+                }
             }
 
-            if ( copyCache )
+            if ( !doCopyCache )
             {
-                painter.drawPixmap( 
-                    canvas->contentsRect().topLeft(), 
-                    *canvas->backingStore() );
-            }
-            else
-            {
-                renderItem( &painter, canvas->contentsRect(),
+                qwtRenderItem( &painter, canvas->contentsRect(),
                     d_data->seriesItem, d_data->from, d_data->to );
             }
 
Index: qwt_legend.cpp
===================================================================
--- qwt_legend.cpp	(revision 382)
+++ qwt_legend.cpp	(working copy)
@@ -12,6 +12,7 @@
 #include "qwt_dyngrid_layout.h"
 #include "qwt_math.h"
 #include "qwt_plot_item.h"
+#include "qwt_painter.h"
 #include <qapplication.h>
 #include <qscrollbar.h>
 #include <qscrollarea.h>
@@ -19,75 +20,104 @@
 #include <qstyle.h>
 #include <qstyleoption.h>
 
-static void qwtRenderBackground( QPainter *painter,
-    const QRectF &rect, const QWidget *widget )
+class QwtLegendMap
 {
-    if ( widget->testAttribute( Qt::WA_StyledBackground ) )
-    {
-        QStyleOption opt;
-        opt.initFrom( widget );
-        opt.rect = rect.toAlignedRect();
+public:
+    inline bool isEmpty() const { return d_entries.isEmpty(); }
 
-        widget->style()->drawPrimitive(
-            QStyle::PE_Widget, &opt, painter, widget);
-    }
-    else
+    void insert( const QVariant &, const QList<QWidget *> & );
+    void remove( const QVariant & );
+
+    void removeWidget( const QWidget * );
+
+    QList<QWidget *> legendWidgets( const QVariant & ) const;
+    QVariant itemInfo( const QWidget * ) const;
+
+private:
+    // we don't know anything about itemInfo and therefore don't have
+    // any key that can be used for a map or hashtab.
+    // But a simple linear list is o.k. here, as we will never have
+    // more than a few entries.
+
+    class Entry
     {
-        const QBrush brush =
-            widget->palette().brush( widget->backgroundRole() );
+    public:
+        QVariant itemInfo;
+        QList<QWidget *> widgets;
+    };
 
-        painter->fillRect( rect, brush );
-    }
-}
-
-class QwtLegendMap: public QMap<const QwtPlotItem *, QList<QWidget *> >
-{
-public:
-    void removeWidget( const QWidget * );
-    QList<QWidget *> legendWidgets( const QwtPlotItem * ) const;
-    const QwtPlotItem *plotItem( const QWidget * ) const;
-    QwtPlotItem *plotItem( const QWidget * );
+    QList< Entry > d_entries;
 };
 
-void QwtLegendMap::removeWidget( const QWidget *widget )
+void QwtLegendMap::insert( const QVariant &itemInfo, 
+    const QList<QWidget *> &widgets )
 {
-    while ( QwtPlotItem *item = plotItem( widget ) )
+    for ( int i = 0; i < d_entries.size(); i++ )
     {
-        QList<QWidget *> widgets = legendWidgets( item );
-        widgets.removeAll( const_cast< QWidget *>( widget ) );
-        insert( item, widgets );
+        Entry &entry = d_entries[i];
+        if ( entry.itemInfo == itemInfo )
+        {
+            entry.widgets = widgets;
+            return;
+        }
     }
+
+    Entry newEntry;
+    newEntry.itemInfo = itemInfo;
+    newEntry.widgets = widgets;
+
+    d_entries += newEntry;
 }
 
-QwtPlotItem *QwtLegendMap::plotItem( const QWidget *widget )
+void QwtLegendMap::remove( const QVariant &itemInfo )
 {
-    if ( widget == NULL )
-        return NULL;
-
-    for ( Iterator it = begin(); it != end(); ++it )
+    for ( int i = 0; i < d_entries.size(); i++ )
     {
-        const QList< QWidget *> &widgets = it.value();
-        for ( int i = 0; i < widgets.size(); i++ )
+        Entry &entry = d_entries[i];
+        if ( entry.itemInfo == itemInfo )
         {
-            if ( widgets[i] == widget )
-                return const_cast<QwtPlotItem *>( it.key() );
+            d_entries.removeAt( i );
+            return;
         }
     }
+}
 
-    return NULL;
+void QwtLegendMap::removeWidget( const QWidget *widget )
+{
+    QWidget *w = const_cast<QWidget *>( widget );
+
+    for ( int i = 0; i < d_entries.size(); i++ )
+        d_entries[ i ].widgets.removeAll( w );
 }
 
-const QwtPlotItem *QwtLegendMap::plotItem( const QWidget *widget ) const
+QVariant QwtLegendMap::itemInfo( const QWidget *widget ) const
 {
-    QwtLegendMap *that = const_cast<QwtLegendMap *>( this );
-    return that->plotItem( widget );
+    if ( widget != NULL )
+    {
+        QWidget *w = const_cast<QWidget *>( widget );
+
+        for ( int i = 0; i < d_entries.size(); i++ )
+        {
+            const Entry &entry = d_entries[i];
+            if ( entry.widgets.indexOf( w ) >= 0 )
+                return entry.itemInfo;
+        }
+    }
+
+    return QVariant();
 }
 
-QList<QWidget *> QwtLegendMap::legendWidgets( const QwtPlotItem *item ) const
+QList<QWidget *> QwtLegendMap::legendWidgets( const QVariant &itemInfo ) const
 {
-    const ConstIterator it = find( item );
-    if ( it != constEnd() )
-        return it.value();
+    if ( itemInfo.isValid() )
+    {
+        for ( int i = 0; i < d_entries.size(); i++ )
+        {
+            const Entry &entry = d_entries[i];
+            if ( entry.itemInfo == itemInfo )
+                return entry.widgets;
+        }
+    }
 
     return QList<QWidget *>();
 }
@@ -128,22 +158,41 @@
         viewport()->setAutoFillBackground( false );
     }
 
-    virtual bool event( QEvent *ev )
+    virtual bool event( QEvent *event )
     {
-        if ( ev->type() == QEvent::PolishRequest )
+        if ( event->type() == QEvent::PolishRequest )
+        {
             setFocusPolicy( Qt::NoFocus );
+        }
 
-        return QScrollArea::event( ev );
+        if ( event->type() == QEvent::Resize )
+        {
+            // adjust the size to en/disable the scrollbars
+            // before QScrollArea adjusts the viewport size
+
+            const QRect cr = contentsRect();
+
+            int w = cr.width();
+            int h = contentsWidget->heightForWidth( cr.width() );
+            if ( h > w )
+            {
+                w -= verticalScrollBar()->sizeHint().width();
+                h = contentsWidget->heightForWidth( w );
+            }
+
+            contentsWidget->resize( w, h );
+        }
+
+        return QScrollArea::event( event );
     }
 
-    virtual bool viewportEvent( QEvent *e )
+    virtual bool viewportEvent( QEvent *event )
     {
-        bool ok = QScrollArea::viewportEvent( e );
+        bool ok = QScrollArea::viewportEvent( event );
 
-        if ( e->type() == QEvent::Resize )
+        if ( event->type() == QEvent::Resize )
         {
-            QEvent event( QEvent::LayoutRequest );
-            QApplication::sendEvent( contentsWidget, &event );
+            layoutContents();
         }
         return ok;
     }
@@ -171,12 +220,35 @@
         return QSize( vw, vh );
     }
 
+    void layoutContents()
+    {
+        const QwtDynGridLayout *tl = qobject_cast<QwtDynGridLayout *>(
+            contentsWidget->layout() );
+        if ( tl == NULL )
+            return;
+
+        const QSize visibleSize = viewport()->contentsRect().size();
+
+        const int minW = int( tl->maxItemWidth() ) + 2 * tl->margin();
+
+        int w = qMax( visibleSize.width(), minW );
+        int h = qMax( tl->heightForWidth( w ), visibleSize.height() );
+
+        const int vpWidth = viewportSize( w, h ).width();
+        if ( w > vpWidth )
+        {
+            w = qMax( vpWidth, minW );
+            h = qMax( tl->heightForWidth( w ), visibleSize.height() );
+        }
+
+        contentsWidget->resize( w, h );
+    }
+
     QWidget *contentsWidget;
 };
 
 /*!
   Constructor
-
   \param parent Parent widget
 */
 QwtLegend::QwtLegend( QWidget *parent ):
@@ -207,14 +279,28 @@
     delete d_data;
 }
 
+/*!
+  \brief Set the maximum number of entries in a row
+
+  F.e when the maximum is set to 1 all items are aligned
+  vertically. 0 means unlimited
+
+  \param numColums Maximum number of entries in a row
+
+  \sa maxColumns(), QwtDynGridLayout::setMaxColumns()
+ */
 void QwtLegend::setMaxColumns( uint numColums )
 {
     QwtDynGridLayout *tl = qobject_cast<QwtDynGridLayout *>(
         d_data->view->contentsWidget->layout() );
     if ( tl )
-        tl->setMaxCols( numColums );
+        tl->setMaxColumns( numColums );
 }
 
+/*!
+  \return Maximum number of entries in a row
+  \sa setMaxColumns(), QwtDynGridLayout::maxColumns()
+ */
 uint QwtLegend::maxColumns() const
 {
     uint maxCols = 0;
@@ -222,7 +308,7 @@
     const QwtDynGridLayout *tl = qobject_cast<const QwtDynGridLayout *>(
         d_data->view->contentsWidget->layout() );
     if ( tl )
-        maxCols = tl->maxCols();
+        maxCols = tl->maxColumns();
 
     return maxCols;
 }
@@ -256,7 +342,7 @@
 
 /*!
   The contents widget is the only child of the viewport of 
-  the internal QScrollArea  and the parent widget of all legend items.
+  the internal QScrollArea and the parent widget of all legend items.
 
   \return Container widget of the legend items
 */
@@ -285,7 +371,7 @@
 
 /*!
   The contents widget is the only child of the viewport of 
-  the internal QScrollArea  and the parent widget of all legend items.
+  the internal QScrollArea and the parent widget of all legend items.
 
   \return Container widget of the legend items
 
@@ -296,27 +382,33 @@
 }
 
 /*!
-  \brief Update the entries for a plot item
+  \brief Update the entries for an item
 
-  \param plotItem Plot items
-  \param data List of legend entry attributes of plot item
+  \param itemInfo Info for an item
+  \param data List of legend entry attributes for the item
  */
-void QwtLegend::updateLegend( const QwtPlotItem *plotItem, 
+void QwtLegend::updateLegend( const QVariant &itemInfo, 
     const QList<QwtLegendData> &data )
 {
-    QList<QWidget *> widgetList = legendWidgets( plotItem );
+    QList<QWidget *> widgetList = legendWidgets( itemInfo );
 
     if ( widgetList.size() != data.size() )
     {
-        for ( int i = data.size(); i < widgetList.size(); i++ )
+        QLayout *contentsLayout = d_data->view->contentsWidget->layout();
+
+        while ( widgetList.size() > data.size() )
         {
-            widgetList[i]->hide();
-            widgetList[i]->deleteLater();
+            QWidget *w = widgetList.takeLast();
 
-            widgetList.removeAt( i );
+            contentsLayout->removeWidget( w );
+
+            // updates might be triggered by signals from the legend widget
+            // itself. So we better don't delete it here.
+
+            w->hide();
+            w->deleteLater();
         }
 
-        QLayout *contentsLayout = d_data->view->contentsWidget->layout();
         for ( int i = widgetList.size(); i < data.size(); i++ )
         {
             QWidget *widget = createWidget( data[i] );
@@ -329,14 +421,14 @@
 
         if ( widgetList.isEmpty() )
         {
-            d_data->itemMap.remove( plotItem );
+            d_data->itemMap.remove( itemInfo );
         }
         else
         {
-            d_data->itemMap.insert( plotItem, widgetList );
+            d_data->itemMap.insert( itemInfo, widgetList );
         }
 
-        updateLayout();
+        updateTabOrder();
     }
     
     for ( int i = 0; i < data.size(); i++ )
@@ -349,6 +441,7 @@
   The default implementation returns a QwtLegendLabel.
 
   \param data Attributes of the legend entry
+  \return Widget representing data on the legend
   
   \note updateWidget() will called soon after createWidget()
         with the same attributes.
@@ -391,10 +484,8 @@
     }
 }
 
-void QwtLegend::updateLayout()
+void QwtLegend::updateTabOrder()
 {
-    layoutContents();
-
     QLayout *contentsLayout = d_data->view->contentsWidget->layout();
     if ( contentsLayout )
     {
@@ -411,18 +502,6 @@
             w = item->widget();
         }
     }
-
-    if ( parentWidget() && parentWidget()->layout() == NULL )
-    {
-        /*
-           updateGeometry() doesn't post LayoutRequest in certain
-           situations, like when we are hidden. But we want the
-           parent widget notified, so it can show/hide the legend
-           depending on its items.
-         */
-        QApplication::postEvent( parentWidget(),
-            new QEvent( QEvent::LayoutRequest ) );
-    }
 }
 
 //! Return a size hint.
@@ -435,7 +514,7 @@
 }
 
 /*!
-  \return The preferred height, for the width w.
+  \return The preferred height, for a width.
   \param width Width
 */
 int QwtLegend::heightForWidth( int width ) const
@@ -449,40 +528,15 @@
     return h;
 }
 
-/*!
-  Adjust contents widget and item layout to the size of the viewport().
-*/
-void QwtLegend::layoutContents()
-{
-    const QSize visibleSize = 
-        d_data->view->viewport()->contentsRect().size();
 
-    const QwtDynGridLayout *tl = qobject_cast<QwtDynGridLayout *>(
-        d_data->view->contentsWidget->layout() );
-    if ( tl )
-    {
-        const int minW = int( tl->maxItemWidth() ) + 2 * tl->margin();
-
-        int w = qMax( visibleSize.width(), minW );
-        int h = qMax( tl->heightForWidth( w ), visibleSize.height() );
-
-        const int vpWidth = d_data->view->viewportSize( w, h ).width();
-        if ( w > vpWidth )
-        {
-            w = qMax( vpWidth, minW );
-            h = qMax( tl->heightForWidth( w ), visibleSize.height() );
-        }
-
-        d_data->view->contentsWidget->resize( w, h );
-    }
-}
-
 /*!
   Handle QEvent::ChildRemoved andQEvent::LayoutRequest events 
   for the contentsWidget().
 
   \param object Object to be filtered
   \param event Event
+
+  \return Forwarded to QwtAbstractLegend::eventFilter()
 */
 bool QwtLegend::eventFilter( QObject *object, QEvent *event )
 {
@@ -503,7 +557,24 @@
             }
             case QEvent::LayoutRequest:
             {
-                layoutContents();
+                d_data->view->layoutContents();
+
+                if ( parentWidget() && parentWidget()->layout() == NULL )
+                {
+                    /*
+                       We want the parent widget ( usually QwtPlot ) to recalculate
+                       its layout, when the contentsWidget has changed. But
+                       because of the scroll view we have to forward the LayoutRequest
+                       event manually.
+
+                       We don't use updateGeometry() because it doesn't post LayoutRequest
+                       events when the legend is hidden. But we want the
+                       parent widget notified, so it can show/hide the legend
+                       depending on its items.
+                     */
+                    QApplication::postEvent( parentWidget(),
+                        new QEvent( QEvent::LayoutRequest ) );
+                }                
                 break;
             }
             default:
@@ -511,7 +582,7 @@
         }
     }
 
-    return QFrame::eventFilter( object, event );
+    return QwtAbstractLegend::eventFilter( object, event );
 }
 
 /*!
@@ -523,15 +594,15 @@
     QWidget *w = qobject_cast<QWidget *>( sender() );
     if ( w )
     {
-        QwtPlotItem *plotItem = d_data->itemMap.plotItem( w );
-        if ( plotItem )
+        const QVariant itemInfo = d_data->itemMap.itemInfo( w );
+        if ( itemInfo.isValid() )
         {
             const QList<QWidget *> widgetList =
-                d_data->itemMap.legendWidgets( plotItem );
+                d_data->itemMap.legendWidgets( itemInfo );
 
             const int index = widgetList.indexOf( w );
             if ( index >= 0 )
-                Q_EMIT clicked( plotItem, index );
+                Q_EMIT clicked( itemInfo, index );
         }
     }
 }
@@ -545,15 +616,15 @@
     QWidget *w = qobject_cast<QWidget *>( sender() );
     if ( w )
     {
-        QwtPlotItem *plotItem = d_data->itemMap.plotItem( w );
-        if ( plotItem )
+        const QVariant itemInfo = d_data->itemMap.itemInfo( w );
+        if ( itemInfo.isValid() )
         {
             const QList<QWidget *> widgetList =
-                d_data->itemMap.legendWidgets( plotItem );
+                d_data->itemMap.legendWidgets( itemInfo );
 
             const int index = widgetList.indexOf( w );
             if ( index >= 0 )
-                Q_EMIT checked( plotItem, on, index );
+                Q_EMIT checked( itemInfo, on, index );
         }
     }
 }
@@ -578,7 +649,7 @@
         if ( autoFillBackground() ||
             testAttribute( Qt::WA_StyledBackground ) )
         {
-            qwtRenderBackground( painter, rect, this );
+            QwtPainter::drawBackgound( painter, rect, this );
         }
     }
 
@@ -587,9 +658,18 @@
     if ( legendLayout == NULL )
         return;
 
-    uint numCols = legendLayout->columnsForWidth( qFloor( rect.width() ) );
+    int left, right, top, bottom;
+    getContentsMargins( &left, &top, &right, &bottom );
+
+    QRect layoutRect; 
+    layoutRect.setLeft( qCeil( rect.left() ) + left );
+    layoutRect.setTop( qCeil( rect.top() ) + top );
+    layoutRect.setRight( qFloor( rect.right() ) - right );
+    layoutRect.setBottom( qFloor( rect.bottom() ) - bottom );
+
+    uint numCols = legendLayout->columnsForWidth( layoutRect.width() );
     QList<QRect> itemRects =
-        legendLayout->layoutItems( rect.toRect(), numCols );
+        legendLayout->layoutItems( layoutRect, numCols );
 
     int index = 0;
 
@@ -629,7 +709,7 @@
         if ( widget->autoFillBackground() ||
             widget->testAttribute( Qt::WA_StyledBackground ) )
         {
-            qwtRenderBackground( painter, rect, widget );
+            QwtPainter::drawBackgound( painter, rect, widget );
         }
     }
 
@@ -653,43 +733,59 @@
         titleRect.setX( iconRect.right() + 2 * label->spacing() );
 
         painter->setFont( label->font() );
-        label->data().title().draw( painter, titleRect );
+        painter->setPen( label->palette().color( QPalette::Text ) );
+        const_cast< QwtLegendLabel *>( label )->drawText( painter, titleRect );
     }
 }
 
 /*!
-  \return List of widgets associated to a plot item
-  \sa legendWidget()
+  \return List of widgets associated to a item
+  \param itemInfo Info about an item
+  \sa legendWidget(), itemInfo(), QwtPlot::itemToInfo()
  */
-QList<QWidget *> QwtLegend::legendWidgets( const QwtPlotItem *item ) const
+QList<QWidget *> QwtLegend::legendWidgets( const QVariant &itemInfo ) const
 {
-    return d_data->itemMap.legendWidgets( item );
+    return d_data->itemMap.legendWidgets( itemInfo );
 }
 
 /*!
-  \return First widget in the list of widgets associated to a plot item
-  \note Almost all types of plot items have only one widget
+  \return First widget in the list of widgets associated to an item
+  \param itemInfo Info about an item
+  \sa itemInfo(), QwtPlot::itemToInfo()
+  \note Almost all types of items have only one widget
 */
-QWidget *QwtLegend::legendWidget( const QwtPlotItem *item ) const
+QWidget *QwtLegend::legendWidget( const QVariant &itemInfo ) const
 {
-    const QList<QWidget *> list = d_data->itemMap.legendWidgets( item );
+    const QList<QWidget *> list = d_data->itemMap.legendWidgets( itemInfo );
     if ( list.isEmpty() )
         return NULL;
 
     return list[0];
 }
 
-//! \return True, when no plot item is inserted
+/*!
+  Find the item that is associated to a widget
+
+  \param widget Widget on the legend
+  \return Associated item info
+  \sa legendWidget()
+ */
+QVariant QwtLegend::itemInfo( const QWidget *widget ) const
+{
+    return d_data->itemMap.itemInfo( widget );
+}
+
+//! \return True, when no item is inserted
 bool QwtLegend::isEmpty() const
 {
     return d_data->itemMap.isEmpty();
 }
 
 /*!
-    Return the extent, that is needed for the scroll bars
+    Return the extent, that is needed for the scrollbars
 
     \param orientation Orientation ( 
-    \return The width of the vertical scroll bar for Qt::Horizontal and v.v.
+    \return The width of the vertical scrollbar for Qt::Horizontal and v.v.
  */
 int QwtLegend::scrollExtent( Qt::Orientation orientation ) const
 {
Index: qwt_thermo.cpp
===================================================================
--- qwt_thermo.cpp	(revision 382)
+++ qwt_thermo.cpp	(working copy)
@@ -17,28 +17,26 @@
 #include <qdrawutil.h>
 #include <qstyle.h>
 #include <qstyleoption.h>
+#include <qmath.h>
 
-static inline bool qwtIsLogarithmic( const QwtThermo *thermo )
-{
-    const QwtScaleTransformation::Type scaleType =
-        thermo->scaleEngine()->transformation()->type();
-
-    return ( scaleType == QwtScaleTransformation::Log10 );
-}
-
-static inline void qwtDrawLine( 
-    QPainter *painter, int pos, 
-    const QColor &color, const QRect pipeRect, 
+static inline void qwtDrawLine( QPainter *painter, int pos, 
+    const QColor &color, const QRect &pipeRect, const QRect &liquidRect,
     Qt::Orientation orientation )
 {
     painter->setPen( color );
     if ( orientation == Qt::Horizontal )
-        painter->drawLine( pos, pipeRect.top(), pos, pipeRect.bottom() );
+    {
+        if ( pos >= liquidRect.left() && pos < liquidRect.right() )
+            painter->drawLine( pos, pipeRect.top(), pos, pipeRect.bottom() );
+    }
     else
-        painter->drawLine( pipeRect.left(), pos, pipeRect.right(), pos );
+    {
+        if ( pos >= liquidRect.top() && pos < liquidRect.bottom() )
+            painter->drawLine( pipeRect.left(), pos, pipeRect.right(), pos );
+    }
 }
 
-QVector<double> qwtTickList( const QwtScaleDiv &scaleDiv, double value )
+QVector<double> qwtTickList( const QwtScaleDiv &scaleDiv )
 {
     QVector<double> values;
 
@@ -48,12 +46,6 @@
     if ( upperLimit < lowerLimit )
         qSwap( lowerLimit, upperLimit );
 
-    if ( value < lowerLimit )
-        return values;
-
-    if ( value < upperLimit )
-        upperLimit = value;
-
     values += lowerLimit;
 
     for ( int tickType = QwtScaleDiv::MinorTick;
@@ -79,17 +71,17 @@
 public:
     PrivateData():
         orientation( Qt::Vertical ),
-        scalePos( QwtThermo::LeftScale ),
+        scalePosition( QwtThermo::TrailingScale ),
         spacing( 3 ),
         borderWidth( 2 ),
         pipeWidth( 10 ),
-        minValue( 0.0 ),
-        maxValue( 0.0 ),
-        value( 0.0 ),
         alarmLevel( 0.0 ),
         alarmEnabled( false ),
         autoFillPipe( true ),
-        colorMap( NULL )
+        originMode( QwtThermo::OriginMinimum ),
+        origin( 0.0 ),
+        colorMap( NULL ),
+        value( 0.0 )
     {
         rangeFlags = QwtInterval::IncludeBorders;
     }
@@ -99,23 +91,23 @@
         delete colorMap;
     }
 
-    QwtScaleMap map;
-
     Qt::Orientation orientation;
-    ScalePos scalePos;
+    QwtThermo::ScalePosition scalePosition;
+
     int spacing;
     int borderWidth;
     int pipeWidth;
 
-    double minValue;
-    double maxValue;
     QwtInterval::BorderFlags rangeFlags;
-    double value;
     double alarmLevel;
     bool alarmEnabled;
     bool autoFillPipe;
+    QwtThermo::OriginMode originMode;
+    double origin;
 
     QwtColorMap *colorMap;
+
+    double value;
 };
 
 /*!
@@ -123,10 +115,9 @@
   \param parent Parent widget
 */
 QwtThermo::QwtThermo( QWidget *parent ):
-    QWidget( parent )
+    QwtAbstractScale( parent )
 {
     d_data = new PrivateData;
-    setRange( 0.0, 1.0, false );
 
     QSizePolicy policy( QSizePolicy::MinimumExpanding, QSizePolicy::Fixed );
     if ( d_data->orientation == Qt::Vertical )
@@ -135,6 +126,7 @@
     setSizePolicy( policy );
 
     setAttribute( Qt::WA_WState_OwnSizePolicy, false );
+    layoutThermo( true );
 }
 
 //! Destructor
@@ -177,40 +169,6 @@
 }
 
 /*!
-  Set the maximum value.
-
-  \param maxValue Maximum value
-  \sa maxValue(), setMinValue(), setRange()
-*/
-void QwtThermo::setMaxValue( double maxValue )
-{
-    setRange( d_data->minValue, maxValue, qwtIsLogarithmic( this ) );
-}
-
-//! Return the maximum value.
-double QwtThermo::maxValue() const
-{
-    return d_data->maxValue;
-}
-
-/*!
-  Set the minimum value.
-
-  \param minValue Minimum value
-  \sa minValue(), setMaxValue(), setRange()
-*/
-void QwtThermo::setMinValue( double minValue )
-{
-    setRange( minValue, d_data->maxValue, qwtIsLogarithmic( this ) );
-}
-
-//! Return the minimum value.
-double QwtThermo::minValue() const
-{
-    return d_data->minValue;
-}
-
-/*!
   Set the current value.
 
   \param value New Value
@@ -239,7 +197,7 @@
   overload QwtScaleDraw::label().
 
   \param scaleDraw ScaleDraw object, that has to be created with
-                   new and will be deleted in ~QwtThermo or the next
+                   new and will be deleted in ~QwtThermo() or the next
                    call of setScaleDraw().
 */
 void QwtThermo::setScaleDraw( QwtScaleDraw *scaleDraw )
@@ -266,7 +224,7 @@
 }
 
 /*!
-  Qt paint event.
+  Paint event handler
   \param event Paint event
 */
 void QwtThermo::paintEvent( QPaintEvent *event )
@@ -282,7 +240,7 @@
 
     if ( !tRect.contains( event->rect() ) )
     {
-        if ( d_data->scalePos != NoScale )
+        if ( d_data->scalePosition != QwtThermo::NoScale )
             scaleDraw()->draw( &painter, palette() );
     }
 
@@ -298,7 +256,7 @@
 }
 
 /*! 
-  Qt resize event handler
+  Resize event handler
   \param event Resize event
 */
 void QwtThermo::resizeEvent( QResizeEvent *event )
@@ -328,7 +286,7 @@
 
 /*!
   Recalculate the QwtThermo geometry and layout based on
-  the QwtThermo::contentsRect() and the fonts.
+  pipeRect() and the fonts.
 
   \param update_geometry notify the layout system and call update
          to redraw the scale
@@ -337,7 +295,7 @@
 {
     const QRect tRect = pipeRect();
     const int bw = d_data->borderWidth + d_data->spacing;
-    const bool inverted = ( maxValue() < minValue() );
+    const bool inverted = ( upperBound() < lowerBound() );
 
     int from, to;
 
@@ -361,28 +319,18 @@
                 to++;
         }
 
-        switch ( d_data->scalePos )
+        if ( d_data->scalePosition == QwtThermo::TrailingScale )
         {
-            case TopScale:
-            {
-                scaleDraw()->setAlignment( QwtScaleDraw::TopScale );
-                scaleDraw()->move( from, tRect.top() - bw );
-                scaleDraw()->setLength( to - from );
-                break;
-            }
-
-            case BottomScale:
-            case NoScale: 
-            default:
-            {
-                scaleDraw()->setAlignment( QwtScaleDraw::BottomScale );
-                scaleDraw()->move( from, tRect.bottom() + bw );
-                scaleDraw()->setLength( to - from );
-                break;
-            }
+            scaleDraw()->setAlignment( QwtScaleDraw::TopScale );
+            scaleDraw()->move( from, tRect.top() - bw );
         }
+        else
+        {
+            scaleDraw()->setAlignment( QwtScaleDraw::BottomScale );
+            scaleDraw()->move( from, tRect.bottom() + bw );
+        }
 
-        d_data->map.setPaintInterval( from, to );
+        scaleDraw()->setLength( to - from );
     }
     else // Qt::Vertical
     {
@@ -404,27 +352,18 @@
                 from--;
         }
 
-        switch ( d_data->scalePos )
+        if ( d_data->scalePosition == QwtThermo::LeadingScale )
         {
-            case RightScale:
-            {
-                scaleDraw()->setAlignment( QwtScaleDraw::RightScale );
-                scaleDraw()->move( tRect.right() + bw, from );
-                scaleDraw()->setLength( to - from );
-                break;
-            }
-
-            case LeftScale:
-            case NoScale: 
-            default:
-            {
-                scaleDraw()->setAlignment( QwtScaleDraw::LeftScale );
-                scaleDraw()->move( tRect.left() - bw, from );
-                scaleDraw()->setLength( to - from );
-                break;
-            }
+            scaleDraw()->setAlignment( QwtScaleDraw::RightScale );
+            scaleDraw()->move( tRect.right() + bw, from );
         }
-        d_data->map.setPaintInterval( to, from );
+        else
+        {
+            scaleDraw()->setAlignment( QwtScaleDraw::LeftScale );
+            scaleDraw()->move( tRect.left() - bw, from );
+        }
+
+        scaleDraw()->setLength( to - from );
     }
 
     if ( update_geometry )
@@ -440,169 +379,152 @@
 */
 QRect QwtThermo::pipeRect() const
 {
-    const QRect cr = contentsRect();
-
     int mbd = 0;
-    if ( d_data->scalePos != NoScale )
+    if ( d_data->scalePosition != QwtThermo::NoScale )
     {
         int d1, d2;
         scaleDraw()->getBorderDistHint( font(), d1, d2 );
         mbd = qMax( d1, d2 );
     }
-    int bw = d_data->borderWidth;
+    const int bw = d_data->borderWidth;
+    const int scaleOff = bw + mbd;
 
-    QRect tRect;
+    const QRect cr = contentsRect();
+
+    QRect pipeRect = cr;
     if ( d_data->orientation == Qt::Horizontal )
     {
-        switch ( d_data->scalePos )
-        {
-            case TopScale:
-            {
-                tRect.setRect(
-                    cr.x() + mbd + bw,
-                    cr.y() + cr.height() - d_data->pipeWidth - 2 * bw,
-                    cr.width() - 2 * ( bw + mbd ),
-                    d_data->pipeWidth 
-                );
-                break;
-            }
+        pipeRect.adjust( scaleOff, 0, -scaleOff, 0 );
 
-            case BottomScale:
-            case NoScale: 
-            default:   
-            {
-                tRect.setRect(
-                    cr.x() + mbd + bw,
-                    cr.y() + d_data->borderWidth,
-                    cr.width() - 2 * ( bw + mbd ),
-                    d_data->pipeWidth 
-                );
-                break;
-            }
-        }
+        if ( d_data->scalePosition == QwtThermo::TrailingScale )
+            pipeRect.setTop( cr.top() + cr.height() - bw - d_data->pipeWidth );
+        else
+            pipeRect.setTop( bw );
+
+        pipeRect.setHeight( d_data->pipeWidth );
     }
     else // Qt::Vertical
     {
-        switch ( d_data->scalePos )
-        {
-            case RightScale:
-            {
-                tRect.setRect(
-                    cr.x() + bw,
-                    cr.y() + mbd + bw,
-                    d_data->pipeWidth,
-                    cr.height() - 2 * ( bw + mbd ) 
-                );
-                break;
-            }
-            case LeftScale:
-            case NoScale: 
-            default:   
-            {
-                tRect.setRect(
-                    cr.x() + cr.width() - 2 * bw - d_data->pipeWidth,
-                    cr.y() + mbd + bw,
-                    d_data->pipeWidth,
-                    cr.height() - 2 * ( bw + mbd ) );
-                break;
-            }
-        }
+        pipeRect.adjust( 0, scaleOff, 0, -scaleOff );
+
+        if ( d_data->scalePosition == QwtThermo::LeadingScale )
+            pipeRect.setLeft( bw );
+        else 
+            pipeRect.setLeft( cr.left() + cr.width() - bw - d_data->pipeWidth );
+
+        pipeRect.setWidth( d_data->pipeWidth );
     }
 
-    return tRect;
+    return pipeRect;
 }
 
 /*!
-   \brief Set the thermometer orientation and the scale position.
+  \brief Set the orientation.
+  \param orientation Allowed values are Qt::Horizontal and Qt::Vertical.
 
-   The scale position NoScale disables the scale.
-   \param o orientation. Possible values are Qt::Horizontal and Qt::Vertical.
-         The default value is Qt::Vertical.
-   \param s Position of the scale.
-         The default value is NoScale.
-
-   A valid combination of scale position and orientation is enforced:
-   - a horizontal thermometer can have the scale positions TopScale,
-     BottomScale or NoScale;
-   - a vertical thermometer can have the scale positions LeftScale,
-     RightScale or NoScale;
-   - an invalid scale position will default to NoScale.
-
-   \sa setScalePosition()
+  \sa orientation(), scalePosition()
 */
-void QwtThermo::setOrientation( Qt::Orientation o, ScalePos s )
+void QwtThermo::setOrientation( Qt::Orientation orientation )
 {
-    if ( o == d_data->orientation && s == d_data->scalePos )
+    if ( orientation == d_data->orientation )
         return;
 
-    switch ( o )
-    {
-        case Qt::Horizontal:
-        {
-            if ( ( s == NoScale ) || ( s == BottomScale ) || ( s == TopScale ) )
-                d_data->scalePos = s;
-            else
-                d_data->scalePos = NoScale;
-            break;
-        }
-        case Qt::Vertical:
-        {
-            if ( ( s == NoScale ) || ( s == LeftScale ) || ( s == RightScale ) )
-                d_data->scalePos = s;
-            else
-                d_data->scalePos = NoScale;
-            break;
-        }
-    }
+    d_data->orientation = orientation;
 
-    if ( o != d_data->orientation )
+    if ( !testAttribute( Qt::WA_WState_OwnSizePolicy ) )
     {
-        if ( !testAttribute( Qt::WA_WState_OwnSizePolicy ) )
-        {
-            QSizePolicy sp = sizePolicy();
-            sp.transpose();
-            setSizePolicy( sp );
+        QSizePolicy sp = sizePolicy();
+        sp.transpose();
+        setSizePolicy( sp );
 
-            setAttribute( Qt::WA_WState_OwnSizePolicy, false );
-        }
+        setAttribute( Qt::WA_WState_OwnSizePolicy, false );
     }
 
-    d_data->orientation = o;
     layoutThermo( true );
 }
 
 /*!
-  \brief Change the scale position (and thermometer orientation).
+  \return Orientation
+  \sa setOrientation()
+*/
+Qt::Orientation QwtThermo::orientation() const
+{
+    return d_data->orientation;
+}
 
-  \param scalePos Position of the scale.
+/*!
+  \brief Change how the origin is determined.
+  \sa originMode(), serOrigin(), origin()
+ */
+void QwtThermo::setOriginMode( OriginMode m )
+{
+    if ( m == d_data->originMode )
+        return;
 
-  A valid combination of scale position and orientation is enforced:
-  - if the new scale position is LeftScale or RightScale, the
-    scale orientation will become Qt::Vertical;
-  - if the new scale position is BottomScale or TopScale, the scale
-    orientation will become Qt::Horizontal;
-  - if the new scale position is NoScale, the scale orientation 
-    will not change.
+    d_data->originMode = m;
+    update();
+}
 
-  \sa setOrientation(), scalePosition()
+/*!
+  \return Mode, how the origin is determined.
+  \sa setOriginMode(), serOrigin(), origin()
+ */
+QwtThermo::OriginMode QwtThermo::originMode() const
+{
+    return d_data->originMode;
+}
+
+/*!
+  \brief Specifies the custom origin.
+
+  If originMode is set to OriginCustom this property controls where the
+  liquid starts.
+
+  \param origin New origin level
+  \sa setOriginMode(), originMode(), origin()
+ */
+void QwtThermo::setOrigin( double origin )
+{
+    if ( origin == d_data->origin )
+        return;
+
+    d_data->origin = origin;
+    update();
+}
+
+/*!
+  \return Origin of the thermo, when OriginCustom is enabled
+  \sa setOrigin(), setOriginMode(), originMode()
+ */
+double QwtThermo::origin() const
+{
+    return d_data->origin;
+}
+
+/*!
+  \brief Change the position of the scale
+  \param scalePosition Position of the scale.
+
+  \sa ScalePosition, scalePosition()
 */
-void QwtThermo::setScalePosition( ScalePos scalePos )
+void QwtThermo::setScalePosition( ScalePosition scalePosition )
 {
-    if ( ( scalePos == BottomScale ) || ( scalePos == TopScale ) )
-        setOrientation( Qt::Horizontal, scalePos );
-    else if ( ( scalePos == LeftScale ) || ( scalePos == RightScale ) )
-        setOrientation( Qt::Vertical, scalePos );
-    else
-        setOrientation( d_data->orientation, NoScale );
+    if ( d_data->scalePosition == scalePosition )
+        return;
+
+    d_data->scalePosition = scalePosition;
+
+    if ( testAttribute( Qt::WA_WState_Polished ) )
+        layoutThermo( true );
 }
 
 /*!
-   Return the scale position.
+   \return Scale position.
    \sa setScalePosition()
 */
-QwtThermo::ScalePos QwtThermo::scalePosition() const
+QwtThermo::ScalePosition QwtThermo::scalePosition() const
 {
-    return d_data->scalePos;
+    return d_data->scalePosition;
 }
 
 //! Notify a scale change.
@@ -621,20 +543,22 @@
 {
     painter->save();
     painter->setClipRect( pipeRect, Qt::IntersectClip );
+    painter->setPen( Qt::NoPen );
 
-    const bool inverted = ( maxValue() < minValue() );
+    const QwtScaleMap scaleMap = scaleDraw()->scaleMap();
+
+    QRect liquidRect = fillRect( pipeRect );
+
     if ( d_data->colorMap != NULL )
     {
-        QwtInterval interval( d_data->minValue, d_data->maxValue );
-        interval = interval.normalized();
+        const QwtInterval interval = scaleDiv().interval().normalized();
 
         // Because the positions of the ticks are rounded
         // we calculate the colors for the rounded tick values
 
-        QVector<double> values = qwtTickList(
-            scaleDraw()->scaleDiv(), d_data->value );
+        QVector<double> values = qwtTickList( scaleDraw()->scaleDiv() );
 
-        if ( d_data->map.isInverting() )
+        if ( scaleMap.isInverting() )
             qSort( values.begin(), values.end(), qGreater<double>() );
         else
             qSort( values.begin(), values.end(), qLess<double>() );
@@ -642,78 +566,45 @@
         int from;
         if ( !values.isEmpty() )
         {
-            from = qRound( d_data->map.transform( values[0] ) );
+            from = qRound( scaleMap.transform( values[0] ) );
             qwtDrawLine( painter, from,
                 d_data->colorMap->color( interval, values[0] ),
-                pipeRect, d_data->orientation );
+                pipeRect, liquidRect, d_data->orientation );
         }
 
         for ( int i = 1; i < values.size(); i++ )
         {
-            const int to = qRound( d_data->map.transform( values[i] ) );
+            const int to = qRound( scaleMap.transform( values[i] ) );
 
             for ( int pos = from + 1; pos < to; pos++ )
             {
-                const double v = d_data->map.invTransform( pos );
+                const double v = scaleMap.invTransform( pos );
 
                 qwtDrawLine( painter, pos, 
                     d_data->colorMap->color( interval, v ),
-                    pipeRect, d_data->orientation );
+                    pipeRect, liquidRect, d_data->orientation );
             }
+
             qwtDrawLine( painter, to,
                 d_data->colorMap->color( interval, values[i] ),
-                pipeRect, d_data->orientation );
+                pipeRect, liquidRect, d_data->orientation );
 
             from = to;
         }
     }
     else
     {
-        const int tval = qRound( d_data->map.transform( d_data->value ) );
-
-        QRect fillRect = pipeRect;
-        if ( d_data->orientation == Qt::Horizontal )
+        if ( !liquidRect.isEmpty() && d_data->alarmEnabled )
         {
-            if ( inverted )
-                fillRect.setLeft( tval );
-            else
-                fillRect.setRight( tval );
-        }
-        else // Qt::Vertical
-        {
-            if ( inverted )
-                fillRect.setBottom( tval );
-            else
-                fillRect.setTop( tval );
-        }
-
-        if ( d_data->alarmEnabled &&
-            d_data->value >= d_data->alarmLevel )
-        {
-            QRect alarmRect = fillRect;
-
-            const int taval = qRound( d_data->map.transform( d_data->alarmLevel ) );
-            if ( d_data->orientation == Qt::Horizontal )
+            const QRect r = alarmRect( liquidRect );
+            if ( !r.isEmpty() )
             {
-                if ( inverted )
-                    alarmRect.setRight( taval );
-                else
-                    alarmRect.setLeft( taval );
+                painter->fillRect( r, palette().brush( QPalette::Highlight ) );
+                liquidRect = QRegion( liquidRect ).subtracted( r ).boundingRect();
             }
-            else
-            {
-                if ( inverted )
-                    alarmRect.setTop( taval );
-                else
-                    alarmRect.setBottom( taval );
-            }
-
-            fillRect = QRegion( fillRect ).subtracted( alarmRect ).boundingRect();
-
-            painter->fillRect( alarmRect, palette().brush( QPalette::Highlight ) );
         }
 
-        painter->fillRect( fillRect, palette().brush( QPalette::ButtonText ) );
+        painter->fillRect( liquidRect, palette().brush( QPalette::ButtonText ) );
     }
 
     painter->restore();
@@ -769,7 +660,7 @@
 }
 
 /*!
-   Return the border width of the thermometer pipe.
+   \return Border width of the thermometer pipe.
    \sa setBorderWidth()
 */
 int QwtThermo::borderWidth() const
@@ -778,50 +669,6 @@
 }
 
 /*!
-  \brief Set the range
-
-  \param minValue value corresponding lower or left end 
-                  of the thermometer
-  \param maxValue value corresponding to the upper or 
-                  right end of the thermometer
-  \param logarithmic logarithmic mapping, true or false
-*/
-void QwtThermo::setRange( 
-    double minValue, double maxValue, bool logarithmic )
-{
-    if ( minValue == d_data->minValue && maxValue == d_data->maxValue
-        && logarithmic == qwtIsLogarithmic( this ) )
-    {
-        return;
-    }
-
-    if ( logarithmic != qwtIsLogarithmic( this ) )
-    {
-        if ( logarithmic )
-            setScaleEngine( new QwtLog10ScaleEngine );
-        else
-            setScaleEngine( new QwtLinearScaleEngine );
-    }
-
-    d_data->minValue = minValue;
-    d_data->maxValue = maxValue;
-
-    /*
-      There are two different maps, one for the scale, the other
-      for the values. This is confusing and will be changed
-      in the future. TODO ...
-     */
-
-    d_data->map.setTransformation( scaleEngine()->transformation() );
-    d_data->map.setScaleInterval( minValue, maxValue );
-
-    if ( autoScale() )
-        rescale( minValue, maxValue );
-
-    layoutThermo( true );
-}
-
-/*!
   \brief Assign a color map for the fill color
 
   \param colorMap Color map
@@ -873,10 +720,10 @@
 }
 
 /*!
-  Return the liquid ( QPalette::ButtonText ) brush. 
+  \return Liquid ( QPalette::ButtonText ) brush. 
   \sa setFillBrush(), QWidget::palette()
 */
-const QBrush& QwtThermo::fillBrush() const
+QBrush QwtThermo::fillBrush() const
 {
     return palette().brush( QPalette::ButtonText );
 }
@@ -900,13 +747,13 @@
 }
 
 /*!
-  Return the liquid brush ( QPalette::Highlight ) above the alarm threshold.
+  \return Liquid brush ( QPalette::Highlight ) above the alarm threshold.
   \sa setAlarmBrush(), QWidget::palette()
 
   \warning The alarm threshold has no effect, when
            a color map has been assigned
 */
-const QBrush& QwtThermo::alarmBrush() const
+QBrush QwtThermo::alarmBrush() const
 {
     return palette().brush( QPalette::Highlight );
 }
@@ -928,7 +775,7 @@
 }
 
 /*!
-  Return the alarm threshold.
+  \return Alarm threshold.
   \sa setAlarmLevel()
 
   \warning The alarm threshold has no effect, when
@@ -955,7 +802,7 @@
 }
 
 /*!
-  Return the width of the pipe.
+  \return Width of the pipe.
   \sa setPipeWidth()
 */
 int QwtThermo::pipeWidth() const
@@ -965,14 +812,14 @@
 
 /*!
   \brief Enable or disable the alarm threshold
-  \param tf true (disabled) or false (enabled)
+  \param on true (disabled) or false (enabled)
 
   \warning The alarm threshold has no effect, when
            a color map has been assigned
 */
-void QwtThermo::setAlarmEnabled( bool tf )
+void QwtThermo::setAlarmEnabled( bool on )
 {
-    d_data->alarmEnabled = tf;
+    d_data->alarmEnabled = on;
     update();
 }
 
@@ -997,7 +844,7 @@
 }
 
 /*!
-  \brief Return a minimum size hint
+  \return Minimum size hint
   \warning The return value depends on the font and the scale.
   \sa sizeHint()
 */
@@ -1005,14 +852,13 @@
 {
     int w = 0, h = 0;
 
-    if ( d_data->scalePos != NoScale )
+    if ( d_data->scalePosition != NoScale )
     {
         const int sdExtent = qCeil( scaleDraw()->extent( font() ) );
         const int sdLength = scaleDraw()->minLength( font() );
 
         w = sdLength;
-        h = d_data->pipeWidth + sdExtent +
-            d_data->borderWidth + d_data->spacing;
+        h = d_data->pipeWidth + sdExtent + d_data->spacing;
 
     }
     else // no scale
@@ -1027,6 +873,7 @@
     w += 2 * d_data->borderWidth;
     h += 2 * d_data->borderWidth;
 
+    // finally add the margins
     int left, right, top, bottom;
     getContentsMargins( &left, &top, &right, &bottom );
     w += left + right;
@@ -1034,3 +881,124 @@
 
     return QSize( w, h );
 }
+
+/*!
+  \brief Calculate the filled rectangle of the pipe
+
+  \param pipeRect Rectangle of the pipe
+  \return Rectangle to be filled ( fill and alarm brush )
+
+  \sa pipeRect(), alarmRect()
+ */
+QRect QwtThermo::fillRect( const QRect &pipeRect ) const
+{
+    double origin;        
+    if ( d_data->originMode == OriginMinimum )
+    {
+        origin = qMin( lowerBound(), upperBound() );
+    }
+    else if ( d_data->originMode == OriginMaximum )
+    {
+        origin = qMax( lowerBound(), upperBound() );
+    }
+    else // OriginCustom
+    {
+        origin = d_data->origin;
+    }
+
+    const QwtScaleMap scaleMap = scaleDraw()->scaleMap();
+
+    int from = qRound( scaleMap.transform( d_data->value ) );
+    int to = qRound( scaleMap.transform( origin ) );
+
+    if ( to < from )
+        qSwap( from, to );
+    
+    QRect fillRect = pipeRect;
+    if ( d_data->orientation == Qt::Horizontal )
+    {
+        fillRect.setLeft( from );
+        fillRect.setRight( to );
+    }
+    else // Qt::Vertical
+    {
+        fillRect.setTop( from );
+        fillRect.setBottom( to );
+    }
+
+    return fillRect.normalized();
+}
+
+/*!
+  \brief Calculate the alarm rectangle of the pipe
+
+  \param fillRect Filled rectangle in the pipe
+  \return Rectangle to be filled with the alarm brush
+
+  \sa pipeRect(), fillRect(), alarmLevel(), alarmBrush()
+ */
+QRect QwtThermo::alarmRect( const QRect &fillRect ) const
+{
+    QRect alarmRect( 0, 0, -1, -1); // something invalid
+
+    if ( !d_data->alarmEnabled )
+        return alarmRect;
+
+    const bool inverted = ( upperBound() < lowerBound() );
+    
+    bool increasing;
+    if ( d_data->originMode == OriginCustom )
+    {
+        increasing = d_data->value > d_data->origin;
+    }
+    else
+    {
+        increasing = d_data->originMode == OriginMinimum;
+    }
+
+    const QwtScaleMap map = scaleDraw()->scaleMap();
+    const int alarmPos = qRound( map.transform( d_data->alarmLevel ) );
+    const int valuePos = qRound( map.transform( d_data->value ) );
+    
+    if ( d_data->orientation == Qt::Horizontal )
+    {
+        int v1, v2;
+        if ( inverted )
+        {
+            v1 = fillRect.left();
+
+            v2 = alarmPos - 1;
+            v2 = qMin( v2, increasing ? fillRect.right() : valuePos );
+        }
+        else
+        {
+            v1 = alarmPos + 1;
+            v1 = qMax( v1, increasing ? fillRect.left() : valuePos );
+
+            v2 = fillRect.right();
+
+        }
+        alarmRect.setRect( v1, fillRect.top(), v2 - v1 + 1, fillRect.height() );
+    }
+    else
+    {
+        int v1, v2;
+        if ( inverted )
+        {
+            v1 = alarmPos + 1;
+            v1 = qMax( v1, increasing ? fillRect.top() : valuePos );
+
+            v2 = fillRect.bottom();
+        }
+        else
+        {
+            v1 = fillRect.top();
+
+            v2 = alarmPos - 1;
+            v2 = qMin( v2, increasing ? fillRect.bottom() : valuePos );
+        }
+        alarmRect.setRect( fillRect.left(), v1, fillRect.width(), v2 - v1 + 1 );
+    }
+
+    return alarmRect;
+} 
Index: qwt_pixel_matrix.cpp
===================================================================
--- qwt_pixel_matrix.cpp	(revision 382)
+++ qwt_pixel_matrix.cpp	(working copy)
@@ -12,7 +12,7 @@
 /*!
   \brief Constructor
 
-  \rect Bounding rectangle for the matrix
+  \param rect Bounding rectangle for the matrix
 */
 QwtPixelMatrix::QwtPixelMatrix( const QRect& rect ):
     QBitArray( qMax( rect.width() * rect.height(), 0 ) ),
Index: qwt_curve_fitter.h
===================================================================
--- qwt_curve_fitter.h	(revision 382)
+++ qwt_curve_fitter.h	(working copy)
@@ -99,6 +99,12 @@
   maximum distance (tolerance) between the original curve and the
   smoothed curve.
 
+  The runtime of the algorithm increases non linear ( worst case O( n*n ) )
+  and might be very slow for huge polygons. To avoid performance issues
+  it might be useful to split the polygon ( setChunkSize() ) and to run the algorithm
+  for these smaller parts. The disadvantage of having no interpolation
+  at the borders is for most use cases irrelevant.
+
   The smoothed curve consists of a subset of the points that defined the
   original curve.
 
@@ -116,9 +122,14 @@
     void setTolerance( double );
     double tolerance() const;
 
+    void setChunkSize( uint );
+    uint chunkSize() const;
+
     virtual QPolygonF fitCurve( const QPolygonF & ) const;
 
 private:
+    virtual QPolygonF simplify( const QPolygonF & ) const;
+
     class Line;
 
     class PrivateData;
Index: qwt_abstract_scale.cpp
===================================================================
--- qwt_abstract_scale.cpp	(revision 382)
+++ qwt_abstract_scale.cpp	(working copy)
@@ -20,10 +20,9 @@
     PrivateData():
         maxMajor( 5 ),
         maxMinor( 3 ),
-        stepSize( 0.0 ),
-        autoScale( true )
+        stepSize( 0.0 )
     {
-        scaleEngine = new QwtLinearScaleEngine;
+        scaleEngine = new QwtLinearScaleEngine();
         scaleDraw = new QwtScaleDraw();
     }
 
@@ -39,21 +38,25 @@
     int maxMajor;
     int maxMinor;
     double stepSize;
-
-    bool autoScale;
 };
 
 /*!
   Constructor
 
+  \param parent Parent widget
+
   Creates a default QwtScaleDraw and a QwtLinearScaleEngine.
-  Autoscaling is enabled, and the stepSize is initialized by 0.0.
+  The initial scale boundaries are set to [ 0.0, 100.0 ]
+
+  The scaleStepSize() is initialized to 0.0, scaleMaxMajor() to 5
+  and scaleMaxMajor to 3.
 */
 
-QwtAbstractScale::QwtAbstractScale()
+QwtAbstractScale::QwtAbstractScale( QWidget *parent ):
+    QWidget( parent )
 {
     d_data = new PrivateData;
-    rescale( 0.0, 100.0 );
+    rescale( 0.0, 100.0, d_data->stepSize );
 }
 
 //! Destructor
@@ -63,111 +66,123 @@
 }
 
 /*!
-  \brief Specify a scale.
+  Set the lower bound of the scale
 
-  Disable autoscaling and define a scale by an interval and a step size
+  \param value Lower bound
 
-  \param vmin lower limit of the scale interval
-  \param vmax upper limit of the scale interval
-  \param stepSize major step size
-  \sa setAutoScale()
+  \sa lowerBound(), setScale(), setUpperBound()
+  \note For inverted scales the lower bound 
+        is greater than the upper bound
 */
-void QwtAbstractScale::setScale( double vmin, double vmax, double stepSize )
+void QwtAbstractScale::setLowerBound( double value )
 {
-    d_data->autoScale = false;
-    d_data->stepSize = stepSize;
+    setScale( value, upperBound() );
+}
 
-    rescale( vmin, vmax, stepSize );
+/*!
+  \return Lower bound of the scale
+  \sa setLowerBound(), setScale(), upperBound()
+*/
+double QwtAbstractScale::lowerBound() const
+{
+    return d_data->scaleDraw->scaleDiv().lowerBound();
 }
 
 /*!
-  \brief Specify a scale.
+  Set the upper bound of the scale
 
-  Disable autoscaling and define a scale by an interval and a step size
+  \param value Upper bound
 
-  \param interval Interval
-  \param stepSize major step size
-  \sa setAutoScale()
+  \sa upperBound(), setScale(), setLowerBound()
+  \note For inverted scales the lower bound 
+        is greater than the upper bound
 */
-void QwtAbstractScale::setScale( const QwtInterval &interval, double stepSize )
+void QwtAbstractScale::setUpperBound( double value )
 {
-    setScale( interval.minValue(), interval.maxValue(), stepSize );
+    setScale( lowerBound(), value );
 }
 
+/*!
+  \return Upper bound of the scale
+  \sa setUpperBound(), setScale(), lowerBound()
+*/
+double QwtAbstractScale::upperBound() const
+{
+    return d_data->scaleDraw->scaleDiv().upperBound();
+}
 
 /*!
   \brief Specify a scale.
 
-  Disable autoscaling and define a scale by a scale division
+  Define a scale by an interval 
 
-  \param scaleDiv Scale division
-  \sa setAutoScale()
+  The ticks are calculated using scaleMaxMinor(), 
+  scaleMaxMajor() and scaleStepSize().
+
+  \param lowerBound lower limit of the scale interval
+  \param upperBound upper limit of the scale interval
+
+  \note For inverted scales the lower bound 
+        is greater than the upper bound
 */
-void QwtAbstractScale::setScale( const QwtScaleDiv &scaleDiv )
+void QwtAbstractScale::setScale( double lowerBound, double upperBound )
 {
-    d_data->autoScale = false;
-
-    if ( scaleDiv != d_data->scaleDraw->scaleDiv() )
-    {
-        d_data->scaleDraw->setScaleDiv( scaleDiv );
-        scaleChange();
-    }
+    rescale( lowerBound, upperBound, d_data->stepSize );
 }
 
 /*!
-  Recalculate the scale division and update the scale draw.
+  \brief Specify a scale.
 
-  \param vmin Lower limit of the scale interval
-  \param vmax Upper limit of the scale interval
-  \param stepSize Major step size
+  Define a scale by an interval
 
-  \sa scaleChange()
+  The ticks are calculated using scaleMaxMinor(), 
+  scaleMaxMajor() and scaleStepSize().
+
+  \param interval Interval
 */
-void QwtAbstractScale::rescale( double vmin, double vmax, double stepSize )
+void QwtAbstractScale::setScale( const QwtInterval &interval )
 {
-    const QwtScaleDiv scaleDiv = d_data->scaleEngine->divideScale(
-        vmin, vmax, d_data->maxMajor, d_data->maxMinor, stepSize );
-
-    if ( scaleDiv != d_data->scaleDraw->scaleDiv() )
-    {
-        d_data->scaleDraw->setTransformation(
-            d_data->scaleEngine->transformation() );
-        d_data->scaleDraw->setScaleDiv( scaleDiv );
-        scaleChange();
-    }
+    setScale( interval.minValue(), interval.maxValue() );
 }
 
 /*!
-  \brief Advise the widget to control the scale range internally.
+  \brief Specify a scale.
 
-  Autoscaling is on by default.
-  \sa setScale(), autoScale()
+  scaleMaxMinor(), scaleMaxMajor() and scaleStepSize() and have no effect.
+
+  \param scaleDiv Scale division
+  \sa setAutoScale()
 */
-void QwtAbstractScale::setAutoScale()
+void QwtAbstractScale::setScale( const QwtScaleDiv &scaleDiv )
 {
-    if ( !d_data->autoScale )
+    if ( scaleDiv != d_data->scaleDraw->scaleDiv() )
     {
-        d_data->autoScale = true;
+#if 1
+        if ( d_data->scaleEngine )
+        {
+            d_data->scaleDraw->setTransformation(
+                d_data->scaleEngine->transformation() );
+        }
+#endif
+
+        d_data->scaleDraw->setScaleDiv( scaleDiv );
+
         scaleChange();
     }
 }
 
 /*!
-  \return \c true if autoscaling is enabled
-*/
-bool QwtAbstractScale::autoScale() const
-{
-    return d_data->autoScale;
-}
-
-/*!
   \brief Set the maximum number of major tick intervals.
 
   The scale's major ticks are calculated automatically such that
   the number of major intervals does not exceed ticks.
+
   The default value is 5.
-  \param ticks maximal number of major ticks.
-  \sa QwtAbstractScaleDraw
+
+  \param ticks Maximal number of major ticks.
+
+  \sa scaleMaxMajor(), setScaleMaxMinor(),
+      setScaleStepSize(), QwtScaleEngine::divideInterval()
 */
 void QwtAbstractScale::setScaleMaxMajor( int ticks )
 {
@@ -179,13 +194,25 @@
 }
 
 /*!
+  \return Maximal number of major tick intervals
+  \sa setScaleMaxMajor(), scaleMaxMinor()
+*/
+int QwtAbstractScale::scaleMaxMajor() const
+{
+    return d_data->maxMajor;
+}
+
+/*!
   \brief Set the maximum number of minor tick intervals
 
   The scale's minor ticks are calculated automatically such that
   the number of minor intervals does not exceed ticks.
   The default value is 3.
-  \param ticks
-  \sa QwtAbstractScaleDraw
+
+  \param ticks Maximal number of minor ticks.
+
+  \sa scaleMaxMajor(), setScaleMaxMinor(),
+      setScaleStepSize(), QwtScaleEngine::divideInterval()
 */
 void QwtAbstractScale::setScaleMaxMinor( int ticks )
 {
@@ -197,8 +224,8 @@
 }
 
 /*!
-  \return Max. number of minor tick intervals
-  The default value is 3.
+  \return Maximal number of minor tick intervals
+  \sa setScaleMaxMinor(), scaleMaxMajor()
 */
 int QwtAbstractScale::scaleMaxMinor() const
 {
@@ -206,19 +233,44 @@
 }
 
 /*!
-  \return Max. number of major tick intervals
-  The default value is 5.
+   \brief Set the step size used for calculating a scale division
+
+   The step size is hint for calculating the intervals for
+   the major ticks of the scale. A value of 0.0 is interpreted
+   as no hint.
+
+   \param stepSize Hint for the step size of the scale
+
+   \sa scaleStepSize(), QwtScaleEngine::divideScale()
+
+   \note Position and distance between the major ticks also
+         depends on scaleMaxMajor().
 */
-int QwtAbstractScale::scaleMaxMajor() const
+void QwtAbstractScale::setScaleStepSize( double stepSize )
 {
-    return d_data->maxMajor;
+    if ( stepSize != d_data->stepSize )
+    {
+        d_data->stepSize = stepSize;
+        updateScaleDraw();
+    }
 }
 
 /*!
+  \return Hint for the step size of the scale
+  \sa setScaleStepSize(), QwtScaleEngine::divideScale()
+*/
+double QwtAbstractScale::scaleStepSize() const
+{
+    return d_data->stepSize;
+}
+
+/*!
   \brief Set a scale draw
 
   scaleDraw has to be created with new and will be deleted in
-  ~QwtAbstractScale or the next call of setAbstractScaleDraw.
+  the destructor or the next call of setAbstractScaleDraw().
+
+  \sa abstractScaleDraw()
 */
 void QwtAbstractScale::setAbstractScaleDraw( QwtAbstractScaleDraw *scaleDraw )
 {
@@ -250,20 +302,14 @@
     return d_data->scaleDraw;
 }
 
-void QwtAbstractScale::updateScaleDraw()
-{
-    rescale( d_data->scaleDraw->scaleDiv().lowerBound(),
-        d_data->scaleDraw->scaleDiv().upperBound(), d_data->stepSize );
-}
-
 /*!
   \brief Set a scale engine
 
-  The scale engine is responsible for calculating the scale division,
-  and in case of auto scaling how to align the scale.
+  The scale engine is responsible for calculating the scale division
+  and provides a transformation between scale and widget coordinates.
 
   scaleEngine has to be created with new and will be deleted in
-  ~QwtAbstractScale or the next call of setScaleEngine.
+  the destructor or the next call of setScaleEngine.
 */
 void QwtAbstractScale::setScaleEngine( QwtScaleEngine *scaleEngine )
 {
@@ -275,8 +321,8 @@
 }
 
 /*!
-    \return Scale engine
-    \sa setScaleEngine()
+  \return Scale engine
+  \sa setScaleEngine()
 */
 const QwtScaleEngine *QwtAbstractScale::scaleEngine() const
 {
@@ -284,8 +330,8 @@
 }
 
 /*!
-    \return Scale engine
-    \sa setScaleEngine()
+  \return Scale engine
+  \sa setScaleEngine()
 */
 QwtScaleEngine *QwtAbstractScale::scaleEngine()
 {
@@ -293,18 +339,111 @@
 }
 
 /*!
-  \brief Notify changed scale
+  \return Scale boundaries and positions of the ticks
 
-  Dummy empty implementation, intended to be overloaded by derived classes
-*/
-void QwtAbstractScale::scaleChange()
+  The scale division might have been assigned explicitly
+  or calculated implicitly by rescale(). 
+ */
+const QwtScaleDiv &QwtAbstractScale::scaleDiv() const
 {
+    return d_data->scaleDraw->scaleDiv();
 }
 
 /*!
-   \return abstractScaleDraw()->scaleMap()
-*/
+  \return Map to translate between scale and widget coordinates
+ */
 const QwtScaleMap &QwtAbstractScale::scaleMap() const
 {
     return d_data->scaleDraw->scaleMap();
 }
+
+/*!
+  Translate a scale value into a widget coordinate
+
+  \param value Scale value 
+  \return Corresponding widget coordinate for value
+  \sa scaleMap(), invTransform()
+ */
+int QwtAbstractScale::transform( double value ) const
+{
+    return qRound( d_data->scaleDraw->scaleMap().transform( value ) );
+}
+
+/*!
+  Translate a widget coordinate into a scale value
+
+  \param value Widget coordinate
+  \return Corresponding scale coordinate for value
+  \sa scaleMap(), transform()
+ */
+double QwtAbstractScale::invTransform( int value ) const
+{
+    return d_data->scaleDraw->scaleMap().invTransform( value );
+}
+
+/*!
+  \return True, when the scale is increasing in opposite direction
+          to the widget coordinates
+ */
+bool QwtAbstractScale::isInverted() const
+{
+    return d_data->scaleDraw->scaleMap().isInverting();
+}
+
+/*!
+  \return The boundary with the smaller value
+  \sa maximum(), lowerBound(), upperBound()
+ */
+double QwtAbstractScale::minimum() const
+{
+    return qMin( d_data->scaleDraw->scaleDiv().lowerBound(),
+        d_data->scaleDraw->scaleDiv().upperBound() );
+}
+
+/*!
+  \return The boundary with the larger value
+  \sa minimum(), lowerBound(), upperBound()
+ */
+double QwtAbstractScale::maximum() const
+{
+    return qMax( d_data->scaleDraw->scaleDiv().lowerBound(),
+        d_data->scaleDraw->scaleDiv().upperBound() );
+}
+
+//! Notify changed scale
+void QwtAbstractScale::scaleChange()
+{
+}
+
+/*!
+  Recalculate the scale division and update the scale.
+
+  \param lowerBound Lower limit of the scale interval
+  \param upperBound Upper limit of the scale interval
+  \param stepSize Major step size
+
+  \sa scaleChange()
+*/
+void QwtAbstractScale::rescale( 
+    double lowerBound, double upperBound, double stepSize )
+{
+    const QwtScaleDiv scaleDiv = d_data->scaleEngine->divideScale(
+        lowerBound, upperBound, d_data->maxMajor, d_data->maxMinor, stepSize );
+
+    if ( scaleDiv != d_data->scaleDraw->scaleDiv() )
+    {
+#if 1
+        d_data->scaleDraw->setTransformation(
+            d_data->scaleEngine->transformation() );
+#endif
+
+        d_data->scaleDraw->setScaleDiv( scaleDiv );
+        scaleChange();
+    }
+}
+
+void QwtAbstractScale::updateScaleDraw()
+{
+    rescale( d_data->scaleDraw->scaleDiv().lowerBound(),
+        d_data->scaleDraw->scaleDiv().upperBound(), d_data->stepSize );
+}
Index: qwt_graphic.cpp
===================================================================
--- qwt_graphic.cpp	(revision 382)
+++ qwt_graphic.cpp	(working copy)
@@ -325,24 +325,26 @@
 };
 
 /*!
-	\brief Constructor
+  \brief Constructor
 
-    Initializes a null graphic
-    \sa isNull()
+  Initializes a null graphic
+  \sa isNull()
  */
-QwtGraphic::QwtGraphic()
+QwtGraphic::QwtGraphic():
+    QwtNullPaintDevice()
 {
     setMode( QwtNullPaintDevice::PathMode );
     d_data = new PrivateData;
 }
 
 /*!
-    \brief Copy constructor
+  \brief Copy constructor
 
-    \param other Source 
-	\sa operator=()
+  \param other Source 
+  \sa operator=()
  */
-QwtGraphic::QwtGraphic( const QwtGraphic &other )
+QwtGraphic::QwtGraphic( const QwtGraphic &other ):
+    QwtNullPaintDevice()
 {
     setMode( other.mode() );
     d_data = new PrivateData( *other.d_data );
@@ -355,9 +357,10 @@
 }
 
 /*!
-    \brief Assignment operator
+  \brief Assignment operator
 
-    \param other Source 
+  \param other Source 
+  \return A reference of this object
  */
 QwtGraphic& QwtGraphic::operator=(const QwtGraphic &other)
 {
@@ -368,8 +371,8 @@
 }
 
 /*!
-    \brief Clear all stored commands 
-	\sa isNull()
+  \brief Clear all stored commands 
+  \sa isNull()
  */
 void QwtGraphic::reset() 
 {
@@ -383,8 +386,8 @@
 }
 
 /*!
-    \return True, when no painter commands have been stored
-	\sa isEmpty(), commands()
+  \return True, when no painter commands have been stored
+  \sa isEmpty(), commands()
 */
 bool QwtGraphic::isNull() const
 {
@@ -392,8 +395,8 @@
 }
 
 /*!
-	\return True, when the bounding rectangle is empty
-	\sa boundingRect(), isNull()
+  \return True, when the bounding rectangle is empty
+  \sa boundingRect(), isNull()
 */
 bool QwtGraphic::isEmpty() const
 {
@@ -401,12 +404,12 @@
 }
 
 /*!
-   Toggle an render hint
+  Toggle an render hint
 
-   \param hint Render hint
-   \param on true/false
+  \param hint Render hint
+  \param on true/false
 
-   \sa testRenderHint(), RenderHint
+  \sa testRenderHint(), RenderHint
 */
 void QwtGraphic::setRenderHint( RenderHint hint, bool on )
 {
@@ -417,11 +420,11 @@
 }
 
 /*!
-   Test a render hint
+  Test a render hint
 
-   \param hint Render hint
-   \return true/false
-   \sa setRenderHint(), RenderHint
+  \param hint Render hint
+  \return true/false
+  \sa setRenderHint(), RenderHint
 */
 bool QwtGraphic::testRenderHint( RenderHint hint ) const
 {
@@ -429,12 +432,12 @@
 }
 
 /*!
-    The bounding rectangle is the controlPointRect()
-    extended by the areas needed for rendering the outlines
-    with unscaled pens.
+  The bounding rectangle is the controlPointRect()
+  extended by the areas needed for rendering the outlines
+  with unscaled pens.
 
-    \return Bounding rectangle of the graphic
-    \sa controlPointRect(), scaledBoundingRect()
+  \return Bounding rectangle of the graphic
+  \sa controlPointRect(), scaledBoundingRect()
  */
 QRectF QwtGraphic::boundingRect() const
 {
@@ -445,11 +448,12 @@
 }
 
 /*!
-    The control point rectangle is the bounding rectangle 
-    of all control points of the paths and the target
-    rectangles of the images/pixmaps.
+  The control point rectangle is the bounding rectangle 
+  of all control points of the paths and the target
+  rectangles of the images/pixmaps.
 
-    \sa boundingRect(), scaledBoundingRect()
+  \return Control point rectangle
+  \sa boundingRect(), scaledBoundingRect()
  */
 QRectF QwtGraphic::controlPointRect() const
 {
@@ -460,16 +464,17 @@
 }
 
 /*!
-    \brief Calculate the target rectangle for scaling the graphic
+  \brief Calculate the target rectangle for scaling the graphic
 
-    \param sx Horizontal scaling factor 
-    \param sy Vertival scaling factor 
+  \param sx Horizontal scaling factor 
+  \param sy Vertical scaling factor 
 
-    \note In case of paths that are painted with a cosmetic pen 
-    ( see QPen::isCosmetic() ) the target rectangle is different to
-    multiplying the bounding rectangle.
+  \note In case of paths that are painted with a cosmetic pen 
+        ( see QPen::isCosmetic() ) the target rectangle is different to
+        multiplying the bounding rectangle.
 
-    \sa boundingRect(), controlPointRect()
+  \return Scaled bounding rectangle
+  \sa boundingRect(), controlPointRect()
  */
 QRectF QwtGraphic::scaledBoundingRect( double sx, double sy ) const
 {
@@ -490,6 +495,7 @@
     return rect;
 }
 
+//! \return Ceiled defaultSize()
 QSize QwtGraphic::sizeMetrics() const
 {
     const QSizeF sz = defaultSize();
@@ -497,38 +503,39 @@
 }
 
 /*!
-    \brief Set a default size
+  \brief Set a default size
 
-    The default size is used in all methods rendering the graphic,
-    where no size is explicitly specified. Assigning an empty size
-    means, that the default size will be calculated from the bounding 
-    rectangle.
+  The default size is used in all methods rendering the graphic,
+  where no size is explicitly specified. Assigning an empty size
+  means, that the default size will be calculated from the bounding 
+  rectangle.
 
-    The default setting is an empty size.
+  The default setting is an empty size.
     
-    \param size Default size
+  \param size Default size
 
-    \sa defaultSize(), boundingRect()
+  \sa defaultSize(), boundingRect()
  */
 void QwtGraphic::setDefaultSize( const QSizeF &size )
 {
-    const double w = qMax( 0.0, size.width() );
-    const double h = qMax( 0.0, size.height() );
+    const double w = qMax( qreal( 0.0 ), size.width() );
+    const double h = qMax( qreal( 0.0 ), size.height() );
 
     d_data->defaultSize = QSizeF( w, h );
 }
 
 /*!
-    \return Default size
+  \brief Default size
 
-    When a non empty size has been assigned by setDefaultSize() this
-    size will be returned. Otherwise the default size is the size
-    of the bounding rectangle.
+  When a non empty size has been assigned by setDefaultSize() this
+  size will be returned. Otherwise the default size is the size
+  of the bounding rectangle.
 
-    The default size is used in all methods rendering the graphic,
-    where no size is explicitly specified. 
+  The default size is used in all methods rendering the graphic,
+  where no size is explicitly specified. 
 
-    \sa setDefaultSize(), boundingRect()
+  \return Default size
+  \sa setDefaultSize(), boundingRect()
  */
 QSizeF QwtGraphic::defaultSize() const
 {
@@ -539,8 +546,8 @@
 }
 
 /*!
-	\brief Replay all recorded painter commands
-    \param painter Qt painter
+  \brief Replay all recorded painter commands
+  \param painter Qt painter
  */
 void QwtGraphic::render( QPainter *painter ) const
 {
@@ -564,14 +571,14 @@
 }
 
 /*!
-	\brief Replay all recorded painter commands
+  \brief Replay all recorded painter commands
 
-    The graphic is scaled to fit into the rectangle
-    of the given size starting at ( 0, 0 ).
+  The graphic is scaled to fit into the rectangle
+  of the given size starting at ( 0, 0 ).
 
-    \param painter Qt painter
-    \param size Size for the scaled graphic
-    \param aspectRatioMode Mode how to scale - See Qt::AspectRatioMode
+  \param painter Qt painter
+  \param size Size for the scaled graphic
+  \param aspectRatioMode Mode how to scale - See Qt::AspectRatioMode
  */
 void QwtGraphic::render( QPainter *painter, const QSizeF &size, 
     Qt::AspectRatioMode aspectRatioMode ) const
@@ -581,13 +588,13 @@
 }
 
 /*!
-    \brief Replay all recorded painter commands
+  \brief Replay all recorded painter commands
 
-    The graphic is scaled to fit into the given rectangle
+  The graphic is scaled to fit into the given rectangle
 
-    \param painter Qt painter
-    \param rect Rectangle for the scaled graphic
-    \param aspectRatioMode Mode how to scale - See Qt::AspectRatioMode
+  \param painter Qt painter
+  \param rect Rectangle for the scaled graphic
+  \param aspectRatioMode Mode how to scale - See Qt::AspectRatioMode
  */
 void QwtGraphic::render( QPainter *painter, const QRectF &rect, 
     Qt::AspectRatioMode aspectRatioMode ) const
@@ -652,17 +659,16 @@
 }
 
 /*!
-    \brief Replay all recorded painter commands
+  \brief Replay all recorded painter commands
 
-    The graphic is scaled to the defaultSize() and aligned
-    to a position.
+  The graphic is scaled to the defaultSize() and aligned
+  to a position.
 
-    \param painter Qt painter
-    \param pos Reference point, where to render
-    \param alignment Flags how to align the target rectangle 
-                     to pos.
+  \param painter Qt painter
+  \param pos Reference point, where to render
+  \param alignment Flags how to align the target rectangle 
+                   to pos.
  */
-
 void QwtGraphic::render( QPainter *painter, 
     const QPointF &pos, Qt::Alignment alignment ) const
 {
@@ -698,15 +704,16 @@
 }
 
 /*!
-    \brief Convert the graphic to a QPixmap
+  \brief Convert the graphic to a QPixmap
     
-    All pixels of the pixmap get initialized by Qt::transparent
-    before the graphic is scaled and rendered on it.
+  All pixels of the pixmap get initialized by Qt::transparent
+  before the graphic is scaled and rendered on it.
     
-    The size of the pixmap is the default size ( ceiled to integers )
-    of the graphic.
-    
-    \sa defaultSize(), toImage(), render()
+  The size of the pixmap is the default size ( ceiled to integers )
+  of the graphic.
+
+  \return The graphic as pixmap in default size
+  \sa defaultSize(), toImage(), render()
  */ 
 QPixmap QwtGraphic::toPixmap() const
 {
@@ -731,15 +738,16 @@
 }
 
 /*!
-    \brief Convert the graphic to a QPixmap
+  \brief Convert the graphic to a QPixmap
 
-    All pixels of the pixmap get initialized by Qt::transparent
-    before the graphic is scaled and rendered on it.
+  All pixels of the pixmap get initialized by Qt::transparent
+  before the graphic is scaled and rendered on it.
 
-    \param size Size of the image
-    \param aspectRatioMode Aspect ratio how to scale the graphic
+  \param size Size of the image
+  \param aspectRatioMode Aspect ratio how to scale the graphic
 
-    \sa toImage(), render()
+  \return The graphic as pixmap
+  \sa toImage(), render()
  */
 QPixmap QwtGraphic::toPixmap( const QSize &size,
     Qt::AspectRatioMode aspectRatioMode ) const
@@ -757,17 +765,18 @@
 }
 
 /*!
-	\brief Convert the graphic to a QImage
+  \brief Convert the graphic to a QImage
 
-    All pixels of the image get initialized by 0 ( transparent )
-    before the graphic is scaled and rendered on it.
+  All pixels of the image get initialized by 0 ( transparent )
+  before the graphic is scaled and rendered on it.
 
-    The format of the image is QImage::Format_ARGB32_Premultiplied.
+  The format of the image is QImage::Format_ARGB32_Premultiplied.
 
-    \param size Size of the image
-    \param aspectRatioMode Aspect ratio how to scale the graphic
+  \param size Size of the image
+  \param aspectRatioMode Aspect ratio how to scale the graphic
 
-    \sa toPixmap(), render()
+  \return The graphic as image
+  \sa toPixmap(), render()
  */
 QImage QwtGraphic::toImage( const QSize &size,
     Qt::AspectRatioMode aspectRatioMode  ) const
@@ -785,17 +794,18 @@
 }
 
 /*!
-    \brief Convert the graphic to a QImage
+  \brief Convert the graphic to a QImage
     
-    All pixels of the image get initialized by 0 ( transparent )
-    before the graphic is scaled and rendered on it.
+  All pixels of the image get initialized by 0 ( transparent )
+  before the graphic is scaled and rendered on it.
 
-    The format of the image is QImage::Format_ARGB32_Premultiplied.
+  The format of the image is QImage::Format_ARGB32_Premultiplied.
 
-    The size of the image is the default size ( ceiled to integers )
-    of the graphic.
+  The size of the image is the default size ( ceiled to integers )
+  of the graphic.
     
-    \sa defaultSize(), toPixmap(), render()
+  \return The graphic as image in default size
+  \sa defaultSize(), toPixmap(), render()
  */
 QImage QwtGraphic::toImage() const
 {
@@ -820,8 +830,10 @@
 }
 
 /*!
-    Store a path command in the command list
-    \sa QPaintEngine::drawPath()
+  Store a path command in the command list
+
+  \param path Painter path
+  \sa QPaintEngine::drawPath()
 */
 void QwtGraphic::drawPath( const QPainterPath &path )
 {
@@ -853,11 +865,16 @@
 }
 
 /*!
-    Store a image command in the command list
-    \sa QPaintEngine::drawPixmap()
+  \brief Store a pixmap command in the command list
+
+  \param rect target rectangle
+  \param pixmap Pixmap to be painted
+  \param subRect Reactangle of the pixmap to be painted
+
+  \sa QPaintEngine::drawPixmap()
 */
 void QwtGraphic::drawPixmap( const QRectF &rect, 
-	const QPixmap &pixmap, const QRectF &subRect )
+    const QPixmap &pixmap, const QRectF &subRect )
 {
     const QPainter *painter = paintEngine()->painter();
     if ( painter == NULL )
@@ -871,8 +888,14 @@
 }
 
 /*!
-    Store a image command in the command list
-    \sa QPaintEngine::drawImage()
+  \brief Store a image command in the command list
+
+  \param rect traget rectangle
+  \param image Image to be painted
+  \param subRect Reactangle of the pixmap to be painted
+  \param flags Image conversion flags
+
+  \sa QPaintEngine::drawImage()
  */
 void QwtGraphic::drawImage( const QRectF &rect, const QImage &image,
     const QRectF &subRect, Qt::ImageConversionFlags flags)
@@ -890,8 +913,10 @@
 }
 
 /*!
-    Store a state command in the command list
-    \sa QPaintEngine::updateState()
+  \brief Store a state command in the command list
+
+  \param state State to be stored
+  \sa QPaintEngine::updateState()
  */
 void QwtGraphic::updateState( const QPaintEngineState &state)
 {
@@ -926,8 +951,8 @@
 }
 
 /*!
-    \return List of recorded paint commands
-    \sa setCommands()
+  \return List of recorded paint commands
+  \sa setCommands()
  */
 const QVector< QwtPainterCommand > &QwtGraphic::commands() const
 {
@@ -935,10 +960,10 @@
 }
 
 /*!
-   \brief Append paint commands
+  \brief Append paint commands
 
-   \param commands Paint commands
-   \sa commands()
+  \param commands Paint commands
+  \sa commands()
  */
 void QwtGraphic::setCommands( QVector< QwtPainterCommand > &commands )
 {
@@ -959,5 +984,3 @@
 
     painter.end();
 }
-
-
Index: qwt_counter.cpp
===================================================================
--- qwt_counter.cpp	(revision 382)
+++ qwt_counter.cpp	(working copy)
@@ -20,7 +20,12 @@
 {
 public:
     PrivateData():
-        editable( true )
+        minimum( 0.0 ),
+        maximum( 0.0 ),
+        singleStep( 1.0 ),
+        isValid( false ),
+        value( 0.0 ),
+        wrapping( false )
     {
         increment[Button1] = 1;
         increment[Button2] = 10;
@@ -34,10 +39,20 @@
     int increment[ButtonCnt];
     int numButtons;
 
-    bool editable;
+    double minimum;
+    double maximum;
+    double singleStep;
+
+    bool isValid;
+    double value;
+
+    bool wrapping;
 };
 
 /*!
+  The counter is initialized with a range is set to [0.0, 1.0] with 
+  0.01 as single step size. The value is invalid.
+
   The default number of buttons is set to 2. The default increments are:
   \li Button 1: 1 step
   \li Button 2: 10 steps
@@ -98,7 +113,8 @@
     }
 
     setNumButtons( 2 );
-    setRange( 0.0, 1.0, 0.001 );
+    setRange( 0.0, 1.0 );
+    setSingleStep( 0.001 );
     setValue( 0.0 );
 
     setSizePolicy(
@@ -114,43 +130,358 @@
     delete d_data;
 }
 
-//! Set from lineedit
-void QwtCounter::textChanged()
+/*! 
+  Set the counter to be in valid/invalid state
+
+  When the counter is set to invalid, no numbers are displayed and
+  the buttons are disabled.
+
+  \param on If true the counter will be set as valid 
+
+  \sa setValue(), isValid()
+*/
+void QwtCounter::setValid( bool on )
 {
-    if ( !d_data->editable )
+    if ( on != d_data->isValid )
+    {
+        d_data->isValid = on;
+
+        updateButtons();
+
+        if ( d_data->isValid )
+        {
+            showNumber( value() );
+            Q_EMIT valueChanged( value() );
+        }
+        else
+        {
+            d_data->valueEdit->setText( QString::null );
+        }
+    }   
+}   
+
+/*! 
+  \return True, if the value is valid
+  \sa setValid(), setValue()
+ */
+bool QwtCounter::isValid() const
+{
+    return d_data->isValid;
+}   
+
+/*!
+  \brief Allow/disallow the user to manually edit the value
+
+  \param on True disable editing
+  \sa isReadOnly()
+*/
+void QwtCounter::setReadOnly( bool on )
+{
+    d_data->valueEdit->setReadOnly( on );
+}
+
+/*! 
+   \return True, when the line line edit is read only. (default is no)
+  \sa setReadOnly()
+ */
+bool QwtCounter::isReadOnly() const
+{
+    return d_data->valueEdit->isReadOnly();
+}
+
+/*!
+  \brief Set a new value without adjusting to the step raster
+
+  The state of the counter is set to be valid.
+
+  \param value New value
+
+  \sa isValid(), value(), valueChanged()
+  \warning The value is clipped when it lies outside the range.
+*/
+
+void QwtCounter::setValue( double value )
+{
+    const double vmin = qMin( d_data->minimum, d_data->maximum );
+    const double vmax = qMax( d_data->minimum, d_data->maximum );
+
+    value = qBound( vmin, value, vmax );
+
+    if ( !d_data->isValid || value != d_data->value )
+    {
+        d_data->isValid = true;
+        d_data->value = value;
+
+        showNumber( value );
+        updateButtons();
+
+        Q_EMIT valueChanged( value );
+    }
+}
+
+/*!
+  \return Current value of the counter
+  \sa setValue(), valueChanged()
+ */
+double QwtCounter::value() const
+{
+    return d_data->value;
+}
+
+/*!
+  \brief Set the minimum and maximum values
+
+  The maximum is adjusted if necessary to ensure that the range remains valid.
+  The value might be modified to be inside of the range.
+
+  \param min Minimum value
+  \param max Maximum value
+
+  \sa minimum(), maximum()
+ */
+void QwtCounter::setRange( double min, double max )
+{
+    max = qMax( min, max );
+
+    if ( d_data->maximum == max && d_data->minimum == min )
         return;
 
-    bool converted = false;
+    d_data->minimum = min;
+    d_data->maximum = max;
 
-    const double value = d_data->valueEdit->text().toDouble( &converted );
-    if ( converted )
-        setValue( value );
+    setSingleStep( singleStep() );
+
+    const double value = qBound( min, d_data->value, max );
+
+    if ( value != d_data->value )
+    {
+        d_data->value = value;
+
+        if ( d_data->isValid )
+        {
+            showNumber( value );
+            Q_EMIT valueChanged( value );
+        }
+    }
+
+    updateButtons();
 }
 
-/**
-  \brief Allow/disallow the user to manually edit the value
+/*!
+  Set the minimum value of the range
 
-  \param editable true enables editing
-  \sa editable()
+  \param value Minimum value
+  \sa setRange(), setMaximum(), minimum()
+
+  \note The maximum is adjusted if necessary to ensure that the range remains valid.
 */
-void QwtCounter::setEditable( bool editable )
+void QwtCounter::setMinimum( double value )
 {
-    if ( editable == d_data->editable )
+    setRange( value, maximum() );
+}
+
+/*!
+  \return The minimum of the range
+  \sa setRange(), setMinimum(), maximum()
+*/
+double QwtCounter::minimum() const
+{
+    return d_data->minimum;
+}
+
+/*!
+  Set the maximum value of the range
+
+  \param value Maximum value
+  \sa setRange(), setMinimum(), maximum()
+*/
+void QwtCounter::setMaximum( double value )
+{
+    setRange( minimum(), value );
+}
+
+/*!
+  \return The maximum of the range
+  \sa setRange(), setMaximum(), minimum()
+*/
+double QwtCounter::maximum() const
+{
+    return d_data->maximum;
+}
+
+/*!
+  \brief Set the step size of the counter
+
+  A value <= 0.0 disables stepping
+
+  \param stepSize Single step size
+  \sa singleStep()
+*/
+void QwtCounter::setSingleStep( double stepSize )
+{
+    d_data->singleStep = qMax( stepSize, 0.0 );
+}
+
+/*!
+  \return Single step size
+  \sa setSingleStep()
+ */
+double QwtCounter::singleStep() const
+{
+    return d_data->singleStep;
+}
+
+/*!
+  \brief En/Disable wrapping
+
+  If wrapping is true stepping up from maximum() value will take 
+  you to the minimum() value and vice versa. 
+
+  \param on En/Disable wrapping
+  \sa wrapping()
+ */
+void QwtCounter::setWrapping( bool on )
+{
+    d_data->wrapping = on;
+}
+
+/*!
+  \return True, when wrapping is set
+  \sa setWrapping()
+ */
+bool QwtCounter::wrapping() const
+{
+    return d_data->wrapping;
+}
+
+/*!
+  Specify the number of buttons on each side of the label
+
+  \param numButtons Number of buttons
+  \sa numButtons()
+*/
+void QwtCounter::setNumButtons( int numButtons )
+{
+    if ( numButtons < 0 || numButtons > QwtCounter::ButtonCnt )
         return;
 
-    d_data->editable = editable;
-    d_data->valueEdit->setReadOnly( !editable );
+    for ( int i = 0; i < QwtCounter::ButtonCnt; i++ )
+    {
+        if ( i < numButtons )
+        {
+            d_data->buttonDown[i]->show();
+            d_data->buttonUp[i]->show();
+        }
+        else
+        {
+            d_data->buttonDown[i]->hide();
+            d_data->buttonUp[i]->hide();
+        }
+    }
+
+    d_data->numButtons = numButtons;
 }
 
-//! returns whether the line edit is edatble. (default is yes)
-bool QwtCounter::editable() const
+/*!
+  \return The number of buttons on each side of the widget.
+  \sa setNumButtons()
+*/
+int QwtCounter::numButtons() const
 {
-    return d_data->editable;
+    return d_data->numButtons;
 }
 
 /*!
-   Handle PolishRequest events
+  Specify the number of steps by which the value
+  is incremented or decremented when a specified button
+  is pushed.
+
+  \param button Button index
+  \param numSteps Number of steps
+
+  \sa incSteps()
+*/
+void QwtCounter::setIncSteps( QwtCounter::Button button, int numSteps )
+{
+    if ( button >= 0 && button < QwtCounter::ButtonCnt )
+        d_data->increment[ button ] = numSteps;
+}
+
+/*!
+  \return The number of steps by which a specified button increments the value
+          or 0 if the button is invalid.
+  \param button Button index
+
+  \sa setIncSteps()
+*/
+int QwtCounter::incSteps( QwtCounter::Button button ) const
+{
+    if ( button >= 0 && button < QwtCounter::ButtonCnt )
+        return d_data->increment[ button ];
+
+    return 0;
+}
+
+
+/*!
+  Set the number of increment steps for button 1
+  \param nSteps Number of steps
+*/
+void QwtCounter::setStepButton1( int nSteps )
+{
+    setIncSteps( QwtCounter::Button1, nSteps );
+}
+
+//! returns the number of increment steps for button 1
+int QwtCounter::stepButton1() const
+{
+    return incSteps( QwtCounter::Button1 );
+}
+
+/*!
+  Set the number of increment steps for button 2
+  \param nSteps Number of steps
+*/
+void QwtCounter::setStepButton2( int nSteps )
+{
+    setIncSteps( QwtCounter::Button2, nSteps );
+}
+
+//! returns the number of increment steps for button 2
+int QwtCounter::stepButton2() const
+{
+    return incSteps( QwtCounter::Button2 );
+}
+
+/*!
+  Set the number of increment steps for button 3
+  \param nSteps Number of steps
+*/
+void QwtCounter::setStepButton3( int nSteps )
+{
+    setIncSteps( QwtCounter::Button3, nSteps );
+}
+
+//! returns the number of increment steps for button 3
+int QwtCounter::stepButton3() const
+{
+    return incSteps( QwtCounter::Button3 );
+}
+
+//! Set from lineedit
+void QwtCounter::textChanged()
+{
+    bool converted = false;
+
+    const double value = d_data->valueEdit->text().toDouble( &converted );
+    if ( converted )
+        setValue( value );
+}
+
+/*!
+   Handle QEvent::PolishRequest events
    \param event Event
+   \return see QWidget::event()
 */
 bool QwtCounter::event( QEvent *event )
 {
@@ -171,9 +502,9 @@
   Handle key events
 
   - Ctrl + Qt::Key_Home\n
-    Step to minValue()
+    Step to minimum()
   - Ctrl + Qt::Key_End\n
-    Step to maxValue()
+    Step to maximum()
   - Qt::Key_Up\n
     Increment by incSteps(QwtCounter::Button1)
   - Qt::Key_Down\n
@@ -198,7 +529,7 @@
         case Qt::Key_Home:
         {
             if ( event->modifiers() & Qt::ControlModifier )
-                setValue( minValue() );
+                setValue( minimum() );
             else
                 accepted = false;
             break;
@@ -206,19 +537,19 @@
         case Qt::Key_End:
         {
             if ( event->modifiers() & Qt::ControlModifier )
-                setValue( maxValue() );
+                setValue( maximum() );
             else
                 accepted = false;
             break;
         }
         case Qt::Key_Up:
         {
-            incValue( d_data->increment[0] );
+            incrementValue( d_data->increment[0] );
             break;
         }
         case Qt::Key_Down:
         {
-            incValue( -d_data->increment[0] );
+            incrementValue( -d_data->increment[0] );
             break;
         }
         case Qt::Key_PageUp:
@@ -234,7 +565,7 @@
             }
             if ( event->key() == Qt::Key_PageDown )
                 increment = -increment;
-            incValue( increment );
+            incrementValue( increment );
             break;
         }
         default:
@@ -286,77 +617,67 @@
 
     const int wheel_delta = 120;
 
+#if 1
     int delta = event->delta();
     if ( delta >= 2 * wheel_delta )
         delta /= 2; // Never saw an abs(delta) < 240
+#endif
 
-    incValue( delta / wheel_delta * increment );
+    incrementValue( delta / wheel_delta * increment );
 }
 
-/*!
-  Specify the number of steps by which the value
-  is incremented or decremented when a specified button
-  is pushed.
+void QwtCounter::incrementValue( int numSteps )
+{
+    const double min = d_data->minimum;
+    const double max = d_data->maximum;
+    double stepSize = d_data->singleStep;
 
-  \param button Button index
-  \param nSteps Number of steps
+    if ( !d_data->isValid || min >= max || stepSize <= 0.0 )
+        return;
 
-  \sa incSteps()
-*/
-void QwtCounter::setIncSteps( QwtCounter::Button button, int nSteps )
-{
-    if ( button >= 0 && button < ButtonCnt )
-        d_data->increment[button] = nSteps;
-}
 
-/*!
-  \return the number of steps by which a specified button increments the value
-  or 0 if the button is invalid.
-  \param button Button index
+#if 1
+    stepSize = qMax( stepSize, 1.0e-10 * ( max - min ) );
+#endif
 
-  \sa setIncSteps()
-*/
-int QwtCounter::incSteps( QwtCounter::Button button ) const
-{
-    if ( button >= 0 && button < ButtonCnt )
-        return d_data->increment[button];
+    double value = d_data->value + numSteps * stepSize;
 
-    return 0;
-}
+    if ( d_data->wrapping )
+    {
+        const double range = max - min;
 
-/*!
-  \brief Set a new value
+        if ( value < min )
+        {
+            value += ::ceil( ( min - value ) / range ) * range;
+        }
+        else if ( value > max )
+        {
+            value -= ::ceil( ( value - max ) / range ) * range;
+        }
+    }
+    else
+    {
+        value = qBound( min, value, max );
+    }
 
-  Calls QwtDoubleRange::setValue and does all visual updates.
+    value = min + qRound( ( value - min ) / stepSize ) * stepSize;
+    if ( qFuzzyCompare( value, max ) )
+        value = max;
 
-  \param value New value
-  \sa QwtDoubleRange::setValue()
-*/
+    if ( qFuzzyCompare( value + 1.0, 1.0 ) )
+        value = 0.0;
 
-void QwtCounter::setValue( double value )
-{
-    QwtDoubleRange::setValue( value );
+    if ( value != d_data->value )
+    {
+        d_data->value = value;
+        showNumber( d_data->value );
+        updateButtons();
 
-    showNum( this->value() );
-    updateButtons();
+        Q_EMIT valueChanged( d_data->value );
+    }
 }
 
-/*!
-  \brief Notify a change of value
-*/
-void QwtCounter::valueChange()
-{
-    if ( isValid() )
-        showNum( value() );
-    else
-        d_data->valueEdit->setText( QString::null );
 
-    updateButtons();
-
-    if ( isValid() )
-        Q_EMIT valueChanged( value() );
-}
-
 /*!
   \brief Update buttons according to the current value
 
@@ -367,15 +688,15 @@
 */
 void QwtCounter::updateButtons()
 {
-    if ( isValid() )
+    if ( d_data->isValid )
     {
         // 1. save enabled state of the smallest down- and up-button
         // 2. change enabled state on under- or over-flow
 
         for ( int i = 0; i < QwtCounter::ButtonCnt; i++ )
         {
-            d_data->buttonDown[i]->setEnabled( value() > minValue() );
-            d_data->buttonUp[i]->setEnabled( value() < maxValue() );
+            d_data->buttonDown[i]->setEnabled( value() > minimum() );
+            d_data->buttonUp[i]->setEnabled( value() < maximum() );
         }
     }
     else
@@ -387,47 +708,12 @@
         }
     }
 }
-
 /*!
-  \brief Specify the number of buttons on each side of the label
-  \param numButtons Number of buttons
-*/
-void QwtCounter::setNumButtons( int numButtons )
-{
-    if ( numButtons < 0 || numButtons > QwtCounter::ButtonCnt )
-        return;
-
-    for ( int i = 0; i < QwtCounter::ButtonCnt; i++ )
-    {
-        if ( i < numButtons )
-        {
-            d_data->buttonDown[i]->show();
-            d_data->buttonUp[i]->show();
-        }
-        else
-        {
-            d_data->buttonDown[i]->hide();
-            d_data->buttonUp[i]->hide();
-        }
-    }
-
-    d_data->numButtons = numButtons;
-}
-
-/*!
-    \return The number of buttons on each side of the widget.
-*/
-int QwtCounter::numButtons() const
-{
-    return d_data->numButtons;
-}
-
-/*!
   Display number string
 
   \param number Number
 */
-void QwtCounter::showNum( double number )
+void QwtCounter::showNumber( double number )
 {
     QString text;
     text.setNum( number );
@@ -443,10 +729,10 @@
     for ( int i = 0; i < ButtonCnt; i++ )
     {
         if ( d_data->buttonUp[i] == sender() )
-            incValue( d_data->increment[i] );
+            incrementValue( d_data->increment[i] );
 
         if ( d_data->buttonDown[i] == sender() )
-            incValue( -d_data->increment[i] );
+            incrementValue( -d_data->increment[i] );
     }
 }
 
@@ -456,30 +742,19 @@
     Q_EMIT buttonReleased( value() );
 }
 
-/*!
-  \brief Notify change of range
-
-  This function updates the enabled property of
-  all buttons contained in QwtCounter.
-*/
-void QwtCounter::rangeChange()
-{
-    updateButtons();
-}
-
 //! A size hint
 QSize QwtCounter::sizeHint() const
 {
     QString tmp;
 
-    int w = tmp.setNum( minValue() ).length();
-    int w1 = tmp.setNum( maxValue() ).length();
+    int w = tmp.setNum( minimum() ).length();
+    int w1 = tmp.setNum( maximum() ).length();
     if ( w1 > w )
         w = w1;
-    w1 = tmp.setNum( minValue() + step() ).length();
+    w1 = tmp.setNum( minimum() + singleStep() ).length();
     if ( w1 > w )
         w = w1;
-    w1 = tmp.setNum( maxValue() - step() ).length();
+    w1 = tmp.setNum( maximum() - singleStep() ).length();
     if ( w1 > w )
         w = w1;
 
@@ -499,105 +774,3 @@
         d_data->valueEdit->minimumSizeHint().height() );
     return QSize( w, h );
 }
-
-//! returns the step size
-double QwtCounter::step() const
-{
-    return QwtDoubleRange::step();
-}
-
-/*!
-   Set the step size
-   \param stepSize Step size
-   \sa QwtDoubleRange::setStep()
-*/
-void QwtCounter::setStep( double stepSize )
-{
-    QwtDoubleRange::setStep( stepSize );
-}
-
-//! returns the minimum value of the range
-double QwtCounter::minValue() const
-{
-    return QwtDoubleRange::minValue();
-}
-
-/*!
-  Set the minimum value of the range
-
-  \param value Minimum value
-  \sa setMaxValue(), minValue()
-*/
-void QwtCounter::setMinValue( double value )
-{
-    setRange( value, maxValue(), step() );
-}
-
-//! returns the maximum value of the range
-double QwtCounter::maxValue() const
-{
-    return QwtDoubleRange::maxValue();
-}
-
-/*!
-  Set the maximum value of the range
-
-  \param value Maximum value
-  \sa setMinValue(), maxVal()
-*/
-void QwtCounter::setMaxValue( double value )
-{
-    setRange( minValue(), value, step() );
-}
-
-/*!
-  Set the number of increment steps for button 1
-  \param nSteps Number of steps
-*/
-void QwtCounter::setStepButton1( int nSteps )
-{
-    setIncSteps( Button1, nSteps );
-}
-
-//! returns the number of increment steps for button 1
-int QwtCounter::stepButton1() const
-{
-    return incSteps( Button1 );
-}
-
-/*!
-  Set the number of increment steps for button 2
-  \param nSteps Number of steps
-*/
-void QwtCounter::setStepButton2( int nSteps )
-{
-    setIncSteps( Button2, nSteps );
-}
-
-//! returns the number of increment steps for button 2
-int QwtCounter::stepButton2() const
-{
-    return incSteps( Button2 );
-}
-
-/*!
-  Set the number of increment steps for button 3
-  \param nSteps Number of steps
-*/
-void QwtCounter::setStepButton3( int nSteps )
-{
-    setIncSteps( Button3, nSteps );
-}
-
-//! returns the number of increment steps for button 3
-int QwtCounter::stepButton3() const
-{
-    return incSteps( Button3 );
-}
-
-//! \return Current value
-double QwtCounter::value() const
-{
-    return QwtDoubleRange::value();
-}
-
Index: qwt_plot_picker.h
===================================================================
--- qwt_plot_picker.h	(revision 382)
+++ qwt_plot_picker.h	(working copy)
@@ -15,14 +15,13 @@
 #include <qvector.h>
 
 class QwtPlot;
-class QwtPlotCanvas;
 
 /*!
   \brief QwtPlotPicker provides selections on a plot canvas
 
   QwtPlotPicker is a QwtPicker tailored for selections on
   a plot canvas. It is set to a x-Axis and y-Axis and
-  translates all pixel coordinates into this coodinate system.
+  translates all pixel coordinates into this coordinate system.
 */
 
 class QWT_EXPORT QwtPlotPicker: public QwtPicker
@@ -30,14 +29,13 @@
     Q_OBJECT
 
 public:
-    explicit QwtPlotPicker( QwtPlotCanvas * );
+    explicit QwtPlotPicker( QWidget *canvas );
     virtual ~QwtPlotPicker();
 
-    explicit QwtPlotPicker( int xAxis, int yAxis, QwtPlotCanvas * );
+    explicit QwtPlotPicker( int xAxis, int yAxis, QWidget * );
 
     explicit QwtPlotPicker( int xAxis, int yAxis,
-        RubberBand rubberBand, DisplayMode trackerMode,
-        QwtPlotCanvas * );
+        RubberBand rubberBand, DisplayMode trackerMode, QWidget * );
 
     virtual void setAxis( int xAxis, int yAxis );
 
@@ -47,19 +45,19 @@
     QwtPlot *plot();
     const QwtPlot *plot() const;
 
-    QwtPlotCanvas *canvas();
-    const QwtPlotCanvas *canvas() const;
+    QWidget *canvas();
+    const QWidget *canvas() const;
 
 Q_SIGNALS:
 
     /*!
-      A signal emitted in case of selectionFlags() & PointSelection.
+      A signal emitted in case of QwtPickerMachine::PointSelection.
       \param pos Selected point
     */
     void selected( const QPointF &pos );
 
     /*!
-      A signal emitted in case of selectionFlags() & RectSelection.
+      A signal emitted in case of QwtPickerMachine::RectSelection.
       \param rect Selected rectangle
     */
     void selected( const QRectF &rect );
Index: qwt_picker.h
===================================================================
--- qwt_picker.h	(revision 382)
+++ qwt_picker.h	(working copy)
@@ -24,6 +24,7 @@
 class QWheelEvent;
 class QKeyEvent;
 class QwtPickerMachine;
+class QwtWidgetOverlay;
 
 /*!
   \brief QwtPicker provides selections on a widget
@@ -48,12 +49,12 @@
   it is also possible to implement individual machines as well.
 
   QwtPicker translates the picked points into a selection using the
-  adjustedPoints method. adjustedPoints is intended to be reimplemented
-  to fixup the selection according to application specific requirements.
+  adjustedPoints() method. adjustedPoints() is intended to be reimplemented
+  to fix up the selection according to application specific requirements.
   (F.e. when an application accepts rectangles of a fixed aspect ratio only.)
 
   Optionally QwtPicker support the process of collecting points by a
-  rubberband and tracker displaying a text for the current mouse
+  rubber band and tracker displaying a text for the current mouse
   position.
 
   \par Example
@@ -79,7 +80,7 @@
     Terminate the selection and call accept to validate the picked points.
 
   The picker is active (isActive()), between begin() and end().
-  In active state the rubberband is displayed, and the tracker is visible
+  In active state the rubber band is displayed, and the tracker is visible
   in case of trackerMode is ActiveOnly or AlwaysOn.
 
   The cursor can be moved using the arrow keys. All selections can be aborted
@@ -95,9 +96,7 @@
 {
     Q_OBJECT
 
-    Q_ENUMS( RubberBand )
-    Q_ENUMS( DisplayMode )
-    Q_ENUMS( ResizeMode )
+    Q_ENUMS( RubberBand DisplayMode ResizeMode )
 
     Q_PROPERTY( bool isEnabled READ isEnabled WRITE setEnabled )
     Q_PROPERTY( ResizeMode resizeMode READ resizeMode WRITE setResizeMode )
@@ -111,7 +110,7 @@
 
 public:
     /*!
-      Rubberband style
+      Rubber band style
 
       The default value is QwtPicker::NoRubberBand.
       \sa setRubberBand(), rubberBand()
@@ -122,22 +121,22 @@
         //! No rubberband.
         NoRubberBand = 0,
 
-        //! A horizontal line ( only for QwtPicker::PointSelection )
+        //! A horizontal line ( only for QwtPickerMachine::PointSelection )
         HLineRubberBand,
 
-        //! A vertical line ( only for QwtPicker::PointSelection )
+        //! A vertical line ( only for QwtPickerMachine::PointSelection )
         VLineRubberBand,
 
-        //! A crosshair ( only for QwtPicker::PointSelection )
+        //! A crosshair ( only for QwtPickerMachine::PointSelection )
         CrossRubberBand,
 
-        //! A rectangle ( only for QwtPicker::RectSelection )
+        //! A rectangle ( only for QwtPickerMachine::RectSelection )
         RectRubberBand,
 
-        //! An ellipse ( only for QwtPicker::RectSelection )
+        //! An ellipse ( only for QwtPickerMachine::RectSelection )
         EllipseRubberBand,
 
-        //! A polygon ( only for QwtPicker::&PolygonSelection )
+        //! A polygon ( only for QwtPickerMachine::PolygonSelection )
         PolygonRubberBand,
 
         /*!
@@ -221,6 +220,8 @@
     virtual void drawRubberBand( QPainter * ) const;
     virtual void drawTracker( QPainter * ) const;
 
+    virtual QRegion rubberBandMask() const;
+
     virtual QwtText trackerText( const QPoint &pos ) const;
     QPoint trackerPosition() const;
     virtual QRect trackerRect( const QFont & ) const;
@@ -269,6 +270,7 @@
       A signal emitted whenever the last appended point of the
       selection has been removed.
 
+      \param pos Position of the point, that has been removed
       \sa remove(), appended()
     */
     void removed( const QPoint &pos );
@@ -310,8 +312,8 @@
 
     virtual void updateDisplay();
 
-    const QWidget *rubberBandWidget() const;
-    const QWidget *trackerWidget() const;
+    const QwtWidgetOverlay *rubberBandOverlay() const;
+    const QwtWidgetOverlay *trackerOverlay() const;
 
     const QPolygon &pickedPoints() const;
 
@@ -320,7 +322,6 @@
 
     void setMouseTracking( bool );
 
-    class PickerWidget;
     class PrivateData;
     PrivateData *d_data;
 };
Index: qwt_plot_grid.cpp
===================================================================
--- qwt_plot_grid.cpp	(revision 382)
+++ qwt_plot_grid.cpp	(working copy)
@@ -35,8 +35,8 @@
     QwtScaleDiv xScaleDiv;
     QwtScaleDiv yScaleDiv;
 
-    QPen majPen;
-    QPen minPen;
+    QPen majorPen;
+    QPen minorPen;
 };
 
 //! Enables major grid, disables minor grid
@@ -62,17 +62,17 @@
 }
 
 /*!
-  \brief Enable or disable vertical gridlines
-  \param tf Enable (true) or disable
+  \brief Enable or disable vertical grid lines
+  \param on Enable (true) or disable
 
-  \sa Minor gridlines can be enabled or disabled with
+  \sa Minor grid lines can be enabled or disabled with
       enableXMin()
 */
-void QwtPlotGrid::enableX( bool tf )
+void QwtPlotGrid::enableX( bool on )
 {
-    if ( d_data->xEnabled != tf )
+    if ( d_data->xEnabled != on )
     {
-        d_data->xEnabled = tf;
+        d_data->xEnabled = on;
 
         legendChanged();
         itemChanged();
@@ -80,15 +80,15 @@
 }
 
 /*!
-  \brief Enable or disable horizontal gridlines
-  \param tf Enable (true) or disable
-  \sa Minor gridlines can be enabled or disabled with enableYMin()
+  \brief Enable or disable horizontal grid lines
+  \param on Enable (true) or disable
+  \sa Minor grid lines can be enabled or disabled with enableYMin()
 */
-void QwtPlotGrid::enableY( bool tf )
+void QwtPlotGrid::enableY( bool on )
 {
-    if ( d_data->yEnabled != tf )
+    if ( d_data->yEnabled != on )
     {
-        d_data->yEnabled = tf;
+        d_data->yEnabled = on;
 
         legendChanged();
         itemChanged();
@@ -96,15 +96,15 @@
 }
 
 /*!
-  \brief Enable or disable  minor vertical gridlines.
-  \param tf Enable (true) or disable
+  \brief Enable or disable  minor vertical grid lines.
+  \param on Enable (true) or disable
   \sa enableX()
 */
-void QwtPlotGrid::enableXMin( bool tf )
+void QwtPlotGrid::enableXMin( bool on )
 {
-    if ( d_data->xMinEnabled != tf )
+    if ( d_data->xMinEnabled != on )
     {
-        d_data->xMinEnabled = tf;
+        d_data->xMinEnabled = on;
 
         legendChanged();
         itemChanged();
@@ -112,15 +112,15 @@
 }
 
 /*!
-  \brief Enable or disable minor horizontal gridlines
-  \param tf Enable (true) or disable
+  \brief Enable or disable minor horizontal grid lines
+  \param on Enable (true) or disable
   \sa enableY()
 */
-void QwtPlotGrid::enableYMin( bool tf )
+void QwtPlotGrid::enableYMin( bool on )
 {
-    if ( d_data->yMinEnabled != tf )
+    if ( d_data->yMinEnabled != on )
     {
-        d_data->yMinEnabled = tf;
+        d_data->yMinEnabled = on;
 
         legendChanged();
         itemChanged();
@@ -156,17 +156,35 @@
 }
 
 /*!
-  Assign a pen for both major and minor gridlines
+  Build and assign a pen for both major and minor grid lines
 
+  In Qt5 the default pen width is 1.0 ( 0.0 in Qt4 ) what makes it
+  non cosmetic ( see QPen::isCosmetic() ). This method has been introduced
+  to hide this incompatibility.
+
+  \param color Pen color
+  \param width Pen width
+  \param style Pen style
+
+  \sa pen(), brush()
+ */
+void QwtPlotGrid::setPen( const QColor &color, qreal width, Qt::PenStyle style )
+{
+    setPen( QPen( color, width, style ) );
+}
+
+/*!
+  Assign a pen for both major and minor grid lines
+
   \param pen Pen
-  \sa setMajPen(), setMinPen()
+  \sa setMajorPen(), setMinorPen()
 */
 void QwtPlotGrid::setPen( const QPen &pen )
 {
-    if ( d_data->majPen != pen || d_data->minPen != pen )
+    if ( d_data->majorPen != pen || d_data->minorPen != pen )
     {
-        d_data->majPen = pen;
-        d_data->minPen = pen;
+        d_data->majorPen = pen;
+        d_data->minorPen = pen;
 
         legendChanged();
         itemChanged();
@@ -174,16 +192,34 @@
 }
 
 /*!
-  Assign a pen for the major gridlines
+  Build and assign a pen for both major grid lines
 
+  In Qt5 the default pen width is 1.0 ( 0.0 in Qt4 ) what makes it
+  non cosmetic ( see QPen::isCosmetic() ). This method has been introduced
+  to hide this incompatibility.
+
+  \param color Pen color
+  \param width Pen width
+  \param style Pen style
+
+  \sa pen(), brush()
+ */
+void QwtPlotGrid::setMajorPen( const QColor &color, qreal width, Qt::PenStyle style )
+{
+    setMajorPen( QPen( color, width, style ) );
+}
+
+/*!
+  Assign a pen for the major grid lines
+
   \param pen Pen
-  \sa majPen(), setMinPen(), setPen()
+  \sa majorPen(), setMinorPen(), setPen()
 */
-void QwtPlotGrid::setMajPen( const QPen &pen )
+void QwtPlotGrid::setMajorPen( const QPen &pen )
 {
-    if ( d_data->majPen != pen )
+    if ( d_data->majorPen != pen )
     {
-        d_data->majPen = pen;
+        d_data->majorPen = pen;
 
         legendChanged();
         itemChanged();
@@ -191,16 +227,34 @@
 }
 
 /*!
-  Assign a pen for the minor gridlines
+  Build and assign a pen for the minor grid lines
 
+  In Qt5 the default pen width is 1.0 ( 0.0 in Qt4 ) what makes it
+  non cosmetic ( see QPen::isCosmetic() ). This method has been introduced
+  to hide this incompatibility.
+
+  \param color Pen color
+  \param width Pen width
+  \param style Pen style
+
+  \sa pen(), brush()
+ */
+void QwtPlotGrid::setMinorPen( const QColor &color, qreal width, Qt::PenStyle style )
+{
+    setMinorPen( QPen( color, width, style ) );
+}
+
+/*!
+  Assign a pen for the minor grid lines
+
   \param pen Pen
-  \sa minPen(), setMajPen(), setPen()
+  \sa minorPen(), setMajorPen(), setPen()
 */
-void QwtPlotGrid::setMinPen( const QPen &pen )
+void QwtPlotGrid::setMinorPen( const QPen &pen )
 {
-    if ( d_data->minPen != pen )
+    if ( d_data->minorPen != pen )
     {
-        d_data->minPen = pen;
+        d_data->minorPen = pen;
 
         legendChanged();
         itemChanged();
@@ -211,23 +265,24 @@
   \brief Draw the grid
 
   The grid is drawn into the bounding rectangle such that
-  gridlines begin and end at the rectangle's borders. The X and Y
+  grid lines begin and end at the rectangle's borders. The X and Y
   maps are used to map the scale divisions into the drawing region
   screen.
+
   \param painter  Painter
   \param xMap X axis map
   \param yMap Y axis
-  \param canvasRect Contents rect of the plot canvas
+  \param canvasRect Contents rectangle of the plot canvas
 */
 void QwtPlotGrid::draw( QPainter *painter,
     const QwtScaleMap &xMap, const QwtScaleMap &yMap,
     const QRectF &canvasRect ) const
 {
-    //  draw minor gridlines
-    QPen minPen = d_data->minPen;
-    minPen.setCapStyle( Qt::FlatCap );
+    //  draw minor grid lines
+    QPen minorPen = d_data->minorPen;
+    minorPen.setCapStyle( Qt::FlatCap );
 
-    painter->setPen( minPen );
+    painter->setPen( minorPen );
 
     if ( d_data->xEnabled && d_data->xMinEnabled )
     {
@@ -245,11 +300,11 @@
             d_data->yScaleDiv.ticks( QwtScaleDiv::MediumTick ) );
     }
 
-    //  draw major gridlines
-    QPen majPen = d_data->majPen;
-    majPen.setCapStyle( Qt::FlatCap );
+    //  draw major grid lines
+    QPen majorPen = d_data->majorPen;
+    majorPen.setCapStyle( Qt::FlatCap );
 
-    painter->setPen( majPen );
+    painter->setPen( majorPen );
 
     if ( d_data->xEnabled )
     {
@@ -301,25 +356,25 @@
 }
 
 /*!
-  \return the pen for the major gridlines
-  \sa setMajPen(), setMinPen(), setPen()
+  \return the pen for the major grid lines
+  \sa setMajorPen(), setMinorPen(), setPen()
 */
-const QPen &QwtPlotGrid::majPen() const
+const QPen &QwtPlotGrid::majorPen() const
 {
-    return d_data->majPen;
+    return d_data->majorPen;
 }
 
 /*!
-  \return the pen for the minor gridlines
-  \sa setMinPen(), setMajPen(), setPen()
+  \return the pen for the minor grid lines
+  \sa setMinorPen(), setMajorPen(), setPen()
 */
-const QPen &QwtPlotGrid::minPen() const
+const QPen &QwtPlotGrid::minorPen() const
 {
-    return d_data->minPen;
+    return d_data->minorPen;
 }
 
 /*!
-  \return true if vertical gridlines are enabled
+  \return true if vertical grid lines are enabled
   \sa enableX()
 */
 bool QwtPlotGrid::xEnabled() const
@@ -328,7 +383,7 @@
 }
 
 /*!
-  \return true if minor vertical gridlines are enabled
+  \return true if minor vertical grid lines are enabled
   \sa enableXMin()
 */
 bool QwtPlotGrid::xMinEnabled() const
@@ -337,7 +392,7 @@
 }
 
 /*!
-  \return true if horizontal gridlines are enabled
+  \return true if horizontal grid lines are enabled
   \sa enableY()
 */
 bool QwtPlotGrid::yEnabled() const
@@ -346,7 +401,7 @@
 }
 
 /*!
-  \return true if minor horizontal gridlines are enabled
+  \return true if minor horizontal grid lines are enabled
   \sa enableYMin()
 */
 bool QwtPlotGrid::yMinEnabled() const
Index: qwt_point_data.h
===================================================================
--- qwt_point_data.h	(revision 382)
+++ qwt_point_data.h	(working copy)
@@ -63,7 +63,7 @@
   The points are calculated in equidistant steps in x-direction.
 
   If the interval is invalid, the points are calculated for
-  the "rect of interest", what normally is the displayed area on the
+  the "rectangle of interest", what normally is the displayed area on the
   plot canvas. In this mode you get different levels of detail, when
   zooming in/out.
 
@@ -71,7 +71,7 @@
 
   The following example shows how to implement a sinus curve.
 
-  \verbatim
+  \code
 #include <cmath>
 #include <qwt_series_data.h>
 #include <qwt_plot_curve.h>
@@ -82,31 +82,32 @@
 {
 public:
     SinusData():
-        QwtSyntheticPointData(100)
+        QwtSyntheticPointData( 100 )
     {
     }
-    virtual double y(double x) const
+
+    virtual double y( double x ) const
     {
-        return qSin(x);
+        return qSin( x );
     }
 };
 
 int main(int argc, char **argv)
 {
-    QApplication a(argc, argv);
+    QApplication a( argc, argv );
 
     QwtPlot plot;
-    plot.setAxisScale(QwtPlot::xBottom, 0.0, 10.0);
-    plot.setAxisScale(QwtPlot::yLeft, -1.0, 1.0);
+    plot.setAxisScale( QwtPlot::xBottom, 0.0, 10.0 );
+    plot.setAxisScale( QwtPlot::yLeft, -1.0, 1.0 );
 
-    QwtPlotCurve *curve = new QwtPlotCurve("y = sin(x)");
-    curve->setData(SinusData());
-    curve->attach(&plot);
+    QwtPlotCurve *curve = new QwtPlotCurve( "y = sin(x)" );
+    curve->setData( new SinusData() );
+    curve->attach( &plot );
 
     plot.show();
     return a.exec();
 }
-   \endverbatim
+   \endcode
 */
 class QWT_EXPORT QwtSyntheticPointData: public QwtSeriesData<QPointF>
 {
@@ -115,7 +116,7 @@
         const QwtInterval & = QwtInterval() );
 
     void setSize( size_t size );
-    size_t size() const;
+    virtual size_t size() const;
 
     void setInterval( const QwtInterval& );
     QwtInterval interval() const;
Index: qwt_text_label.h
===================================================================
--- qwt_text_label.h	(revision 382)
+++ qwt_text_label.h	(working copy)
@@ -28,12 +28,16 @@
 
     Q_PROPERTY( int indent READ indent WRITE setIndent )
     Q_PROPERTY( int margin READ margin WRITE setMargin )
+    Q_PROPERTY( QString plainText READ plainText WRITE setPlainText )
 
 public:
     explicit QwtTextLabel( QWidget *parent = NULL );
     explicit QwtTextLabel( const QwtText &, QWidget *parent = NULL );
     virtual ~QwtTextLabel();
 
+    void setPlainText( const QString & );
+    QString plainText() const;
+
 public Q_SLOTS:
     void setText( const QString &,
         QwtText::TextFormat textFormat = QwtText::AutoText );
@@ -56,10 +60,11 @@
 
     QRect textRect() const;
 
+    virtual void drawText( QPainter *, const QRectF & );
+
 protected:
     virtual void paintEvent( QPaintEvent *e );
     virtual void drawContents( QPainter * );
-    virtual void drawText( QPainter *, const QRect & );
 
 private:
     void init();
Index: qwt_scale_div.cpp
===================================================================
--- qwt_scale_div.cpp	(revision 382)
+++ qwt_scale_div.cpp	(working copy)
@@ -9,18 +9,24 @@
 
 #include "qwt_scale_div.h"
 #include "qwt_math.h"
-#include "qwt_interval.h"
 #include <qalgorithms.h>
 
-//! Construct an invalid QwtScaleDiv instance.
-QwtScaleDiv::QwtScaleDiv():
-    d_lowerBound( 0.0 ),
-    d_upperBound( 0.0 )
+/*!
+  Construct a division without ticks
+
+  \param lowerBound First boundary
+  \param upperBound Second boundary
+
+  \note lowerBound might be greater than upperBound for inverted scales
+ */
+QwtScaleDiv::QwtScaleDiv( double lowerBound, double upperBound ):
+    d_lowerBound( lowerBound ),
+    d_upperBound( upperBound )
 {
 }
 
 /*!
-  Construct QwtScaleDiv instance.
+  Construct a scale division
 
   \param interval Interval
   \param ticks List of major, medium and minor ticks
@@ -35,14 +41,15 @@
 }
 
 /*!
-  Construct QwtScaleDiv instance.
+  Construct a scale division
 
-  \param lowerBound First interval limit
-  \param upperBound Second interval limit
+  \param lowerBound First boundary
+  \param upperBound Second boundary
   \param ticks List of major, medium and minor ticks
+
+  \note lowerBound might be greater than upperBound for inverted scales
 */
-QwtScaleDiv::QwtScaleDiv(
-        double lowerBound, double upperBound,
+QwtScaleDiv::QwtScaleDiv( double lowerBound, double upperBound,
         QList<double> ticks[NTickTypes] ):
     d_lowerBound( lowerBound ),
     d_upperBound( upperBound )
@@ -52,15 +59,110 @@
 }
 
 /*!
+  Construct a scale division
+
+  \param lowerBound First boundary
+  \param upperBound Second boundary
+  \param minorTicks List of minor ticks
+  \param mediumTicks List medium ticks
+  \param majorTicks List of major ticks
+
+  \note lowerBound might be greater than upperBound for inverted scales
+*/
+QwtScaleDiv::QwtScaleDiv( double lowerBound, double upperBound,
+        const QList<double> &minorTicks, 
+        const QList<double> &mediumTicks,
+        const QList<double> &majorTicks ):
+    d_lowerBound( lowerBound ),
+    d_upperBound( upperBound )
+{
+    d_ticks[ MinorTick ] = minorTicks;
+    d_ticks[ MediumTick ] = mediumTicks;
+    d_ticks[ MajorTick ] = majorTicks;
+}
+
+/*!
+  Change the interval
+
+  \param lowerBound First boundary
+  \param upperBound Second boundary
+
+  \note lowerBound might be greater than upperBound for inverted scales
+*/
+void QwtScaleDiv::setInterval( double lowerBound, double upperBound )
+{
+    d_lowerBound = lowerBound;
+    d_upperBound = upperBound;
+}
+
+/*!
    Change the interval
+
    \param interval Interval
 */
 void QwtScaleDiv::setInterval( const QwtInterval &interval )
 {
-    setInterval( interval.minValue(), interval.maxValue() );
+    d_lowerBound = interval.minValue();
+    d_upperBound = interval.maxValue();
 }
 
 /*!
+  \return lowerBound -> upperBound
+*/
+QwtInterval QwtScaleDiv::interval() const
+{
+    return QwtInterval( d_lowerBound, d_upperBound );
+}
+
+/*!
+  Set the first boundary
+
+  \param lowerBound First boundary
+  \sa lowerBiound(), setUpperBound()
+ */
+void QwtScaleDiv::setLowerBound( double lowerBound  )
+{
+    d_lowerBound = lowerBound;
+}
+
+/*!
+  \return First boundary
+  \sa upperBound()
+*/
+double QwtScaleDiv::lowerBound() const
+{
+    return d_lowerBound;
+}   
+
+/*!
+  Set the second boundary
+
+  \param upperBound Second boundary
+  \sa upperBound(), setLowerBound()
+ */
+void QwtScaleDiv::setUpperBound( double upperBound  )
+{
+    d_upperBound = upperBound;
+} 
+
+/*!
+  \return upper bound
+  \sa lowerBound()
+*/
+double QwtScaleDiv::upperBound() const
+{
+    return d_upperBound;
+}
+
+/*!
+  \return upperBound() - lowerBound()
+*/
+double QwtScaleDiv::range() const
+{
+    return d_upperBound - d_lowerBound;
+}
+
+/*!
   \brief Equality operator
   \return true if this instance is equal to other
 */
@@ -83,11 +185,11 @@
 
 /*!
   \brief Inequality
-  \return true if this instance is not equal to s
+  \return true if this instance is not equal to other
 */
-bool QwtScaleDiv::operator!=( const QwtScaleDiv &s ) const
+bool QwtScaleDiv::operator!=( const QwtScaleDiv &other ) const
 {
-    return ( !( *this == s ) );
+    return ( !( *this == other ) );
 }
 
 //! Check if the scale division is empty( lowerBound() == upperBound() )
@@ -116,7 +218,10 @@
     return value >= min && value <= max;
 }
 
-//! Invert the scale divison
+/*! 
+   Invert the scale division
+   \sa inverted()
+ */
 void QwtScaleDiv::invert()
 {
     qSwap( d_lowerBound, d_upperBound );
@@ -133,6 +238,57 @@
     }
 }
 
+/*! 
+  \return A scale division with inverted boundaries and ticks
+  \sa invert()
+ */
+QwtScaleDiv QwtScaleDiv::inverted() const
+{
+    QwtScaleDiv other = *this;
+    other.invert();
+
+    return other;
+}
+
+/*! 
+   Return a scale division with an interval [lowerBound, upperBound]
+   where all ticks outside this interval are removed
+
+   \param lowerBound Lower bound
+   \param upperBound Upper bound
+
+   \return Scale division with all ticks inside of the given interval
+
+   \note lowerBound might be greater than upperBound for inverted scales
+*/
+QwtScaleDiv QwtScaleDiv::bounded( 
+    double lowerBound, double upperBound ) const
+{
+    const double min = qMin( lowerBound, upperBound );
+    const double max = qMax( lowerBound, upperBound );
+
+    QwtScaleDiv sd;
+    sd.setInterval( lowerBound, upperBound );
+
+    for ( int tickType = 0; tickType < QwtScaleDiv::NTickTypes; tickType++ )
+    {
+        const QList<double> &ticks = d_ticks[ tickType ];
+
+        QList<double> boundedTicks;
+        for ( int i = 0; i < ticks.size(); i++ )
+        {
+            const double tick = ticks[i];
+            if ( tick >= min && tick <= max )
+                boundedTicks += tick;
+        }
+
+        sd.setTicks( tickType, boundedTicks );
+    }
+
+    return sd;
+
+}
+
 /*!
     Assign ticks
 
@@ -149,21 +305,21 @@
    Return a list of ticks
 
    \param type MinorTick, MediumTick or MajorTick
+   \return Tick list
 */
-const QList<double> &QwtScaleDiv::ticks( int type ) const
+QList<double> QwtScaleDiv::ticks( int type ) const
 {
     if ( type >= 0 && type < NTickTypes )
         return d_ticks[type];
 
-    static QList<double> noTicks;
-    return noTicks;
+    return QList<double>();
 }
 
 #ifndef QT_NO_DEBUG_STREAM
 
 QDebug operator<<( QDebug debug, const QwtScaleDiv &scaleDiv )
 {
-    debug << scaleDiv.interval();
+    debug << scaleDiv.lowerBound() << "<->" << scaleDiv.upperBound();
     debug << "Major: " << scaleDiv.ticks( QwtScaleDiv::MajorTick );
     debug << "Medium: " << scaleDiv.ticks( QwtScaleDiv::MediumTick );
     debug << "Minor: " << scaleDiv.ticks( QwtScaleDiv::MinorTick );
Index: qwt_point_mapper.cpp
===================================================================
--- qwt_point_mapper.cpp	(revision 382)
+++ qwt_point_mapper.cpp	(working copy)
@@ -12,12 +12,296 @@
 #include "qwt_pixel_matrix.h"
 #include <qpolygon.h>
 #include <qimage.h>
+#include <qpen.h>
+#include <qpainter.h>
 
+#if QT_VERSION >= 0x040400
+
+#include <qthread.h>
+#include <qfuture.h>
+#include <qtconcurrentrun.h>
+
+#if !defined(QT_NO_QFUTURE)
+#define QWT_USE_THREADS 0
+#endif
+
+#endif
+
+static QRectF qwtInvalidRect( 0.0, 0.0, -1.0, -1.0 );
+
+// Helper class to work around the 5 parameters
+// limitation of QtConcurrent::run()
+class QwtDotsCommand
+{
+public:
+    const QwtSeriesData<QPointF> *series;
+    int from;
+    int to;
+    QRgb rgb;
+};
+
+static void qwtRenderDots(
+    const QwtScaleMap &xMap, const QwtScaleMap &yMap,
+    const QwtDotsCommand command, const QPoint &pos, QImage *image ) 
+{
+    const QRgb rgb = command.rgb;
+    QRgb *bits = reinterpret_cast<QRgb *>( image->bits() );
+
+    const int w = image->width();
+    const int h = image->height();
+
+    const int x0 = pos.x();
+    const int y0 = pos.y();
+
+    for ( int i = command.from; i <= command.to; i++ )
+    {
+        const QPointF sample = command.series->sample( i );
+
+        const int x = static_cast<int>( xMap.transform( sample.x() ) + 0.5 ) - x0;
+        const int y = static_cast<int>( yMap.transform( sample.y() ) + 0.5 ) - y0;
+
+        if ( x >= 0 && x < w && y >= 0 && y < h )
+            bits[ y * w + x ] = rgb;
+    }
+}
+
+static inline int qwtRoundValue( double value )
+{
+#if 1
+    return qRound( value );
+#else
+    // A little bit faster, but differs from qRound()
+    // for negative values. Should be no problem as we are
+    // rounding widgets coordinates, where negative values 
+    // are clipped off anyway ( at least when there is no 
+    // painter transformation )
+
+    return static_cast<int>( value + 0.5 );
+#endif
+}
+
+// some functors, so that the compile can inline
+struct QwtRoundI
+{
+    inline int operator()( double value )
+    {
+        return qwtRoundValue( value );
+    }
+};
+
+struct QwtRoundF
+{
+    inline double operator()( double value )
+    {
+        return static_cast<double>( qwtRoundValue( value ) );
+    }
+};
+
+struct QwtNoRoundF
+{   
+    inline double operator()( double value )
+    {
+        return value;
+    }
+};
+
+// mapping points without any filtering - beside checking
+// the bounding rectangle
+
+template<class Polygon, class Point, class Round>
+static inline Polygon qwtToPoints( 
+    const QRectF &boundingRect,
+    const QwtScaleMap &xMap, const QwtScaleMap &yMap,
+    const QwtSeriesData<QPointF> *series, 
+    int from, int to, Round round )
+{
+    Polygon polyline( to - from + 1 );
+    Point *points = polyline.data();
+
+    int numPoints = 0;
+
+    if ( boundingRect.isValid() )
+    {
+        // iterating over all values
+        // filtering out all points outside of
+        // the bounding rectangle
+
+        for ( int i = from; i <= to; i++ )
+        {
+            const QPointF sample = series->sample( i );
+
+            const double x = xMap.transform( sample.x() );
+            const double y = yMap.transform( sample.y() );
+
+            if ( boundingRect.contains( x, y ) )
+            {
+                points[ numPoints ].rx() = round( x );
+                points[ numPoints ].ry() = round( y );
+
+                numPoints++;
+            }
+        }
+
+        polyline.resize( numPoints );
+    }
+    else
+    {
+        // simply iterating over all values
+        // without any filtering
+
+        for ( int i = from; i <= to; i++ )
+        {
+            const QPointF sample = series->sample( i );
+
+            const double x = xMap.transform( sample.x() );
+            const double y = yMap.transform( sample.y() );
+
+            points[ numPoints ].rx() = round( x );
+            points[ numPoints ].ry() = round( y );
+
+            numPoints++;
+        }
+    }
+
+    return polyline;
+}
+
+static inline QPolygon qwtToPointsI(
+    const QRectF &boundingRect,
+    const QwtScaleMap &xMap, const QwtScaleMap &yMap,
+    const QwtSeriesData<QPointF> *series,
+    int from, int to )
+{
+    return qwtToPoints<QPolygon, QPoint>( 
+        boundingRect, xMap, yMap, series, from, to, QwtRoundI() );
+}
+
+template<class Round>
+static inline QPolygonF qwtToPointsF(
+    const QRectF &boundingRect,
+    const QwtScaleMap &xMap, const QwtScaleMap &yMap,
+    const QwtSeriesData<QPointF> *series,
+    int from, int to, Round round )
+{
+    return qwtToPoints<QPolygonF, QPointF>( 
+        boundingRect, xMap, yMap, series, from, to, round );
+}
+
+// Mapping points with filtering out consecutive
+// points mapped to the same position
+
+template<class Polygon, class Point, class Round>
+static inline Polygon qwtToPolylineFiltered( 
+    const QwtScaleMap &xMap, const QwtScaleMap &yMap,
+    const QwtSeriesData<QPointF> *series, 
+    int from, int to, Round round )
+{
+    // in curves with many points consecutive points
+    // are often mapped to the same position. As this might
+    // result in empty lines ( or symbols hidden by others )
+    // we try to filter them out
+
+    Polygon polyline( to - from + 1 );
+    Point *points = polyline.data();
+
+    const QPointF sample0 = series->sample( from );
+
+    points[0].rx() = round( xMap.transform( sample0.x() ) );
+    points[0].ry() = round( yMap.transform( sample0.y() ) );
+
+    int pos = 0;
+    for ( int i = from + 1; i <= to; i++ )
+    {
+        const QPointF sample = series->sample( i );
+
+        const Point p( round( xMap.transform( sample.x() ) ),
+            round( yMap.transform( sample.y() ) ) );
+
+        if ( points[pos] != p )
+            points[++pos] = p;
+    }
+
+    polyline.resize( pos + 1 );
+    return polyline;
+}
+
+static inline QPolygon qwtToPolylineFilteredI(
+    const QwtScaleMap &xMap, const QwtScaleMap &yMap,
+    const QwtSeriesData<QPointF> *series,
+    int from, int to )
+{
+    return qwtToPolylineFiltered<QPolygon, QPoint>(
+        xMap, yMap, series, from, to, QwtRoundI() );
+}
+
+template<class Round>
+static inline QPolygonF qwtToPolylineFilteredF(
+    const QwtScaleMap &xMap, const QwtScaleMap &yMap,
+    const QwtSeriesData<QPointF> *series,
+    int from, int to, Round round )
+{
+    return qwtToPolylineFiltered<QPolygonF, QPointF>(
+        xMap, yMap, series, from, to, round );
+} 
+
+template<class Polygon, class Point>
+static inline Polygon qwtToPointsFiltered(
+    const QRectF &boundingRect,
+    const QwtScaleMap &xMap, const QwtScaleMap &yMap,
+    const QwtSeriesData<QPointF> *series, int from, int to )
+{
+    // F.e. in scatter plots ( no connecting lines ) we
+    // can sort out all duplicates ( not only consecutive points )
+
+    Polygon polygon( to - from + 1 );
+    Point *points = polygon.data();
+
+    QwtPixelMatrix pixelMatrix( boundingRect.toAlignedRect() );
+
+    int numPoints = 0;
+    for ( int i = from; i <= to; i++ )
+    {
+        const QPointF sample = series->sample( i );
+
+        const int x = qwtRoundValue( xMap.transform( sample.x() ) );
+        const int y = qwtRoundValue( yMap.transform( sample.y() ) );
+
+        if ( pixelMatrix.testAndSetPixel( x, y, true ) == false )
+        {
+            points[ numPoints ].rx() = x;
+            points[ numPoints ].ry() = y;
+
+            numPoints++;
+        }
+    }
+
+    polygon.resize( numPoints );
+    return polygon;
+}
+
+static inline QPolygon qwtToPointsFilteredI(
+    const QRectF &boundingRect,
+    const QwtScaleMap &xMap, const QwtScaleMap &yMap,
+    const QwtSeriesData<QPointF> *series, int from, int to )
+{
+    return qwtToPointsFiltered<QPolygon, QPoint>(
+        boundingRect, xMap, yMap, series, from, to );
+} 
+
+static inline QPolygonF qwtToPointsFilteredF(
+    const QRectF &boundingRect,
+    const QwtScaleMap &xMap, const QwtScaleMap &yMap,
+    const QwtSeriesData<QPointF> *series, int from, int to )
+{
+    return qwtToPointsFiltered<QPolygonF, QPointF>(
+        boundingRect, xMap, yMap, series, from, to );
+}
+
 class QwtPointMapper::PrivateData
 {
 public:
     PrivateData():
-        boundingRect( 0.0, 0.0, -1.0, -1.0 )
+        boundingRect( qwtInvalidRect )
     {
     }
 
@@ -37,16 +321,34 @@
     delete d_data;
 }
 
+/*!
+  Set the flags affecting the transformation process
+
+  \param flags Flags
+  \sa flags(), setFlag()
+ */
 void QwtPointMapper::setFlags( TransformationFlags flags )
 {
     d_data->flags = flags;
 }
 
+/*!
+  \return Flags affecting the transformation process
+  \sa setFlags(), setFlag()
+ */
 QwtPointMapper::TransformationFlags QwtPointMapper::flags() const
 {
     return d_data->flags;
 }
 
+/*!
+  Modify a flag affecting the transformation process
+
+  \param flag Flag type
+  \param on Value
+
+  \sa flag(), setFlags()
+ */
 void QwtPointMapper::setFlag( TransformationFlag flag, bool on )
 {
     if ( on )
@@ -55,16 +357,33 @@
         d_data->flags &= ~flag;
 }
 
+/*!
+  \return True, when the flag is set
+  \param flag Flag type
+  \sa setFlag(), setFlags()
+ */
 bool QwtPointMapper::testFlag( TransformationFlag flag ) const
 {
     return d_data->flags & flag;
 }
 
+/*!
+  Set a bounding rectangle for the point mapping algorithm
+
+  A valid bounding rectangle can be used for optimizations
+
+  \param rect Bounding rectangle
+  \sa boundingRect()
+ */
 void QwtPointMapper::setBoundingRect( const QRectF &rect )
 {
     d_data->boundingRect = rect;
 }
 
+/*!
+  \return Bounding rectangle
+  \sa setBoundingRect()
+ */
 QRectF QwtPointMapper::boundingRect() const
 {
     return d_data->boundingRect;
@@ -76,94 +395,48 @@
   When the WeedOutPoints flag is enabled consecutive points,
   that are mapped to the same position will be one point. 
 
+  When RoundPoints is set all points are rounded to integers
+  but returned as PolygonF - what only makes sense
+  when the further processing of the values need a QPolygonF.
+
   \param xMap x map
   \param yMap y map
-  \param series Seies of points to be mapped
-  \param from index of the first point to be painted
-  \param to index of the last point to be painted
+  \param series Series of points to be mapped
+  \param from Index of the first point to be painted
+  \param to Index of the last point to be painted
+
+  \return Translated polygon
 */
 QPolygonF QwtPointMapper::toPolygonF(
     const QwtScaleMap &xMap, const QwtScaleMap &yMap,
     const QwtSeriesData<QPointF> *series, int from, int to ) const
 {
-    QPolygonF polyline( to - from + 1 );
-    QPointF *points = polyline.data();
+    QPolygonF polyline;
 
-    if ( d_data->flags & RoundPoints )
+    if ( d_data->flags & WeedOutPoints )
     {
-        if ( d_data->flags & WeedOutPoints )
+        if ( d_data->flags & RoundPoints )
         {
-            const QPointF sample0 = series->sample( from );
-            points[0].rx() = qRound( xMap.transform( sample0.x() ) );
-            points[0].ry() = qRound( yMap.transform( sample0.y() ) );
-
-            int pos = 0;
-            for ( int i = from + 1; i <= to; i++ )
-            {
-                const QPointF sample = series->sample( i );
-
-                const double x = qRound( xMap.transform( sample.x() ) );
-                const double y = qRound( yMap.transform( sample.y() ) );
-
-                if ( points[pos].x() != x || points[pos].y() != y )
-                {
-                    pos++;
-                    points[pos].rx() = x;
-                    points[pos].ry() = y;
-                }
-            }
-
-            polyline.resize( pos + 1 );
+            polyline = qwtToPolylineFilteredF( 
+                xMap, yMap, series, from, to, QwtRoundF() );
         }
         else
         {
-            for ( int i = from; i <= to; i++ )
-            {
-                const QPointF sample = series->sample( i );
-
-                const int x = qRound( xMap.transform( sample.x() ) );
-                const int y = qRound( yMap.transform( sample.y() ) );
-
-                points[i - from].rx() = static_cast<double>( x );
-                points[i - from].ry() = static_cast<double>( y );
-            }
+            polyline = qwtToPolylineFilteredF( 
+                xMap, yMap, series, from, to, QwtNoRoundF() );
         }
     }
     else
     {
-        if ( d_data->flags & WeedOutPoints )
+        if ( d_data->flags & RoundPoints )
         {
-            const QPointF sample0 = series->sample( from );
-            points[0].rx() = qRound( xMap.transform( sample0.x() ) );
-            points[0].ry() = qRound( yMap.transform( sample0.y() ) );
-
-            int pos = 0;
-            for ( int i = from + 1; i <= to; i++ )
-            {
-                const QPointF sample = series->sample( i );
-
-                const double x = xMap.transform( sample.x() );
-                const double y = yMap.transform( sample.y() );
-
-                // we could use qFuzzyCompare ?
-                if ( points[pos].x() != x || points[pos].y() != y )
-                {
-                    pos++;
-                    points[pos].rx() = x;
-                    points[pos].ry() = y;
-                }
-            }
-
-            polyline.resize( pos + 1 );
+            polyline = qwtToPointsF( qwtInvalidRect, 
+                xMap, yMap, series, from, to, QwtRoundF() );
         }
         else
         {
-            for ( int i = from; i <= to; i++ )
-            {
-                const QPointF sample = series->sample( i );
-                points[i - from].rx() = xMap.transform( sample.x() );
-                points[i - from].ry() = yMap.transform( sample.y() );
-            }
+            polyline = qwtToPointsF( qwtInvalidRect, 
+                xMap, yMap, series, from, to, QwtNoRoundF() );
         }
     }
 
@@ -178,233 +451,271 @@
 
   \param xMap x map
   \param yMap y map
-  \param series Seies of points to be mapped
-  \param from index of the first point to be painted
-  \param to index of the last point to be painted
+  \param series Series of points to be mapped
+  \param from Index of the first point to be painted
+  \param to Index of the last point to be painted
+
+  \return Translated polygon
 */
 QPolygon QwtPointMapper::toPolygon(
     const QwtScaleMap &xMap, const QwtScaleMap &yMap,
     const QwtSeriesData<QPointF> *series, int from, int to ) const
 {
-    QPolygon polyline( to - from + 1 );
-    QPoint *points = polyline.data();
+    QPolygon polyline;
 
     if ( d_data->flags & WeedOutPoints )
     {
-        const QPointF sample0 = series->sample( from );
-        points[0].rx() = qRound( xMap.transform( sample0.x() ) );
-        points[0].ry() = qRound( yMap.transform( sample0.y() ) );
-
-        int pos = 0;
-        for ( int i = from + 1; i <= to; i++ )
-        {
-            const QPointF sample = series->sample( i );
-
-            const int x = qRound( xMap.transform( sample.x() ) );
-            const int y = qRound( yMap.transform( sample.y() ) );
-
-            if ( points[pos].x() != x || points[pos].y() != y )
-            {
-                pos++;
-                points[pos].rx() = x;
-                points[pos].ry() = y;
-            }
-        }
-
-        polyline.resize( pos + 1 );
+        polyline = qwtToPolylineFilteredI( 
+            xMap, yMap, series, from, to );
     }
     else
     {
-        for ( int i = from; i <= to; i++ )
-        {
-            const QPointF sample = series->sample( i );
-
-#if 1
-            points[i - from].rx() = qRound( xMap.transform( sample.x() ) );
-            points[i - from].ry() = qRound( yMap.transform( sample.y() ) );
-#else
-            // A little bit faster, but differs from qRound
-            // for negative values. Should be no problem as we are
-            // rounding coordinates, where negative values are clipped off anyway
-            // ( at least when there is no painter transformation )
-
-            points[i - from].rx() =
-                static_cast<int>( xMap.transform( sample.x() ) + 0.5 );
-            points[i - from].ry() =
-                static_cast<int>( yMap.transform( sample.y() ) + 0.5 );
-#endif
-        }
+        polyline = qwtToPointsI( 
+            qwtInvalidRect, xMap, yMap, series, from, to );
     }
 
     return polyline;
 }
 
 /*!
-  \brief Translate a series of points into a QPolygon
+  \brief Translate a series into a QPolygonF
 
-  When the WeedOutPoints flag is enabled and the mapper has
-  a valid bounding rectangle all points that
-  are mapped to the same position will be one point. 
+  - WeedOutPoints & RoundPoints & boundingRect().isValid()
+    All points that are mapped to the same position 
+    will be one point. Points outside of the bounding
+    rectangle are ignored.
+ 
+  - WeedOutPoints & RoundPoints & !boundingRect().isValid()
+    All consecutive points that are mapped to the same position 
+    will one point
 
+  - WeedOutPoints & !RoundPoints 
+    All consecutive points that are mapped to the same position 
+    will one point
+
+  - !WeedOutPoints & boundingRect().isValid()
+    Points outside of the bounding rectangle are ignored.
+
+  When RoundPoints is set all points are rounded to integers
+  but returned as PolygonF - what only makes sense
+  when the further processing of the values need a QPolygonF.
+
   \param xMap x map
   \param yMap y map
-  \param series Seies of points to be mapped
-  \param from index of the first point to be painted
-  \param to index of the last point to be painted
+  \param series Series of points to be mapped
+  \param from Index of the first point to be painted
+  \param to Index of the last point to be painted
+
+  \return Translated polygon
 */
-QPolygon QwtPointMapper::toPoints(
+QPolygonF QwtPointMapper::toPointsF(
     const QwtScaleMap &xMap, const QwtScaleMap &yMap,
     const QwtSeriesData<QPointF> *series, int from, int to ) const
 {
-    QPolygon polygon( to - from + 1 );
-    QPoint *points = polygon.data();
-    int numPoints = 0;
+    QPolygonF points;
 
-    if ( d_data->boundingRect.isEmpty() )
+    if ( d_data->flags & WeedOutPoints )
     {
-        for ( int i = from; i <= to; i++ )
+        if ( d_data->flags & RoundPoints )
         {
-            const QPointF sample = series->sample( i );
+            if ( d_data->boundingRect.isValid() )
+            {   
+                points = qwtToPointsFilteredF( d_data->boundingRect,
+                    xMap, yMap, series, from, to );
+            }
+            else
+            {   
+                // without a bounding rectangle all we can
+                // do is to filter out duplicates of
+                // consecutive points
 
-            const int x = qRound( xMap.transform( sample.x() ) );
-            const int y = qRound( yMap.transform( sample.y() ) );
+                points = qwtToPolylineFilteredF( 
+                    xMap, yMap, series, from, to, QwtRoundF() );
+            }
+        }
+        else
+        {
+            // when rounding is not allowed we can't use
+            // qwtToPointsFilteredF
 
-            points[ numPoints ].rx() = x;
-            points[ numPoints ].ry() = y;
-
-            numPoints++;
+            points = qwtToPolylineFilteredF( 
+                xMap, yMap, series, from, to, QwtNoRoundF() );
         }
     }
     else
     {
-        if ( d_data->flags & WeedOutPoints )
+        if ( d_data->flags & RoundPoints )
         {
-            const QRect rect = d_data->boundingRect.toAlignedRect();
-
-            QwtPixelMatrix pixelMatrix( rect );
-
-            for ( int i = from; i <= to; i++ )
-            {
-                const QPointF sample = series->sample( i );
-
-                const QPoint pos(
-                    qRound( xMap.transform( sample.x() ) ),
-                    qRound( yMap.transform( sample.y() ) )
-                );
-
-                if ( pixelMatrix.testAndSetPixel( pos, true ) == false )
-                    points[ numPoints++ ] = pos;
-            }
+            points = qwtToPointsF( d_data->boundingRect,
+                xMap, yMap, series, from, to, QwtRoundF() );
         }
         else
         {
-            for ( int i = from; i <= to; i++ )
-            {
-                const QPointF sample = series->sample( i );
-
-                const double x = qRound( xMap.transform( sample.x() ) );
-                const double y = qRound( yMap.transform( sample.y() ) );
-
-                if ( d_data->boundingRect.contains( x, y ) )
-                {
-                    points[ numPoints ].rx() = qRound( x );
-                    points[ numPoints ].ry() = qRound( y );
-
-                    numPoints++;
-                }
-            }
+            points = qwtToPointsF( d_data->boundingRect,
+                xMap, yMap, series, from, to, QwtNoRoundF() );
         }
-
-        polygon.resize( numPoints );
     }
 
-    return polygon;
+    return points;
 }
 
 /*!
-  \brief Translate a series into a QPolygon
+  \brief Translate a series of points into a QPolygon
 
-  When the WeedOutPoints flag is enabled and the mapper has
-  a valid bounding rectangle all points that
-  are mapped to the same position will be one point. 
+  - WeedOutPoints & boundingRect().isValid()
+    All points that are mapped to the same position 
+    will be one point. Points outside of the bounding
+    rectangle are ignored.
+ 
+  - WeedOutPoints & !boundingRect().isValid()
+    All consecutive points that are mapped to the same position 
+    will one point
 
+  - !WeedOutPoints & boundingRect().isValid()
+    Points outside of the bounding rectangle are ignored.
+
   \param xMap x map
   \param yMap y map
-  \param series Seies of points to be mapped
-  \param from index of the first point to be painted
-  \param to index of the last point to be painted
+  \param series Series of points to be mapped
+  \param from Index of the first point to be painted
+  \param to Index of the last point to be painted
+
+  \return Translated polygon
 */
-QPolygonF QwtPointMapper::toPointsF(
+QPolygon QwtPointMapper::toPoints(
     const QwtScaleMap &xMap, const QwtScaleMap &yMap,
     const QwtSeriesData<QPointF> *series, int from, int to ) const
 {
-    QPolygonF polyline( to - from + 1 );
-    QPointF *points = polyline.data();
+    QPolygon points;
 
-    if ( d_data->flags & RoundPoints )
+    if ( d_data->flags & WeedOutPoints )
     {
-        for ( int i = from; i <= to; i++ )
+        if ( d_data->boundingRect.isValid() )
         {
-            const QPointF sample = series->sample( i );
+            points = qwtToPointsFilteredI( d_data->boundingRect,
+                xMap, yMap, series, from, to );
+        }
+        else
+        {
+            // when we don't have the bounding rectangle all
+            // we can do is to filter out consecutive duplicates
 
-            const int x = qRound( xMap.transform( sample.x() ) );
-            const int y = qRound( yMap.transform( sample.y() ) );
-
-            points[i - from].rx() = static_cast<double>( x );
-            points[i - from].ry() = static_cast<double>( y );
+            points = qwtToPolylineFilteredI( 
+                xMap, yMap, series, from, to );
         }
     }
     else
     {
-        for ( int i = from; i <= to; i++ )
-        {
-            const QPointF sample = series->sample( i );
-            points[i - from].rx() = xMap.transform( sample.x() );
-            points[i - from].ry() = yMap.transform( sample.y() );
-        }
+        points = qwtToPointsI( 
+            d_data->boundingRect, xMap, yMap, series, from, to );
     }
 
-    return polyline;
+    return points;
 }
 
+
 /*!
   \brief Translate a series into a QImage
 
   \param xMap x map
   \param yMap y map
-  \param series Seies of points to be mapped
-  \param from index of the first point to be painted
-  \param to index of the last point to be painted
-  \param rgb RGB value, that will be set for all pixels
-             of the image, whe a point is mapped to
+  \param series Series of points to be mapped
+  \param from Index of the first point to be painted
+  \param to Index of the last point to be painted
+  \param pen Pen used for drawing a point
+             of the image, where a point is mapped to
+  \param antialiased True, when the dots should be displayed
+                     antialiased
+  \param numThreads Number of threads to be used for rendering.
+                   If numThreads is set to 0, the system specific
+                   ideal thread count is used.
+
+  \return Image displaying the series
 */
 QImage QwtPointMapper::toImage(
     const QwtScaleMap &xMap, const QwtScaleMap &yMap,
-    const QwtSeriesData<QPointF> *series, int from, int to, QRgb rgb ) const
+    const QwtSeriesData<QPointF> *series, int from, int to, 
+    const QPen &pen, bool antialiased, uint numThreads ) const
 {
+    Q_UNUSED( antialiased )
+
+#if QWT_USE_THREADS
+    if ( numThreads == 0 )
+        numThreads = QThread::idealThreadCount();
+
+    if ( numThreads <= 0 )
+        numThreads = 1;
+#else
+    Q_UNUSED( numThreads )
+#endif
+
+    // a very special optimization for scatter plots
+    // where every sample is mapped to one pixel only.
+
     const QRect rect = d_data->boundingRect.toAlignedRect();
 
     QImage image( rect.size(), QImage::Format_ARGB32 );
     image.fill( Qt::transparent );
 
-    const int w = image.width();
-    const int h = image.height();
+    if ( pen.width() <= 1 && pen.color().alpha() == 255 )
+    {
+        QwtDotsCommand command;
+        command.series = series;
+        command.rgb = pen.color().rgba();
 
-    const int x0 = rect.x();
-    const int y0 = rect.y();
+#if QWT_USE_THREADS
+        const int numPoints = ( to - from + 1 ) / numThreads;
 
-    QRgb *bits = reinterpret_cast<QRgb *>( image.bits() );
-    for ( int i = from; i <= to; i++ )
+        QList< QFuture<void> > futures;
+        for ( uint i = 0; i < numThreads; i++ )
+        {
+            const QPoint pos = rect.topLeft();
+
+            const int index0 = from + i * numPoints;
+            if ( i == numThreads - 1 )
+            {
+                command.from = index0;
+                command.to = to;
+
+                qwtRenderDots( xMap, yMap, command, pos, &image );
+            }
+            else
+            {
+                command.from = index0;
+                command.to = index0 + numPoints - 1;
+
+                futures += QtConcurrent::run( &qwtRenderDots, 
+                    xMap, yMap, command, pos, &image );
+            }
+        }
+        for ( int i = 0; i < futures.size(); i++ )
+            futures[i].waitForFinished();
+#else
+        command.from = from;
+        command.to = to;
+
+        qwtRenderDots( xMap, yMap, command, rect.topLeft(), &image );
+#endif
+    }
+    else
     {
-        const QPointF sample = series->sample( i );
+        // fallback implementation: to be replaced later by
+        // setting the pixels of the image like above, TODO ...
 
-        const int x = qRound( xMap.transform( sample.x() ) ) - x0;
-        const int y = qRound( yMap.transform( sample.y() ) ) - y0;
+        QPainter painter( &image );
+        painter.setPen( pen );
+        painter.setRenderHint( QPainter::Antialiasing, antialiased );
 
-        if ( x >= 0 && x < w && y >= 0 && y < w )
-            bits[ y * h + x ] = rgb;
+        const int chunkSize = 1000;
+        for ( int i = from; i <= to; i += chunkSize )
+        {
+            const int indexTo = qMin( i + chunkSize - 1, to );
+            const QPolygon points = toPoints(
+                xMap, yMap, series, i, indexTo );
+
+            painter.drawPoints( points );
+        }
     }
 
     return image;
 }
-
Index: qwt_compass_rose.cpp
===================================================================
--- qwt_compass_rose.cpp	(revision 382)
+++ qwt_compass_rose.cpp	(working copy)
@@ -75,6 +75,7 @@
   Set the Factor how to shrink the thorns with each level
   The default value is 0.9.
 
+  \param factor Shrink factor
   \sa shrinkFactor()
 */
 void QwtSimpleCompassRose::setShrinkFactor( double factor )
@@ -165,7 +166,7 @@
         if ( 2.0 * M_PI / step > 32 )
             leafWidth = 16;
 
-        const double origin = north / 180.0 * M_PI;
+        const double origin = qwtRadians( north );
         for ( double angle = origin;
             angle < 2.0 * M_PI + origin; angle += step )
         {
@@ -211,7 +212,10 @@
         d_data->width = 0.4;
 }
 
-//! \sa setWidth()
+/*! 
+  \return Width of the rose
+  \sa setWidth()
+ */
 double QwtSimpleCompassRose::width() const
 {
     return d_data->width;
Index: qwt_dyngrid_layout.cpp
===================================================================
--- qwt_dyngrid_layout.cpp	(revision 382)
+++ qwt_dyngrid_layout.cpp	(working copy)
@@ -24,9 +24,9 @@
 
     mutable QList<QLayoutItem*> itemList;
 
-    uint maxCols;
+    uint maxColumns;
     uint numRows;
-    uint numCols;
+    uint numColumns;
 
     Qt::Orientations expanding;
 
@@ -81,7 +81,7 @@
 void QwtDynGridLayout::init()
 {
     d_data = new QwtDynGridLayout::PrivateData;
-    d_data->maxCols = d_data->numRows = d_data->numCols = 0;
+    d_data->maxColumns = d_data->numRows = d_data->numColumns = 0;
     d_data->expanding = 0;
 }
 
@@ -104,27 +104,31 @@
 
 /*!
   Limit the number of columns.
-  \param maxCols upper limit, 0 means unlimited
-  \sa maxCols()
+  \param maxColumns upper limit, 0 means unlimited
+  \sa maxColumns()
 */
-void QwtDynGridLayout::setMaxCols( uint maxCols )
+void QwtDynGridLayout::setMaxColumns( uint maxColumns )
 {
-    d_data->maxCols = maxCols;
+    d_data->maxColumns = maxColumns;
 }
 
 /*!
-  Return the upper limit for the number of columns.
+  \brief Return the upper limit for the number of columns.
+
   0 means unlimited, what is the default.
-  \sa setMaxCols()
+
+  \return Upper limit for the number of columns
+  \sa setMaxColumns()
 */
-
-uint QwtDynGridLayout::maxCols() const
+uint QwtDynGridLayout::maxColumns() const
 {
-    return d_data->maxCols;
+    return d_data->maxColumns;
 }
 
-//! Adds item to the next free position.
-
+/*! 
+  \brief Add an item to the next free position.
+  \param item Layout item
+ */
 void QwtDynGridLayout::addItem( QLayoutItem *item )
 {
     d_data->itemList.append( item );
@@ -134,7 +138,6 @@
 /*!
   \return true if this layout is empty.
 */
-
 bool QwtDynGridLayout::isEmpty() const
 {
     return d_data->itemList.isEmpty();
@@ -143,16 +146,16 @@
 /*!
   \return number of layout items
 */
-
 uint QwtDynGridLayout::itemCount() const
 {
     return d_data->itemList.count();
 }
 
 /*!
-  Find the item at a spcific index
+  Find the item at a specific index
 
   \param index Index
+  \return Item at a specific index
   \sa takeAt()
 */
 QLayoutItem *QwtDynGridLayout::itemAt( int index ) const
@@ -164,9 +167,10 @@
 }
 
 /*!
-  Find the item at a spcific index and remove it from the layout
+  Find the item at a specific index and remove it from the layout
 
   \param index Index
+  \return Layout item, removed from the layout
   \sa itemAt()
 */
 QLayoutItem *QwtDynGridLayout::takeAt( int index )
@@ -199,10 +203,13 @@
 }
 
 /*!
-  Returns whether this layout can make use of more space than sizeHint().
+  \brief Returns whether this layout can make use of more space than sizeHint().
+
   A value of Qt::Vertical or Qt::Horizontal means that it wants to grow in only
   one dimension, while Qt::Vertical | Qt::Horizontal means that it wants
   to grow in both dimensions.
+
+  \return Orientations, where the layout expands
   \sa setExpandingDirections()
 */
 Qt::Orientations QwtDynGridLayout::expandingDirections() const
@@ -212,7 +219,7 @@
 
 /*!
   Reorganizes columns and rows and resizes managed items within
-  the rectangle rect.
+  a rectangle.
 
   \param rect Layout geometry
 */
@@ -223,12 +230,12 @@
     if ( isEmpty() )
         return;
 
-    d_data->numCols = columnsForWidth( rect.width() );
-    d_data->numRows = itemCount() / d_data->numCols;
-    if ( itemCount() % d_data->numCols )
+    d_data->numColumns = columnsForWidth( rect.width() );
+    d_data->numRows = itemCount() / d_data->numColumns;
+    if ( itemCount() % d_data->numColumns )
         d_data->numRows++;
 
-    QList<QRect> itemGeometries = layoutItems( rect, d_data->numCols );
+    QList<QRect> itemGeometries = layoutItems( rect, d_data->numColumns );
 
     int index = 0;
     for ( QList<QLayoutItem*>::iterator it = d_data->itemList.begin();
@@ -240,30 +247,33 @@
 }
 
 /*!
-  Calculate the number of columns for a given width. It tries to
-  use as many columns as possible (limited by maxCols())
+  \brief Calculate the number of columns for a given width. 
 
+  The calculation tries to use as many columns as possible 
+  ( limited by maxColumns() )
+
   \param width Available width for all columns
-  \sa maxCols(), setMaxCols()
+  \return Number of columns for a given width
+
+  \sa maxColumns(), setMaxColumns()
 */
-
 uint QwtDynGridLayout::columnsForWidth( int width ) const
 {
     if ( isEmpty() )
         return 0;
 
-    uint maxCols = itemCount();
-    if ( d_data->maxCols > 0 ) 
-        maxCols = qMin( d_data->maxCols, maxCols );
+    uint maxColumns = itemCount();
+    if ( d_data->maxColumns > 0 ) 
+        maxColumns = qMin( d_data->maxColumns, maxColumns );
 
-    if ( maxRowWidth( maxCols ) <= width )
-        return maxCols;
+    if ( maxRowWidth( maxColumns ) <= width )
+        return maxColumns;
 
-    for ( uint numCols = 2; numCols <= maxCols; numCols++ )
+    for ( uint numColumns = 2; numColumns <= maxColumns; numColumns++ )
     {
-        const int rowWidth = maxRowWidth( numCols );
+        const int rowWidth = maxRowWidth( numColumns );
         if ( rowWidth > width )
-            return numCols - 1;
+            return numColumns - 1;
     }
 
     return 1; // At least 1 column
@@ -273,15 +283,15 @@
   Calculate the width of a layout for a given number of
   columns.
 
-  \param numCols Given number of columns
+  \param numColumns Given number of columns
   \param itemWidth Array of the width hints for all items
 */
-int QwtDynGridLayout::maxRowWidth( int numCols ) const
+int QwtDynGridLayout::maxRowWidth( int numColumns ) const
 {
     int col;
 
-    QVector<int> colWidth( numCols );
-    for ( col = 0; col < numCols; col++ )
+    QVector<int> colWidth( numColumns );
+    for ( col = 0; col < numColumns; col++ )
         colWidth[col] = 0;
 
     if ( d_data->isDirty )
@@ -290,13 +300,13 @@
     for ( int index = 0;
         index < d_data->itemSizeHints.count(); index++ )
     {
-        col = index % numCols;
+        col = index % numColumns;
         colWidth[col] = qMax( colWidth[col],
             d_data->itemSizeHints[int( index )].width() );
     }
 
-    int rowWidth = 2 * margin() + ( numCols - 1 ) * spacing();
-    for ( col = 0; col < numCols; col++ )
+    int rowWidth = 2 * margin() + ( numColumns - 1 ) * spacing();
+    for ( col = 0; col < numColumns; col++ )
         rowWidth += colWidth[col];
 
     return rowWidth;
@@ -326,48 +336,48 @@
 
 /*!
   Calculate the geometries of the layout items for a layout
-  with numCols columns and a given rect.
+  with numColumns columns and a given rectangle.
 
   \param rect Rect where to place the items
-  \param numCols Number of columns
+  \param numColumns Number of columns
   \return item geometries
 */
 
 QList<QRect> QwtDynGridLayout::layoutItems( const QRect &rect,
-    uint numCols ) const
+    uint numColumns ) const
 {
     QList<QRect> itemGeometries;
-    if ( numCols == 0 || isEmpty() )
+    if ( numColumns == 0 || isEmpty() )
         return itemGeometries;
 
-    uint numRows = itemCount() / numCols;
-    if ( numCols % itemCount() )
+    uint numRows = itemCount() / numColumns;
+    if ( numColumns % itemCount() )
         numRows++;
 
     if ( numRows == 0 )
         return itemGeometries;
 
     QVector<int> rowHeight( numRows );
-    QVector<int> colWidth( numCols );
+    QVector<int> colWidth( numColumns );
 
-    layoutGrid( numCols, rowHeight, colWidth );
+    layoutGrid( numColumns, rowHeight, colWidth );
 
     bool expandH, expandV;
     expandH = expandingDirections() & Qt::Horizontal;
     expandV = expandingDirections() & Qt::Vertical;
 
     if ( expandH || expandV )
-        stretchGrid( rect, numCols, rowHeight, colWidth );
+        stretchGrid( rect, numColumns, rowHeight, colWidth );
 
-    const int maxCols = d_data->maxCols;
-    d_data->maxCols = numCols;
+    const int maxColumns = d_data->maxColumns;
+    d_data->maxColumns = numColumns;
     const QRect alignedRect = alignmentRect( rect );
-    d_data->maxCols = maxCols;
+    d_data->maxColumns = maxColumns;
 
     const int xOffset = expandH ? 0 : alignedRect.x();
     const int yOffset = expandV ? 0 : alignedRect.y();
 
-    QVector<int> colX( numCols );
+    QVector<int> colX( numColumns );
     QVector<int> rowY( numRows );
 
     const int xySpace = spacing();
@@ -377,14 +387,14 @@
         rowY[r] = rowY[r-1] + rowHeight[r-1] + xySpace;
 
     colX[0] = xOffset + margin();
-    for ( uint c = 1; c < numCols; c++ )
+    for ( uint c = 1; c < numColumns; c++ )
         colX[c] = colX[c-1] + colWidth[c-1] + xySpace;
 
     const int itemCount = d_data->itemList.size();
     for ( int i = 0; i < itemCount; i++ )
     {
-        const int row = i / numCols;
-        const int col = i % numCols;
+        const int row = i / numColumns;
+        const int col = i % numColumns;
 
         QRect itemGeometry( colX[col], rowY[row],
             colWidth[col], rowHeight[row] );
@@ -397,17 +407,17 @@
 
 /*!
   Calculate the dimensions for the columns and rows for a grid
-  of numCols columns.
+  of numColumns columns.
 
-  \param numCols Number of columns.
+  \param numColumns Number of columns.
   \param rowHeight Array where to fill in the calculated row heights.
   \param colWidth Array where to fill in the calculated column widths.
 */
 
-void QwtDynGridLayout::layoutGrid( uint numCols,
+void QwtDynGridLayout::layoutGrid( uint numColumns,
     QVector<int>& rowHeight, QVector<int>& colWidth ) const
 {
-    if ( numCols <= 0 )
+    if ( numColumns <= 0 )
         return;
 
     if ( d_data->isDirty )
@@ -415,8 +425,8 @@
 
     for ( int index = 0; index < d_data->itemSizeHints.count(); index++ )
     {
-        const int row = index / numCols;
-        const int col = index % numCols;
+        const int row = index / numColumns;
+        const int col = index % numColumns;
 
         const QSize &size = d_data->itemSizeHints[int( index )];
 
@@ -428,7 +438,7 @@
 }
 
 /*!
-  \return true: QwtDynGridLayout implements heightForWidth.
+  \return true: QwtDynGridLayout implements heightForWidth().
   \sa heightForWidth()
 */
 bool QwtDynGridLayout::hasHeightForWidth() const
@@ -437,7 +447,7 @@
 }
 
 /*!
-  \return The preferred height for this layout, given the width w.
+  \return The preferred height for this layout, given a width.
   \sa hasHeightForWidth()
 */
 int QwtDynGridLayout::heightForWidth( int width ) const
@@ -445,15 +455,15 @@
     if ( isEmpty() )
         return 0;
 
-    const uint numCols = columnsForWidth( width );
-    uint numRows = itemCount() / numCols;
-    if ( itemCount() % numCols )
+    const uint numColumns = columnsForWidth( width );
+    uint numRows = itemCount() / numColumns;
+    if ( itemCount() % numColumns )
         numRows++;
 
     QVector<int> rowHeight( numRows );
-    QVector<int> colWidth( numCols );
+    QVector<int> colWidth( numColumns );
 
-    layoutGrid( numCols, rowHeight, colWidth );
+    layoutGrid( numColumns, rowHeight, colWidth );
 
     int h = 2 * margin() + ( numRows - 1 ) * spacing();
     for ( uint row = 0; row < numRows; row++ )
@@ -467,12 +477,17 @@
   rows in case of expanding() & QSizePolicy::Vertical to fill the entire
   rect. Rows and columns are stretched with the same factor.
 
+  \param rect Bounding rectangle
+  \param numColumns Number of columns
+  \param rowHeight Array to be filled with the calculated row heights
+  \param colWidth Array to be filled with the calculated column widths
+
   \sa setExpanding(), expanding()
 */
 void QwtDynGridLayout::stretchGrid( const QRect &rect,
-    uint numCols, QVector<int>& rowHeight, QVector<int>& colWidth ) const
+    uint numColumns, QVector<int>& rowHeight, QVector<int>& colWidth ) const
 {
-    if ( numCols == 0 || isEmpty() )
+    if ( numColumns == 0 || isEmpty() )
         return;
 
     bool expandH, expandV;
@@ -481,15 +496,15 @@
 
     if ( expandH )
     {
-        int xDelta = rect.width() - 2 * margin() - ( numCols - 1 ) * spacing();
-        for ( uint col = 0; col < numCols; col++ )
+        int xDelta = rect.width() - 2 * margin() - ( numColumns - 1 ) * spacing();
+        for ( uint col = 0; col < numColumns; col++ )
             xDelta -= colWidth[col];
 
         if ( xDelta > 0 )
         {
-            for ( uint col = 0; col < numCols; col++ )
+            for ( uint col = 0; col < numColumns; col++ )
             {
-                const int space = xDelta / ( numCols - col );
+                const int space = xDelta / ( numColumns - col );
                 colWidth[col] += space;
                 xDelta -= space;
             }
@@ -498,8 +513,8 @@
 
     if ( expandV )
     {
-        uint numRows = itemCount() / numCols;
-        if ( itemCount() % numCols )
+        uint numRows = itemCount() / numColumns;
+        if ( itemCount() % numColumns )
             numRows++;
 
         int yDelta = rect.height() - 2 * margin() - ( numRows - 1 ) * spacing();
@@ -519,36 +534,37 @@
 }
 
 /*!
-   Return the size hint. If maxCols() > 0 it is the size for
-   a grid with maxCols() columns, otherwise it is the size for
+   Return the size hint. If maxColumns() > 0 it is the size for
+   a grid with maxColumns() columns, otherwise it is the size for
    a grid with only one row.
 
-   \sa maxCols(), setMaxCols()
+   \return Size hint
+   \sa maxColumns(), setMaxColumns()
 */
 QSize QwtDynGridLayout::sizeHint() const
 {
     if ( isEmpty() )
         return QSize();
 
-    uint numCols = itemCount();
-    if ( d_data->maxCols > 0 )
-        numCols = qMin( d_data->maxCols, numCols );
+    uint numColumns = itemCount();
+    if ( d_data->maxColumns > 0 )
+        numColumns = qMin( d_data->maxColumns, numColumns );
 
-    uint numRows = itemCount() / numCols;
-    if ( itemCount() % numCols )
+    uint numRows = itemCount() / numColumns;
+    if ( itemCount() % numColumns )
         numRows++;
 
     QVector<int> rowHeight( numRows );
-    QVector<int> colWidth( numCols );
+    QVector<int> colWidth( numColumns );
 
-    layoutGrid( numCols, rowHeight, colWidth );
+    layoutGrid( numColumns, rowHeight, colWidth );
 
     int h = 2 * margin() + ( numRows - 1 ) * spacing();
     for ( uint row = 0; row < numRows; row++ )
         h += rowHeight[row];
 
-    int w = 2 * margin() + ( numCols - 1 ) * spacing();
-    for ( uint col = 0; col < numCols; col++ )
+    int w = 2 * margin() + ( numColumns - 1 ) * spacing();
+    for ( uint col = 0; col < numColumns; col++ )
         w += colWidth[col];
 
     return QSize( w, h );
@@ -556,7 +572,7 @@
 
 /*!
   \return Number of rows of the current layout.
-  \sa numCols()
+  \sa numColumns()
   \warning The number of rows might change whenever the geometry changes
 */
 uint QwtDynGridLayout::numRows() const
@@ -569,7 +585,7 @@
   \sa numRows()
   \warning The number of columns might change whenever the geometry changes
 */
-uint QwtDynGridLayout::numCols() const
+uint QwtDynGridLayout::numColumns() const
 {
-    return d_data->numCols;
+    return d_data->numColumns;
 }
Index: qwt_raster_data.h
===================================================================
--- qwt_raster_data.h	(revision 382)
+++ qwt_raster_data.h	(working copy)
@@ -38,7 +38,7 @@
     //! Flags to modify the contour algorithm
     enum ConrecFlag
     {
-        //! Ignore all verices on the same level
+        //! Ignore all vertices on the same level
         IgnoreAllVerticesOnLevel = 0x01,
 
         //! Ignore all values, that are out of range
Index: qwt_picker_machine.cpp
===================================================================
--- qwt_picker_machine.cpp	(revision 382)
+++ qwt_picker_machine.cpp	(working copy)
@@ -397,15 +397,17 @@
                 }
                 else
                 {
-                    cmdList += End;
-                    setState( 0 );
+                    cmdList += Append;
                 }
             }
             if ( eventPattern.mouseMatch( QwtEventPattern::MouseSelect2, 
                 static_cast<const QMouseEvent *>( event ) ) )
             {
                 if ( state() == 1 )
-                    cmdList += Append;
+                {
+                    cmdList += End;
+                    setState( 0 );
+                }
             }
             break;
         }
@@ -430,18 +432,92 @@
                 }
                 else
                 {
-                    cmdList += End;
-                    setState( 0 );
+                    cmdList += Append;
                 }
             }
             else if ( eventPattern.keyMatch( QwtEventPattern::KeySelect2, 
                 static_cast<const QKeyEvent *> ( event ) ) )
             {
                 if ( state() == 1 )
+                {
+                    cmdList += End;
+                    setState( 0 );
+                }
+            }
+            break;
+        }
+        default:
+            break;
+    }
+
+    return cmdList;
+}
+
+//! Constructor
+QwtPickerDragLineMachine::QwtPickerDragLineMachine():
+    QwtPickerMachine( PolygonSelection )
+{
+}
+
+//! Transition
+QList<QwtPickerMachine::Command> QwtPickerDragLineMachine::transition(
+    const QwtEventPattern &eventPattern, const QEvent *event )
+{
+    QList<QwtPickerMachine::Command> cmdList;
+
+    switch( event->type() )
+    {
+        case QEvent::MouseButtonPress:
+        {
+            if ( eventPattern.mouseMatch( QwtEventPattern::MouseSelect1,
+                static_cast<const QMouseEvent *>( event ) ) )
+            {
+                if ( state() == 0 )
+                {
+                    cmdList += Begin;
                     cmdList += Append;
+                    cmdList += Append;
+                    setState( 1 );
+                }
             }
             break;
         }
+        case QEvent::KeyPress:
+        {
+            if ( eventPattern.keyMatch( QwtEventPattern::KeySelect1,
+                static_cast<const QKeyEvent *> ( event ) ) )
+            {
+                if ( state() == 0 )
+                {
+                    cmdList += Begin;
+                    cmdList += Append;
+                    cmdList += Append;
+                    setState( 1 );
+                }
+                else
+                {
+                    cmdList += End;
+                    setState( 0 );
+                }
+            }
+            break;
+        }
+        case QEvent::MouseMove:
+        case QEvent::Wheel:
+        {
+            if ( state() != 0 )
+                cmdList += Move;
+
+            break;
+        }
+        case QEvent::MouseButtonRelease:
+        {
+            if ( state() != 0 )
+            {
+                cmdList += End;
+                setState( 0 );
+            }
+        }
         default:
             break;
     }
Index: qwt_plot_multi_barchart.h
===================================================================
--- qwt_plot_multi_barchart.h	(revision 382)
+++ qwt_plot_multi_barchart.h	(working copy)
@@ -11,21 +11,54 @@
 #define QWT_PLOT_BAR_CHART_H
 
 #include "qwt_global.h"
-#include "qwt_plot_baritem.h"
+#include "qwt_plot_abstract_barchart.h"
 #include "qwt_series_data.h"
-#include <qlist.h>
 
 class QwtColumnRect;
 class QwtColumnSymbol;
 
+/*!
+  \brief QwtPlotMultiBarChart displays a series of a samples that consist
+         each of a set of values. 
+
+  Each value is displayed as a bar, the bars of each set can be organized 
+  side by side or accumulated.
+
+  Each bar of a set is rendered by a QwtColumnSymbol, that is set by setSymbol().
+  The bars of different sets use the same symbols. Exceptions are possible
+  by overloading specialSymbol() or overloading drawBar().
+
+  Depending on its orientation() the bars are displayed horizontally 
+  or vertically. The bars cover the interval between the baseline() 
+  and the value.
+
+  In opposite to most other plot items, QwtPlotMultiBarChart returns more
+  than one entry for the legend - one for each symbol.
+   
+  \sa QwtPlotBarChart, QwtPlotHistogram
+      QwtPlotSeriesItem::orientation(), QwtPlotAbstractBarChart::baseline()
+ */
 class QWT_EXPORT QwtPlotMultiBarChart: 
-    public QwtPlotBarItem, public QwtSeriesStore<QwtSetSample>
+    public QwtPlotAbstractBarChart, public QwtSeriesStore<QwtSetSample>
 {
 public:
+    /*!
+        \brief Chart styles.
+
+        The default setting is QwtPlotMultiBarChart::Grouped.
+        \sa setStyle(), style()
+    */
     enum ChartStyle
     {
-        Stacked,
-        Grouped
+        //! The bars of a set are displayed side by side
+        Grouped,
+
+        /*!
+            The bars are displayed on top of each other accumulating
+            to a single bar. All values of a set need to have the same
+            sign.
+         */
+        Stacked
     };
 
     explicit QwtPlotMultiBarChart( const QString &title = QString::null );
@@ -35,23 +68,21 @@
 
     virtual int rtti() const;
 
-    void setTitles( const QList<QwtText> & );
-    QList<QwtText> titles() const;
+    void setBarTitles( const QList<QwtText> & );
+    QList<QwtText> barTitles() const;
 
     void setSamples( const QVector<QwtSetSample> & );
     void setSamples( const QVector< QVector<double> > & );
+    void setSamples( QwtSeriesData<QwtSetSample> * );
 
     void setStyle( ChartStyle style );
     ChartStyle style() const;
 
-    void setColorTable( const QList<QBrush> &colorTable );
-    QList<QBrush> colorTable() const;
-
     void setSymbol( int barIndex, QwtColumnSymbol *symbol );
-    void clearSymbols();
-
     const QwtColumnSymbol *symbol( int barIndex ) const;
 
+    void resetSymbolMap();
+
     virtual void drawSeries( QPainter *painter,
         const QwtScaleMap &xMap, const QwtScaleMap &yMap,
         const QRectF &canvasRect, int from, int to ) const;
@@ -65,6 +96,9 @@
 protected:
     QwtColumnSymbol *symbol( int barIndex );
 
+    virtual QwtColumnSymbol *specialSymbol( 
+        int sampleIndex, int valueIndex ) const;
+
     virtual void drawSample( QPainter *painter,
         const QwtScaleMap &xMap, const QwtScaleMap &yMap,
         const QRectF &canvasRect, const QwtInterval &boundingInterval,
@@ -73,12 +107,6 @@
     virtual void drawBar( QPainter *, int sampleIndex,
         int barIndex, const QwtColumnRect & ) const;
 
-    virtual void drawLabel( QPainter *, int sampleIndex,
-        int barIndex, const QwtColumnRect &, const QwtText & ) const;
-
-    virtual QwtText label( int sampleIndex, int barIndex,
-        const QwtSetSample& ) const;
-
     void drawStackedBars( QPainter *painter,
         const QwtScaleMap &xMap, const QwtScaleMap &yMap,
         const QRectF &canvasRect, int index,
Index: qwt_plot_seriesitem.cpp
===================================================================
--- qwt_plot_seriesitem.cpp	(revision 382)
+++ qwt_plot_seriesitem.cpp	(working copy)
@@ -82,7 +82,7 @@
   \param painter Painter
   \param xMap Maps x-values into pixel coordinates.
   \param yMap Maps y-values into pixel coordinates.
-  \param canvasRect Contents rect of the canvas
+  \param canvasRect Contents rectangle of the canvas
 */
 void QwtPlotSeriesItem::draw( QPainter *painter,
         const QwtScaleMap &xMap, const QwtScaleMap &yMap,
Index: qwt_wheel.h
===================================================================
--- qwt_wheel.h	(revision 382)
+++ qwt_wheel.h	(working copy)
@@ -11,49 +11,63 @@
 #define QWT_WHEEL_H
 
 #include "qwt_global.h"
-#include "qwt_abstract_slider.h"
+#include <qwidget.h>
 
 /*!
   \brief The Wheel Widget
 
   The wheel widget can be used to change values over a very large range
-  in very small steps. Using the setMass member, it can be configured
-  as a flywheel.
+  in very small steps. Using the setMass() member, it can be configured
+  as a flying wheel.
 
+  The default range of the wheel is [0.0, 100.0]
+
   \sa The radio example.
 */
-class QWT_EXPORT QwtWheel : public QwtAbstractSlider
+class QWT_EXPORT QwtWheel: public QWidget
 {
     Q_OBJECT
 
+    Q_PROPERTY( Qt::Orientation orientation
+                READ orientation WRITE setOrientation )
+
+    Q_PROPERTY( double value READ value WRITE setValue )
+    Q_PROPERTY( double minimum READ minimum WRITE setMinimum )
+    Q_PROPERTY( double maximum READ maximum WRITE setMaximum )
+
+    Q_PROPERTY( double singleStep READ singleStep WRITE setSingleStep )
+    Q_PROPERTY( int pageStepCount READ pageStepCount WRITE setPageStepCount )
+    Q_PROPERTY( bool stepAlignment READ stepAlignment WRITE setStepAlignment )
+
+    Q_PROPERTY( bool tracking READ isTracking WRITE setTracking )
+    Q_PROPERTY( bool wrapping READ wrapping WRITE setWrapping )
+    Q_PROPERTY( bool inverted READ isInverted WRITE setInverted )
+
+    Q_PROPERTY( double mass READ mass WRITE setMass )
+    Q_PROPERTY( int updateInterval READ updateInterval WRITE setUpdateInterval )
+
     Q_PROPERTY( double totalAngle READ totalAngle WRITE setTotalAngle )
     Q_PROPERTY( double viewAngle READ viewAngle WRITE setViewAngle )
-    Q_PROPERTY( int tickCnt READ tickCnt WRITE setTickCnt )
+    Q_PROPERTY( int tickCount READ tickCount WRITE setTickCount )
     Q_PROPERTY( int wheelWidth READ wheelWidth WRITE setWheelWidth )
     Q_PROPERTY( int borderWidth READ borderWidth WRITE setBorderWidth )
     Q_PROPERTY( int wheelBorderWidth READ wheelBorderWidth WRITE setWheelBorderWidth )
-    Q_PROPERTY( double mass READ mass WRITE setMass )
 
 public:
     explicit QwtWheel( QWidget *parent = NULL );
     virtual ~QwtWheel();
 
-public Q_SLOTS:
-    void setTotalAngle ( double );
-    void setViewAngle( double );
+    double value() const;
 
-public:
-    virtual void setOrientation( Qt::Orientation );
+    void setOrientation( Qt::Orientation );
+    Qt::Orientation orientation() const;
 
     double totalAngle() const;
     double viewAngle() const;
 
-    void setTickCnt( int );
-    int tickCnt() const;
+    void setTickCount( int );
+    int tickCount() const;
 
-    void setMass( double );
-    double mass() const;
-
     void setWheelWidth( int );
     int wheelWidth() const;
 
@@ -63,25 +77,100 @@
     void setBorderWidth( int );
     int borderWidth() const;
 
+    void setInverted( bool tf );
+    bool isInverted() const;
+
+    void setWrapping( bool tf );
+    bool wrapping() const;
+
+    void setSingleStep( double );
+    double singleStep() const;
+
+    void setPageStepCount( int );
+    int pageStepCount() const;
+
+    void setStepAlignment( bool on );
+    bool stepAlignment() const;
+
+    void setRange( double vmin, double vmax );
+
+    void setMinimum( double min );
+    double minimum() const;
+
+    void setMaximum( double max );
+    double maximum() const;
+
+    void setUpdateInterval( int );
+    int updateInterval() const;
+
+    void setTracking( bool enable );
+    bool isTracking() const;
+
+    double mass() const;
+
+public Q_SLOTS:
+    void setValue( double );
+    void setTotalAngle ( double );
+    void setViewAngle( double );
+    void setMass( double );
+
+Q_SIGNALS:
+
+    /*!
+      \brief Notify a change of value.
+
+      When tracking is enabled this signal will be emitted every
+      time the value changes. 
+
+      \param value new value
+      \sa setTracking()
+    */
+    void valueChanged( double value );
+
+    /*!
+      This signal is emitted when the user presses the
+      the wheel with the mouse
+    */
+    void wheelPressed();
+
+    /*!
+      This signal is emitted when the user releases the mouse
+    */
+    void wheelReleased();
+
+    /*!
+      This signal is emitted when the user moves the
+      wheel with the mouse.
+
+      \param value new value
+    */
+    void wheelMoved( double value );
+
+protected:
+    virtual void paintEvent( QPaintEvent * );
+    virtual void mousePressEvent( QMouseEvent * );
+    virtual void mouseReleaseEvent( QMouseEvent * );
+    virtual void mouseMoveEvent( QMouseEvent * );
+    virtual void keyPressEvent( QKeyEvent * );
+    virtual void wheelEvent( QWheelEvent * );
+    virtual void timerEvent( QTimerEvent * );
+
+    void stopFlying();
+
     QRect wheelRect() const;
 
     virtual QSize sizeHint() const;
     virtual QSize minimumSizeHint() const;
 
-protected:
-    virtual void paintEvent( QPaintEvent * );
-    virtual void resizeEvent( QResizeEvent * );
-
     virtual void drawTicks( QPainter *, const QRectF & );
     virtual void drawWheelBackground( QPainter *, const QRectF & );
 
-    virtual void valueChange();
+    virtual double valueAt( const QPoint & ) const;
 
-    virtual double getValue( const QPoint & );
-    virtual void getScrollMode( const QPoint &,
-        QwtAbstractSlider::ScrollMode &, int &direction ) const;
+private:
+    double alignedValue( double ) const;
+    double boundedValue( double ) const;
 
-private:
     class PrivateData;
     PrivateData *d_data;
 };
Index: qwt_plot_renderer.h
===================================================================
--- qwt_plot_renderer.h	(revision 382)
+++ qwt_plot_renderer.h	(working copy)
@@ -12,10 +12,10 @@
 
 #include "qwt_global.h"
 #include <qobject.h>
+#include <qsize.h>
 
 class QwtPlot;
 class QwtScaleMap;
-class QSizeF;
 class QRectF;
 class QPainter;
 class QPaintDevice;
@@ -58,8 +58,17 @@
         DiscardCanvasBackground = 0x08,
 
         //! Don't render the footer of the plot
-        DiscardFooter           = 0x10
+        DiscardFooter           = 0x10,
 
+        /*! 
+            Don't render the frame of the canvas
+
+            \note This flag has no effect when using
+                  style sheets, where the frame is part
+                  of the background
+         */
+        DiscardCanvasFrame           = 0x20
+
     };
 
     //! Disard flags
@@ -71,17 +80,14 @@
      */
     enum LayoutFlag
     {
-        //! Use the default layout without margins and frames
+        //! Use the default layout as on screen
         DefaultLayout   = 0x00,
 
-        //! Render all frames of the plot
-        KeepFrames      = 0x01,
-
         /*!
           Instead of the scales a box is painted around the plot canvas,
           where the scale ticks are aligned to.
          */
-        FrameWithScales = 0x02
+        FrameWithScales = 0x01
     };
 
     //! Layout flags
@@ -106,7 +112,7 @@
         const QSizeF &sizeMM, int resolution = 85 );
 
     void renderDocument( QwtPlot *,
-        const QString &title, const QString &fileName,
+        const QString &fileName, const QString &format,
         const QSizeF &sizeMM, int resolution = 85 );
 
 #ifndef QWT_NO_SVG
@@ -143,9 +149,10 @@
     virtual void renderLegend( 
         const QwtPlot *, QPainter *, const QRectF & ) const;
 
-    bool exportTo( QwtPlot *, const QString &documentName );
+    bool exportTo( QwtPlot *, const QString &documentName,
+        const QSizeF &sizeMM = QSizeF( 300, 200 ), int resolution = 85 );
 
-protected:
+private:
     void buildCanvasMaps( const QwtPlot *,
         const QRectF &, QwtScaleMap maps[] ) const;
 
Index: qwt_pixel_matrix.h
===================================================================
--- qwt_pixel_matrix.h	(revision 382)
+++ qwt_pixel_matrix.h	(working copy)
@@ -15,7 +15,7 @@
 #include <qrect.h>
 
 /*!
-  \brief A bitfield corresponding to the pixels of a rectangle
+  \brief A bit field corresponding to the pixels of a rectangle
 
   QwtPixelMatrix is intended to filter out duplicates in an
   unsorted array of points.
@@ -29,10 +29,10 @@
     void setRect( const QRect& rect );
     QRect rect() const;
 
-    bool testPixel( const QPoint& pos ) const;
-    bool testAndSetPixel( const QPoint& pos, bool on );
+    bool testPixel( int x, int y ) const;
+    bool testAndSetPixel( int x, int y, bool on );
 
-    int index( const QPoint& pos ) const;
+    int index( int x, int y ) const;
 
 private:
     QRect d_rect;
@@ -41,28 +41,31 @@
 /*!
   \brief Test if a pixel has been set
 
-  \param pos Position
+  \param x X-coordinate
+  \param y Y-coordinate
+
   \return true, when pos is outside of rect(), or when the pixel
           has already been set.
  */
-inline bool QwtPixelMatrix::testPixel( const QPoint& pos ) const
+inline bool QwtPixelMatrix::testPixel( int x, int y ) const
 {
-    const int idx = index( pos );
+    const int idx = index( x, y );
     return ( idx >= 0 ) ? testBit( idx ) : true;
 }
 
 /*!
   \brief Set a pixel and test if a pixel has been set before
 
-  \param pos Position
+  \param x X-coordinate
+  \param y Y-coordinate
   \param on Set/Clear the pixel
 
   \return true, when pos is outside of rect(), or when the pixel
           was set before.
  */
-inline bool QwtPixelMatrix::testAndSetPixel( const QPoint& pos, bool on )
+inline bool QwtPixelMatrix::testAndSetPixel( int x, int y, bool on )
 {
-    const int idx = index( pos );
+    const int idx = index( x, y );
     if ( idx < 0 )
         return true;
 
@@ -73,18 +76,23 @@
 }
 
 /*!
-  \brief Calculate the index in the bitfield correxponding to a position
+  \brief Calculate the index in the bit field corresponding to a position
 
-  \param pos Position
+  \param x X-coordinate
+  \param y Y-coordinate
   \return Index, when rect() contains pos - otherwise -1.
  */
-inline int QwtPixelMatrix::index( const QPoint& pos ) const
+inline int QwtPixelMatrix::index( int x, int y ) const
 {
-    if ( !d_rect.contains( pos ) )
+    const int dx = x - d_rect.x();
+    if ( dx < 0 || dx >= d_rect.width() )
         return -1;
 
-    return d_rect.width() * ( pos.y() - d_rect.y() )
-           + ( pos.x() - d_rect.x() );
+    const int dy = y - d_rect.y();
+    if ( dy < 0 || dy >= d_rect.height() )
+        return -1;
+
+    return dy * d_rect.width() + dx;
 }
 
 #endif
Index: qwt_matrix_raster_data.cpp
===================================================================
--- qwt_matrix_raster_data.cpp	(revision 382)
+++ qwt_matrix_raster_data.cpp	(working copy)
@@ -20,7 +20,7 @@
     {
     }
 
-    inline double value(size_t row, size_t col) const
+    inline double value(int row, int col) const
     {
         return values.data()[ row * numColumns + col ];
     }
@@ -28,8 +28,8 @@
     QwtMatrixRasterData::ResampleMode resampleMode;
 
     QVector<double> values;
-    size_t numColumns;
-    size_t numRows;
+    int numColumns;
+    int numRows;
 
     double dx;
     double dy;
@@ -54,7 +54,7 @@
    \param mode Resampling mode
    \sa resampleMode(), value()
 */
-void QwtMatrixRasterData::setResampleMode(ResampleMode mode)
+void QwtMatrixRasterData::setResampleMode( ResampleMode mode )
 {
     d_data->resampleMode = mode;
 }
@@ -105,10 +105,10 @@
    \sa valueMatrix(), numColumns(), numRows(), setInterval()()
 */
 void QwtMatrixRasterData::setValueMatrix( 
-    const QVector<double> &values, size_t numColumns )
+    const QVector<double> &values, int numColumns )
 {
     d_data->values = values;
-    d_data->numColumns = numColumns;
+    d_data->numColumns = qMax( numColumns, 0 );
     update();
 }
 
@@ -122,10 +122,29 @@
 }
 
 /*!
+  \brief Change a single value in the matrix
+
+  \param row Row index
+  \param col Column index
+  \param value New value
+
+  \sa value(), setValueMatrix()
+*/
+void QwtMatrixRasterData::setValue( int row, int col, double value )
+{
+    if ( row >= 0 && row < d_data->numRows &&
+        col >= 0 && col < d_data->numColumns )
+    {
+        const int index = row * d_data->numColumns + col;
+        d_data->values.data()[ index ] = value;
+    }
+}
+
+/*!
    \return Number of columns of the value matrix
    \sa valueMatrix(), numRows(), setValueMatrix()
 */
-size_t QwtMatrixRasterData::numColumns() const
+int QwtMatrixRasterData::numColumns() const
 {
     return d_data->numColumns;
 }
@@ -134,14 +153,18 @@
    \return Number of rows of the value matrix
    \sa valueMatrix(), numColumns(), setValueMatrix()
 */
-size_t QwtMatrixRasterData::numRows() const
+int QwtMatrixRasterData::numRows() const
 {
     return d_data->numRows;
 }
 
 /*!
-   \brief Pixel hint
+   \brief Calculate the pixel hint
 
+   pixelHint() returns the geometry of a pixel, that can be used 
+   to calculate the resolution and alignment of the plot item, that is
+   representing the data. 
+
    - NearestNeighbour\n
      pixelHint() returns the surrounding pixel of the top left value 
      in the matrix.
@@ -150,10 +173,15 @@
      Returns an empty rectangle recommending
      to render in target device ( f.e. screen ) resolution. 
 
+   \param area Requested area, ignored
+   \return Calculated hint
+
    \sa ResampleMode, setMatrix(), setInterval()
 */
-QRectF QwtMatrixRasterData::pixelHint( const QRectF & ) const
+QRectF QwtMatrixRasterData::pixelHint( const QRectF &area ) const
 {
+    Q_UNUSED( area )
+
     QRectF rect;
     if ( d_data->resampleMode == NearestNeighbour )
     {
@@ -229,8 +257,8 @@
         case NearestNeighbour:
         default:
         {
-            uint row = uint( (y - yInterval.minValue() ) / d_data->dy );
-            uint col = uint( (x - xInterval.minValue() ) / d_data->dx );
+            int row = int( (y - yInterval.minValue() ) / d_data->dy );
+            int col = int( (x - xInterval.minValue() ) / d_data->dx );
 
             // In case of intervals, where the maximum is included
             // we get out of bound for row/col, when the value for the
Index: qwt_plot_marker.cpp
===================================================================
--- qwt_plot_marker.cpp	(revision 382)
+++ qwt_plot_marker.cpp	(working copy)
@@ -128,7 +128,7 @@
   \param painter Painter
   \param xMap x Scale Map
   \param yMap y Scale Map
-  \param canvasRect Contents rect of the canvas in painter coordinates
+  \param canvasRect Contents rectangle of the canvas in painter coordinates
 */
 void QwtPlotMarker::draw( QPainter *painter,
     const QwtScaleMap &xMap, const QwtScaleMap &yMap,
@@ -161,7 +161,7 @@
   Draw the lines marker
 
   \param painter Painter
-  \param canvasRect Contents rect of the canvas in painter coordinates
+  \param canvasRect Contents rectangle of the canvas in painter coordinates
   \param pos Position of the marker, translated into widget coordinates
 
   \sa drawLabel(), QwtSymbol::drawSymbol()
@@ -201,7 +201,7 @@
   Align and draw the text label of the marker
 
   \param painter Painter
-  \param canvasRect Contents rect of the canvas in painter coordinates
+  \param canvasRect Contents rectangle of the canvas in painter coordinates
   \param pos Position of the marker, translated into widget coordinates
 
   \sa drawLabel(), QwtSymbol::drawSymbol()
@@ -391,7 +391,7 @@
 
 /*!
   \brief Set the label
-  \param label label text
+  \param label Label text
   \sa label()
 */
 void QwtPlotMarker::setLabel( const QwtText& label )
@@ -502,6 +502,24 @@
     return d_data->spacing;
 }
 
+/*! 
+  Build and assign a line pen
+    
+  In Qt5 the default pen width is 1.0 ( 0.0 in Qt4 ) what makes it
+  non cosmetic ( see QPen::isCosmetic() ). This method has been introduced
+  to hide this incompatibility.
+    
+  \param color Pen color
+  \param width Pen width
+  \param style Pen style
+    
+  \sa pen(), brush()
+ */ 
+void QwtPlotMarker::setLinePen( const QColor &color, qreal width, Qt::PenStyle style )
+{   
+    setLinePen( QPen( color, width, style ) );
+}
+
 /*!
   Specify a pen for the line.
 
Index: qwt_color_map.h
===================================================================
--- qwt_color_map.h	(revision 382)
+++ qwt_color_map.h	(working copy)
@@ -40,7 +40,7 @@
 
     enum Format
     {
-        //! The map is intended to map into QRgb values.
+        //! The map is intended to map into RGB values.
         RGB,
 
         /*!
@@ -56,16 +56,18 @@
     Format format() const;
 
     /*!
-       Map a value of a given interval into a rgb value.
+       Map a value of a given interval into a RGB value.
+
        \param interval Range for the values
        \param value Value
-       \return rgb value, corresponding to value
+       \return RGB value, corresponding to value
     */
     virtual QRgb rgb( const QwtInterval &interval,
         double value ) const = 0;
 
     /*!
        Map a value of a given interval into a color index
+
        \param interval Range for the values
        \param value Value
        \return color index, corresponding to value
@@ -135,7 +137,7 @@
 };
 
 /*!
-  \brief QwtAlphaColorMap variies the alpha value of a color
+  \brief QwtAlphaColorMap varies the alpha value of a color
 */
 class QWT_EXPORT QwtAlphaColorMap: public QwtColorMap
 {
Index: qwt_abstract_legend.cpp
===================================================================
--- qwt_abstract_legend.cpp	(revision 382)
+++ qwt_abstract_legend.cpp	(working copy)
@@ -26,7 +26,7 @@
 
 /*!
    Return the extent, that is needed for elements to scroll
-   the legend ( usually scroll bars ),
+   the legend ( usually scrollbars ),
 
    \param orientation Orientation
    \return Extent of the corresponding scroll element
Index: qwt_graphic.h
===================================================================
--- qwt_graphic.h	(revision 382)
+++ qwt_graphic.h	(working copy)
@@ -69,7 +69,7 @@
     Because the offset for drawing the outline depends on the shape 
     of the painter path ( the peak of a triangle is different than the flat side ) 
     scaling with a fixed aspect ratio always needs to be calculated from the 
-	control point rectangle.
+    control point rectangle.
 
     \sa QwtPainterCommand
  */
@@ -77,8 +77,8 @@
 {
 public:
     /*! 
-		Hint how to render a graphic
-		\sa setRenderHint(), testRenderHint()
+        Hint how to render a graphic
+        \sa setRenderHint(), testRenderHint()
      */
     enum RenderHint
     {
@@ -131,7 +131,7 @@
     QImage toImage( const QSize &, 
         Qt::AspectRatioMode = Qt::IgnoreAspectRatio  ) const;
 
-	QRectF scaledBoundingRect( double sx, double sy ) const;
+    QRectF scaledBoundingRect( double sx, double sy ) const;
 
     QRectF boundingRect() const;
     QRectF controlPointRect() const;
Index: qwt_point_data.cpp
===================================================================
--- qwt_point_data.cpp	(revision 382)
+++ qwt_point_data.cpp	(working copy)
@@ -9,6 +9,7 @@
 
 #include "qwt_point_data.h"
 #include "qwt_math.h"
+#include <string.h>
 
 /*!
   Constructor
@@ -37,14 +38,14 @@
         const double *y, size_t size )
 {
     d_x.resize( size );
-    qMemCopy( d_x.data(), x, size * sizeof( double ) );
+    ::memcpy( d_x.data(), x, size * sizeof( double ) );
 
     d_y.resize( size );
-    qMemCopy( d_y.data(), y, size * sizeof( double ) );
+    ::memcpy( d_y.data(), y, size * sizeof( double ) );
 }
 
 /*!
-  \brief Calculate the bounding rect
+  \brief Calculate the bounding rectangle
 
   The bounding rectangle is calculated once by iterating over all
   points and is stored for all following requests.
@@ -68,12 +69,12 @@
 /*!
   Return the sample at position i
 
-  \param i Index
+  \param index Index
   \return Sample at position i
 */
-QPointF QwtPointArrayData::sample( size_t i ) const
+QPointF QwtPointArrayData::sample( size_t index ) const
 {
-    return QPointF( d_x[int( i )], d_y[int( i )] );
+    return QPointF( d_x[int( index )], d_y[int( index )] );
 }
 
 //! \return Array of the x-values
@@ -110,7 +111,7 @@
 }
 
 /*!
-  \brief Calculate the bounding rect
+  \brief Calculate the bounding rectangle
 
   The bounding rectangle is calculated once by iterating over all
   points and is stored for all following requests.
@@ -134,12 +135,12 @@
 /*!
   Return the sample at position i
 
-  \param i Index
+  \param index Index
   \return Sample at position i
 */
-QPointF QwtCPointerData::sample( size_t i ) const
+QPointF QwtCPointerData::sample( size_t index ) const
 {
-    return QPointF( d_x[int( i )], d_y[int( i )] );
+    return QPointF( d_x[int( index )], d_y[int( index )] );
 }
 
 //! \return Array of the x-values
@@ -210,7 +211,7 @@
 }
 
 /*!
-   Set a the "rect of interest"
+   Set a the "rectangle of interest"
 
    QwtPlotSeriesItem defines the current area of the plot canvas
    as "rect of interest" ( QwtPlotSeriesItem::updateScaleDiv() ).
@@ -228,7 +229,7 @@
 }
 
 /*!
-   \return "rect of interest"
+   \return "rectangle of interest"
    \sa setRectOfInterest()
 */
 QRectF QwtSyntheticPointData::rectOfInterest() const
@@ -237,7 +238,7 @@
 }
 
 /*!
-  \brief Calculate the bounding rect
+  \brief Calculate the bounding rectangle
 
   This implementation iterates over all points, what could often
   be implemented much faster using the characteristics of the series.
@@ -281,10 +282,13 @@
 /*!
    Calculate a x-value from an index
 
-   x values are calculated by deviding an interval into
+   x values are calculated by dividing an interval into
    equidistant steps. If !interval().isValid() the
-   interval is calculated from the "rect of interest".
+   interval is calculated from the "rectangle of interest".
 
+   \param index Index of the requested point 
+   \return Calculated x coordinate
+
    \sa interval(), rectOfInterest(), y()
 */
 double QwtSyntheticPointData::x( uint index ) const
Index: qwt_plot.h
===================================================================
--- qwt_plot.h	(revision 382)
+++ qwt_plot.h	(working copy)
@@ -17,6 +17,7 @@
 #include "qwt_interval.h"
 #include <qframe.h>
 #include <qlist.h>
+#include <qvariant.h>
 
 class QwtPlotLayout;
 class QwtAbstractLegend;
@@ -25,7 +26,6 @@
 class QwtScaleDiv;
 class QwtScaleDraw;
 class QwtTextLabel;
-class QwtPlotCanvas;
 
 /*!
   \brief A 2-D plotting widget
@@ -36,10 +36,13 @@
   (QwtPlotMarker), the grid (QwtPlotGrid), or anything else derived
   from QwtPlotItem.
   A plot can have up to four axes, with each plot item attached to an x- and
-  a y axis. The scales at the axes can be explicitely set (QwtScaleDiv), or
+  a y axis. The scales at the axes can be explicitly set (QwtScaleDiv), or
   are calculated from the plot items, using algorithms (QwtScaleEngine) which
   can be configured separately for each axis.
 
+  The simpleplot example is a good starting point to see how to set up a 
+  plot widget.
+
   \image html plot.png
 
   \par Example
@@ -71,8 +74,19 @@
 class QWT_EXPORT QwtPlot: public QFrame, public QwtPlotDict
 {
     Q_OBJECT
+
+    Q_PROPERTY( QBrush canvasBackground 
+        READ canvasBackground WRITE setCanvasBackground )
+    Q_PROPERTY( bool autoReplot READ autoReplot WRITE setAutoReplot )
+
+#if 0
+    // This property is intended to configure the plot
+    // widget from a special dialog in the deigner plugin.
+    // Disabled until such a dialog has been implemented.
+
     Q_PROPERTY( QString propertiesDocument
         READ grabProperties WRITE applyProperties )
+#endif
 
 public:
     //! \brief Axis index
@@ -98,8 +112,6 @@
         Position of the legend, relative to the canvas.
 
         \sa insertLegend()
-        \note In case of ExternalLegend, the legend is not
-              handled by QwtPlotRenderer
      */
     enum LegendPosition
     {
@@ -113,30 +125,24 @@
         BottomLegend,
 
         //! The legend will be above the title
-        TopLegend,
-
-        /*!
-          External means that only the content of the legend
-          will be handled by QwtPlot, but not its geometry.
-          This type can be used to have a legend in an 
-          external window ( or on the canvas ).
-         */
-        ExternalLegend
+        TopLegend
     };
 
     explicit QwtPlot( QWidget * = NULL );
-    explicit QwtPlot( const QwtText &title, QWidget *p = NULL );
+    explicit QwtPlot( const QwtText &title, QWidget * = NULL );
 
     virtual ~QwtPlot();
 
     void applyProperties( const QString & );
     QString grabProperties() const;
 
-    void setAutoReplot( bool tf = true );
+    void setAutoReplot( bool = true );
     bool autoReplot() const;
 
     // Layout
 
+    void setPlotLayout( QwtPlotLayout * );
+
     QwtPlotLayout *plotLayout();
     const QwtPlotLayout *plotLayout() const;
 
@@ -157,17 +163,17 @@
 
     QwtTextLabel *footerLabel();
     const QwtTextLabel *footerLabel() const;
+
     // Canvas
 
-    QwtPlotCanvas *canvas();
-    const QwtPlotCanvas *canvas() const;
+    void setCanvas( QWidget * );
 
+    QWidget *canvas();
+    const QWidget *canvas() const;
+
     void setCanvasBackground( const QBrush & );
     QBrush canvasBackground() const;
 
-    void setCanvasLineWidth( int w );
-    int canvasLineWidth() const;
-
     virtual QwtScaleMap canvasMap( int axisId ) const;
 
     double invTransform( int axisId, int pos ) const;
@@ -248,6 +254,9 @@
     virtual void drawItems( QPainter *, const QRectF &,
         const QwtScaleMap maps[axisCnt] ) const;
 
+    virtual QVariant itemToInfo( QwtPlotItem * ) const;
+    virtual QwtPlotItem *infoToItem( const QVariant & ) const;
+
 Q_SIGNALS:
     /*!
       A signal indicating, that an item has been attached/detached
@@ -261,10 +270,13 @@
       A signal with the attributes how to update 
       the legend entries for a plot item.
 
-      \param plotItem Plot item
-      \param data List of attributes for items on a legend
+      \param itemInfo Info about a plot item, build from itemToInfo()
+      \param data Attributes of the entries ( usually <= 1 ) for
+                  the plot item.
+
+      \sa itemToInfo(), infoToItem(), QwtAbstractLegend::updateLegend()
      */
-    void legendDataChanged( const QwtPlotItem *plotItem, 
+    void legendDataChanged( const QVariant &itemInfo, 
         const QList<QwtLegendData> &data );
 
 public Q_SLOTS:
@@ -277,7 +289,7 @@
     virtual void resizeEvent( QResizeEvent *e );
 
 private Q_SLOTS:
-    void updateLegendItems( const QwtPlotItem *plotItem,
+    void updateLegendItems( const QVariant &itemInfo,
         const QList<QwtLegendData> &data );
 
 private:
Index: qwt_event_pattern.h
===================================================================
--- qwt_event_pattern.h	(revision 382)
+++ qwt_event_pattern.h	(working copy)
@@ -32,105 +32,115 @@
     /*!
       \brief Symbolic mouse input codes
 
-      The default initialization for 3 button mice is:
-      - MouseSelect1\n
-        Qt::LeftButton
-      - MouseSelect2\n
-        Qt::RightButton
-      - MouseSelect3\n
-        Qt::MidButton
-      - MouseSelect4\n
-        Qt::LeftButton + Qt::ShiftButton
-      - MouseSelect5\n
-        Qt::RightButton + Qt::ShiftButton
-      - MouseSelect6\n
-        Qt::MidButton + Qt::ShiftButton
+      QwtEventPattern implements 3 different settings for
+      mice with 1, 2, or 3 buttons that can be activated
+      using initMousePattern(). The default setting is for
+      3 button mice.
 
-      The default initialization for 2 button mice is:
-      - MouseSelect1\n
-        Qt::LeftButton
-      - MouseSelect2\n
-        Qt::RightButton
-      - MouseSelect3\n
-        Qt::LeftButton + Qt::AltButton
-      - MouseSelect4\n
-        Qt::LeftButton + Qt::ShiftButton
-      - MouseSelect5\n
-        Qt::RightButton + Qt::ShiftButton
-      - MouseSelect6\n
-        Qt::LeftButton + Qt::AltButton + Qt::ShiftButton
+      Individual settings can be configured using setMousePattern().
 
-      The default initialization for 1 button mice is:
-      - MouseSelect1\n
-        Qt::LeftButton
-      - MouseSelect2\n
-        Qt::LeftButton + Qt::ControlButton
-      - MouseSelect3\n
-        Qt::LeftButton + Qt::AltButton
-      - MouseSelect4\n
-        Qt::LeftButton + Qt::ShiftButton
-      - MouseSelect5\n
-        Qt::LeftButton + Qt::ControlButton + Qt::ShiftButton
-      - MouseSelect6\n
-        Qt::LeftButton + Qt::AltButton + Qt::ShiftButton
-
-      \sa initMousePattern()
+      \sa initMousePattern(), setMousePattern(), setKeyPattern()
     */
-
     enum MousePatternCode
     {
+        /*! 
+          The default setting for 1, 2 and 3 button mice is:
+
+          - Qt::LeftButton 
+          - Qt::LeftButton 
+          - Qt::LeftButton 
+         */
         MouseSelect1,
+
+        /*!
+          The default setting for 1, 2 and 3 button mice is:
+
+          - Qt::LeftButton + Qt::ControlModifier
+          - Qt::RightButton
+          - Qt::RightButton
+         */
         MouseSelect2,
+
+        /*!
+          The default setting for 1, 2 and 3 button mice is:
+
+          - Qt::LeftButton + Qt::AltModifier
+          - Qt::LeftButton + Qt::AltModifier
+          - Qt::MidButton
+         */
         MouseSelect3,
+
+        /*!
+          The default setting for 1, 2 and 3 button mice is:
+
+          - Qt::LeftButton + Qt::ShiftModifier
+          - Qt::LeftButton + Qt::ShiftModifier
+          - Qt::LeftButton + Qt::ShiftModifier
+         */
         MouseSelect4,
+
+        /*!
+          The default setting for 1, 2 and 3 button mice is:
+
+          - Qt::LeftButton + Qt::ControlButton | Qt::ShiftModifier
+          - Qt::RightButton + Qt::ShiftModifier
+          - Qt::RightButton + Qt::ShiftModifier
+         */
         MouseSelect5,
+
+        /*!
+          The default setting for 1, 2 and 3 button mice is:
+
+          - Qt::LeftButton + Qt::AltModifier + Qt::ShiftModifier
+          - Qt::LeftButton + Qt::AltModifier | Qt::ShiftModifier
+          - Qt::MidButton + Qt::ShiftModifier
+         */
         MouseSelect6,
 
+        //! Number of mouse patterns
         MousePatternCount
     };
 
     /*!
       \brief Symbolic keyboard input codes
 
-      Default initialization:
-      - KeySelect1\n
-        Qt::Key_Return
-      - KeySelect2\n
-        Qt::Key_Space
-      - KeyAbort\n
-        Qt::Key_Escape
+      Individual settings can be configured using setKeyPattern()
 
-      - KeyLeft\n
-        Qt::Key_Left
-      - KeyRight\n
-        Qt::Key_Right
-      - KeyUp\n
-        Qt::Key_Up
-      - KeyDown\n
-        Qt::Key_Down
-
-      - KeyUndo\n
-        Qt::Key_Minus
-      - KeyRedo\n
-        Qt::Key_Plus
-      - KeyHome\n
-        Qt::Key_Escape
+      \sa setKeyPattern(), setMousePattern()
     */
     enum KeyPatternCode
     {
+        //! Qt::Key_Return
         KeySelect1,
+
+        //! Qt::Key_Space
         KeySelect2,
+
+        //! Qt::Key_Escape
         KeyAbort,
 
+        //! Qt::Key_Left
         KeyLeft,
+
+        //! Qt::Key_Right
         KeyRight,
+
+        //! Qt::Key_Up
         KeyUp,
+
+        //! Qt::Key_Down
         KeyDown,
 
+        //! Qt::Key_Plus
         KeyRedo,
+
+        //! Qt::Key_Minus
         KeyUndo,
+
+        //! Qt::Key_Escape
         KeyHome,
 
+        //! Number of key patterns
         KeyPatternCount
     };
 
@@ -139,17 +149,18 @@
     {
     public:
         //! Constructor
-        MousePattern( int btn = Qt::NoButton, int st = Qt::NoButton )
+        MousePattern( Qt::MouseButton btn = Qt::NoButton, 
+                Qt::KeyboardModifiers modifierCodes = Qt::NoModifier ):
+            button( btn ),
+            modifiers( modifierCodes )
         {
-            button = btn;
-            state = st;
         }
 
-        //! Button code
-        int button;
+        //! Button 
+        Qt::MouseButton button;
 
-        //! State
-        int state;
+        //! Keyboard modifier
+        Qt::KeyboardModifiers modifiers;
     };
 
     //! A pattern for key events
@@ -157,17 +168,18 @@
     {
     public:
         //! Constructor
-        KeyPattern( int k = 0, int st = Qt::NoButton )
+        KeyPattern( int keyCode = Qt::Key_unknown, 
+                Qt::KeyboardModifiers modifierCodes = Qt::NoModifier ):
+            key( keyCode ),
+            modifiers( modifierCodes )
         {
-            key = k;
-            state = st;
         }
 
         //! Key code
         int key;
 
-        //! State
-        int state;
+        //! Modifiers
+        Qt::KeyboardModifiers modifiers;
     };
 
     QwtEventPattern();
@@ -176,9 +188,12 @@
     void initMousePattern( int numButtons );
     void initKeyPattern();
 
-    void setMousePattern( uint pattern, int button, int state = Qt::NoButton );
-    void setKeyPattern( uint pattern, int key, int state = Qt::NoButton );
+    void setMousePattern( MousePatternCode, Qt::MouseButton button, 
+        Qt::KeyboardModifiers = Qt::NoModifier );
 
+    void setKeyPattern( KeyPatternCode, int keyCode, 
+        Qt::KeyboardModifiers modifierCodes = Qt::NoModifier );
+
     void setMousePattern( const QVector<MousePattern> & );
     void setKeyPattern( const QVector<KeyPattern> & );
 
@@ -188,8 +203,8 @@
     QVector<MousePattern> &mousePattern();
     QVector<KeyPattern> &keyPattern();
 
-    bool mouseMatch( uint pattern, const QMouseEvent * ) const;
-    bool keyMatch( uint pattern, const QKeyEvent * ) const;
+    bool mouseMatch( MousePatternCode, const QMouseEvent * ) const;
+    bool keyMatch( KeyPatternCode, const QKeyEvent * ) const;
 
 protected:
     virtual bool mouseMatch( const MousePattern &, const QMouseEvent * ) const;
@@ -212,14 +227,14 @@
 inline bool operator==( QwtEventPattern::MousePattern b1,
     QwtEventPattern::MousePattern  b2 )
 {
-    return b1.button == b2.button && b1.state == b2.state;
+    return b1.button == b2.button && b1.modifiers == b2.modifiers;
 }
 
 //! Compare operator
 inline bool operator==( QwtEventPattern::KeyPattern b1,
    QwtEventPattern::KeyPattern  b2 )
 {
-    return b1.key == b2.key && b1.state == b2.state;
+    return b1.key == b2.key && b1.modifiers == b2.modifiers;
 }
 
 #endif
Index: qwt_plot_barchart.cpp
===================================================================
--- qwt_plot_barchart.cpp	(revision 382)
+++ qwt_plot_barchart.cpp	(working copy)
@@ -12,31 +12,46 @@
 #include "qwt_column_symbol.h"
 #include "qwt_painter.h"
 #include <qpainter.h>
-#include <qpalette.h>
 
 class QwtPlotBarChart::PrivateData
 {
 public:
     PrivateData():
-        symbol( NULL )
+        symbol( NULL ),
+        legendMode( QwtPlotBarChart::LegendChartTitle )
     {
     }
+ 
+    ~PrivateData()
+    {
+        delete symbol;
+    }
 
     QwtColumnSymbol *symbol;
+    QwtPlotBarChart::LegendMode legendMode;
 };
 
+/*!
+  Constructor
+  \param title Title of the curve
+*/
 QwtPlotBarChart::QwtPlotBarChart( const QwtText &title ):
-    QwtPlotBarItem( title )
+    QwtPlotAbstractBarChart( title )
 {
     init();
 }
 
+/*!
+  Constructor
+  \param title Title of the curve
+*/
 QwtPlotBarChart::QwtPlotBarChart( const QString &title ):
-    QwtPlotBarItem( QwtText( title ) )
+    QwtPlotAbstractBarChart( QwtText( title ) )
 {
     init();
 }
 
+//! Destructor
 QwtPlotBarChart::~QwtPlotBarChart()
 {
     delete d_data;
@@ -54,12 +69,28 @@
     return QwtPlotItem::Rtti_PlotBarChart;
 }
 
+/*!
+  Initialize data with an array of points
+
+  \param samples Vector of points
+  \note QVector is implicitly shared
+  \note QPolygonF is derived from QVector<QPointF>
+*/
 void QwtPlotBarChart::setSamples(
     const QVector<QPointF> &samples )
 {
     setData( new QwtPointSeriesData( samples ) );
 }
 
+/*!
+  Initialize data with an array of doubles
+
+  The indices in the array are taken as x coordinate,
+  while the doubles are interpreted as y values.
+
+  \param samples Vector of y coordinates
+  \note QVector is implicitly shared
+*/
 void QwtPlotBarChart::setSamples(
     const QVector<double> &samples )
 {
@@ -70,6 +101,31 @@
     setData( new QwtPointSeriesData( points ) );
 }
 
+/*!
+  Assign a series of samples
+
+  setSamples() is just a wrapper for setData() without any additional
+  value - beside that it is easier to find for the developer.
+
+  \param data Data
+  \warning The item takes ownership of the data object, deleting
+           it when its not used anymore.
+*/
+void QwtPlotBarChart::setSamples( QwtSeriesData<QPointF> *data )
+{
+    setData( data );
+}
+
+/*!
+  \brief Assign a symbol
+
+  The bar chart will take the ownership of the symbol, hence the previously
+  set symbol will be delete by setting a new one. If \p symbol is 
+  \c NULL no symbol will be drawn.
+
+  \param symbol Symbol
+  \sa symbol()
+*/
 void QwtPlotBarChart::setSymbol( QwtColumnSymbol *symbol )
 {
     if ( symbol != d_data->symbol )
@@ -91,6 +147,37 @@
     return d_data->symbol;
 }
 
+/*!
+  Set the mode that decides what to display on the legend
+
+  In case of LegendBarTitles barTitle() needs to be overloaded
+  to return individual titles for each bar.
+
+  \param mode New mode
+  \sa legendMode(), legendData(), barTitle(), QwtPlotItem::ItemAttribute
+ */
+void QwtPlotBarChart::setLegendMode( LegendMode mode )
+{
+    if ( mode != d_data->legendMode )
+    {
+        d_data->legendMode = mode;
+        legendChanged();
+    }
+}
+
+/*!
+  \return Legend mode
+  \sa setLegendMode()
+ */
+QwtPlotBarChart::LegendMode QwtPlotBarChart::legendMode() const
+{
+    return d_data->legendMode;
+}
+
+/*!
+  \return Bounding rectangle of all samples.
+  For an empty series the rectangle is invalid.
+*/
 QRectF QwtPlotBarChart::boundingRect() const
 {
     const size_t numSamples = dataSize();
@@ -160,82 +247,209 @@
   \param yMap y map
   \param canvasRect Contents rect of the canvas
   \param boundingInterval Bounding interval of sample values
-  \param from Index of the first point to be painted
-  \param to Index of the last point to be painted
+  \param index Index of the sample
+  \param sample Value of the sample
 
   \sa drawSeries()
 */
 void QwtPlotBarChart::drawSample( QPainter *painter,
     const QwtScaleMap &xMap, const QwtScaleMap &yMap,
     const QRectF &canvasRect, const QwtInterval &boundingInterval,
-    int index, const QPointF &point ) const
+    int index, const QPointF &sample ) const
 {
-    double sampleW;
+    QwtColumnRect barRect;
 
     if ( orientation() == Qt::Horizontal )
     {
-        sampleW = sampleWidth( yMap, canvasRect.height(),
-            boundingInterval.width(), point.y() );
+        const double barHeight = sampleWidth( yMap, canvasRect.height(),
+            boundingInterval.width(), sample.y() );
+
+        const double x1 = xMap.transform( baseline() );
+        const double x2 = xMap.transform( sample.y() );
+
+        const double y = yMap.transform( sample.x() );
+        const double y1 = y - 0.5 * barHeight;
+        const double y2 = y + 0.5 * barHeight;
+
+        barRect.direction = ( x1 < x2 ) ?
+            QwtColumnRect::LeftToRight : QwtColumnRect::RightToLeft;
+
+        barRect.hInterval = QwtInterval( x1, x2 ).normalized();
+        barRect.vInterval = QwtInterval( y1, y2 );
     }
     else
     {
-        sampleW = sampleWidth( xMap, canvasRect.width(),
-            boundingInterval.width(), point.y() );
+        const double barWidth = sampleWidth( xMap, canvasRect.width(),
+            boundingInterval.width(), sample.y() );
+
+        const double x = xMap.transform( sample.x() );
+        const double x1 = x - 0.5 * barWidth;
+        const double x2 = x + 0.5 * barWidth;
+
+        const double y1 = yMap.transform( baseline() );
+        const double y2 = yMap.transform( sample.y() );
+
+        barRect.direction = ( y1 < y2 ) ?
+            QwtColumnRect::TopToBottom : QwtColumnRect::BottomToTop;
+
+        barRect.hInterval = QwtInterval( x1, x2 );
+        barRect.vInterval = QwtInterval( y1, y2 ).normalized();
     }
 
-    // ....
-    Q_UNUSED( painter );
-    Q_UNUSED( sampleW );
-    Q_UNUSED( index );
+    drawBar( painter, index, sample, barRect );
 }
 
+/*!
+  Draw a bar 
+
+  \param painter Painter
+  \param sampleIndex Index of the sample represented by the bar
+  \param sample Value of the sample
+  \param rect Bounding rectangle of the bar
+ */
 void QwtPlotBarChart::drawBar( QPainter *painter,
-    int sampleIndex, const QwtColumnRect &rect ) const
+    int sampleIndex, const QPointF &sample, 
+    const QwtColumnRect &rect ) const
 {
-    static Qt::GlobalColor colors[] =
-        { Qt::blue, Qt::red, Qt::green, Qt::magenta, Qt::yellow };
+    const QwtColumnSymbol *specialSym = 
+        specialSymbol( sampleIndex, sample );
 
-    const int colorIndex = sampleIndex % ( sizeof( colors ) / sizeof( colors[0] ) );
+    const QwtColumnSymbol *sym = specialSym;
+    if ( sym == NULL )
+        sym = d_data->symbol;
 
-    if ( d_data->symbol &&
-        ( d_data->symbol->style() != QwtColumnSymbol::NoStyle ) )
+    if ( sym )
     {
-        d_data->symbol->setPalette( QPalette( colors[ colorIndex ] ) );
-        d_data->symbol->draw( painter, rect );
+        sym->draw( painter, rect );
     }
     else
     {
-        QRectF r = rect.toRect();
-        if ( QwtPainter::roundingAlignment( painter ) )
-        {
-            r.setLeft( qRound( r.left() ) );
-            r.setRight( qRound( r.right() ) );
-            r.setTop( qRound( r.top() ) );
-            r.setBottom( qRound( r.bottom() ) );
-        }
+        // we build a temporary default symbol
+        QwtColumnSymbol sym( QwtColumnSymbol::Box );
+        sym.setLineWidth( 1 );
+        sym.setFrameStyle( QwtColumnSymbol::Plain );
+        sym.draw( painter, rect );
+    }
 
-        painter->setPen( QPen( Qt::black, 1 ) );
-        painter->setBrush( colors[ colorIndex ] );
-        QwtPainter::drawRect( painter, r );
-    }
+    delete specialSym;
 }
 
-void QwtPlotBarChart::drawLabel( QPainter *painter, int sampleIndex,
-    const QwtColumnRect &rect, const QwtText &text ) const
+/*!
+  Needs to be overloaded to return a 
+  non default symbol for a specific sample
+
+  \param sampleIndex Index of the sample represented by the bar
+  \param sample Value of the sample
+
+  \return NULL, indicating to use the default symbol
+ */
+QwtColumnSymbol *QwtPlotBarChart::specialSymbol( 
+    int sampleIndex, const QPointF &sample ) const
 {
-    Q_UNUSED( painter );
     Q_UNUSED( sampleIndex );
-    Q_UNUSED( rect );
-    Q_UNUSED( text );
+    Q_UNUSED( sample );
+
+    return NULL;
 }
 
-QwtText QwtPlotBarChart::label(
-    int sampleIndex, const QPointF &sample ) const
+/*!
+  \brief Return the title of a bar
+
+  In LegendBarTitles mode the title is displayed on
+  the legend entry corresponding to a bar.
+
+  The default implementation is a dummy, that is intended
+  to be overloaded.
+
+  \param sampleIndex Index of the bar
+  \return An empty text
+  \sa LegendBarTitles
+ */
+QwtText QwtPlotBarChart::barTitle( int sampleIndex ) const
 {
     Q_UNUSED( sampleIndex );
+    return QwtText();
+}
 
-    QString labelText;
-    labelText.setNum( sample.y() );
+/*!
+   \brief Return all information, that is needed to represent
+          the item on the legend
 
-    return QwtText( labelText );
+   In case of LegendBarTitles an entry for each bar is returned,
+   otherwise the chart is represented like any other plot item
+   from its title() and the legendIcon().
+
+   \return Information, that is needed to represent the item on the legend
+   \sa title(), setLegendMode(), barTitle(), QwtLegend, QwtPlotLegendItem
+ */
+QList<QwtLegendData> QwtPlotBarChart::legendData() const
+{
+    QList<QwtLegendData> list;
+
+    if ( d_data->legendMode == LegendBarTitles )
+    {
+        const size_t numSamples = dataSize();
+        for ( size_t i = 0; i < numSamples; i++ )
+        {
+            QwtLegendData data;
+
+            QVariant titleValue;
+            qVariantSetValue( titleValue, barTitle( i ) );
+            data.setValue( QwtLegendData::TitleRole, titleValue );
+
+            if ( !legendIconSize().isEmpty() )
+            {
+                QVariant iconValue;
+                qVariantSetValue( iconValue,
+                    legendIcon( i, legendIconSize() ) );
+
+                data.setValue( QwtLegendData::IconRole, iconValue );
+            }
+
+            list += data;
+        }
+    }
+    else
+    {
+        return QwtPlotAbstractBarChart::legendData();
+    }
+
+    return list;
 }
+
+/*!
+   \return Icon representing a bar or the chart on the legend
+
+   When the legendMode() is LegendBarTitles the icon shows
+   the bar corresponding to index - otherwise the bar
+   displays the default symbol.
+
+   \param index Index of the legend entry 
+   \param size Icon size
+
+   \sa setLegendMode(), drawBar(), 
+       QwtPlotItem::setLegendIconSize(), QwtPlotItem::legendData()
+ */
+QwtGraphic QwtPlotBarChart::legendIcon( 
+    int index, const QSizeF &size ) const
+{
+    QwtColumnRect column;
+    column.hInterval = QwtInterval( 0.0, size.width() - 1.0 );
+    column.vInterval = QwtInterval( 0.0, size.height() - 1.0 );
+
+    QwtGraphic icon;
+    icon.setDefaultSize( size );
+    icon.setRenderHint( QwtGraphic::RenderPensUnscaled, true );
+
+    QPainter painter( &icon );
+    painter.setRenderHint( QPainter::Antialiasing,
+        testRenderHint( QwtPlotItem::RenderAntialiased ) );
+
+    int barIndex = -1;
+    if ( d_data->legendMode == QwtPlotBarChart::LegendBarTitles )
+        barIndex = index;
+        
+    drawBar( &painter, barIndex, QPointF(), column );
+
+    return icon;
+}
Index: qwt_text.cpp
===================================================================
--- qwt_text.cpp	(revision 382)
+++ qwt_text.cpp	(working copy)
@@ -138,7 +138,8 @@
 public:
     PrivateData():
         renderFlags( Qt::AlignCenter ),
-        backgroundPen( Qt::NoPen ),
+        borderRadius( 0 ),
+        borderPen( Qt::NoPen ),
         backgroundBrush( Qt::NoBrush ),
         paintAttributes( 0 ),
         layoutAttributes( 0 ),
@@ -150,7 +151,8 @@
     QString text;
     QFont font;
     QColor color;
-    QPen backgroundPen;
+    double borderRadius;
+    QPen borderPen;
     QBrush backgroundBrush;
 
     QwtText::PaintAttributes paintAttributes;
@@ -218,7 +220,8 @@
         d_data->text == other.d_data->text &&
         d_data->font == other.d_data->font &&
         d_data->color == other.d_data->color &&
-        d_data->backgroundPen == other.d_data->backgroundPen &&
+        d_data->borderRadius == other.d_data->borderRadius &&
+        d_data->borderPen == other.d_data->borderPen &&
         d_data->backgroundBrush == other.d_data->backgroundBrush &&
         d_data->paintAttributes == other.d_data->paintAttributes &&
         d_data->textEngine == other.d_data->textEngine;
@@ -247,7 +250,7 @@
 }
 
 /*!
-   Return the text.
+   \return Text as QString.
    \sa setText()
 */
 QString QwtText::text() const
@@ -260,7 +263,7 @@
 
    The default setting is Qt::AlignCenter
 
-   \param renderFlags Bitwise OR of the flags used like in QPainter::drawText
+   \param renderFlags Bitwise OR of the flags used like in QPainter::drawText()
 
    \sa renderFlags(), QwtTextEngine::draw()
    \note Some renderFlags might have no effect, depending on the text format.
@@ -303,11 +306,13 @@
 }
 
 /*!
-  Return the font of the text, if it has one.
-  Otherwise return defaultFont.
+   Return the font of the text, if it has one.
+   Otherwise return defaultFont.
 
-  \param defaultFont Default font
-  \sa setFont(), font(), PaintAttributes
+   \param defaultFont Default font
+   \return Font used for drawing the text
+
+   \sa setFont(), font(), PaintAttributes
 */
 QFont QwtText::usedFont( const QFont &defaultFont ) const
 {
@@ -318,7 +323,7 @@
 }
 
 /*!
-   Set the pen color used for painting the text.
+   Set the pen color used for drawing the text.
 
    \param color Color
    \note Setting the color might have no effect, when
@@ -341,6 +346,8 @@
   Otherwise return defaultColor.
 
   \param defaultColor Default color
+  \return Color used for drawing the text
+
   \sa setColor(), color(), PaintAttributes
 */
 QColor QwtText::usedColor( const QColor &defaultColor ) const
@@ -352,31 +359,51 @@
 }
 
 /*!
+  Set the radius for the corners of the border frame
+
+  \param radius Radius of a rounded corner
+  \sa borderRadius(), setBorderPen(), setBackgroundBrush()
+*/
+void QwtText::setBorderRadius( double radius )
+{
+    d_data->borderRadius = qMax( 0.0, radius );
+}
+
+/*!
+  \return Radius for the corners of the border frame
+  \sa setBorderRadius(), borderPen(), backgroundBrush()
+*/
+double QwtText::borderRadius() const
+{
+    return d_data->borderRadius;
+}
+
+/*!
    Set the background pen
 
    \param pen Background pen
-   \sa backgroundPen(), setBackgroundBrush()
+   \sa borderPen(), setBackgroundBrush()
 */
-void QwtText::setBackgroundPen( const QPen &pen )
+void QwtText::setBorderPen( const QPen &pen )
 {
-    d_data->backgroundPen = pen;
+    d_data->borderPen = pen;
     setPaintAttribute( PaintBackground );
 }
 
 /*!
    \return Background pen
-   \sa setBackgroundPen(), backgroundBrush()
+   \sa setBorderPen(), backgroundBrush()
 */
-QPen QwtText::backgroundPen() const
+QPen QwtText::borderPen() const
 {
-    return d_data->backgroundPen;
+    return d_data->borderPen;
 }
 
 /*!
    Set the background brush
 
    \param brush Background brush
-   \sa backgroundBrush(), setBackgroundPen()
+   \sa backgroundBrush(), setBorderPen()
 */
 void QwtText::setBackgroundBrush( const QBrush &brush )
 {
@@ -386,7 +413,7 @@
 
 /*!
    \return Background brush
-   \sa setBackgroundBrush(), backgroundPen()
+   \sa setBackgroundBrush(), borderPen()
 */
 QBrush QwtText::backgroundBrush() const
 {
@@ -400,7 +427,7 @@
    \param on On/Off
 
    \note Used by setFont(), setColor(),
-         setBackgroundPen() and setBackgroundBrush()
+         setBorderPen() and setBackgroundBrush()
    \sa testPaintAttribute()
 */
 void QwtText::setPaintAttribute( PaintAttribute attribute, bool on )
@@ -542,13 +569,25 @@
 {
     if ( d_data->paintAttributes & PaintBackground )
     {
-        if ( d_data->backgroundPen != Qt::NoPen ||
+        if ( d_data->borderPen != Qt::NoPen ||
             d_data->backgroundBrush != Qt::NoBrush )
         {
             painter->save();
-            painter->setPen( d_data->backgroundPen );
+
+            painter->setPen( d_data->borderPen );
             painter->setBrush( d_data->backgroundBrush );
-            QwtPainter::drawRect( painter, rect );
+
+            if ( d_data->borderRadius == 0 )
+            {
+                QwtPainter::drawRect( painter, rect );
+            }
+            else
+            {
+                painter->setRenderHint( QPainter::Antialiasing, true );
+                painter->drawRoundedRect( rect,
+                    d_data->borderRadius, d_data->borderRadius );
+            }
+
             painter->restore();
         }
     }
@@ -595,13 +634,15 @@
 
    In case of QwtText::AutoText the first text engine
    (beside QwtPlainTextEngine) is returned, where QwtTextEngine::mightRender
-   returns true. If there is none QwtPlainTextEngine is returnd.
+   returns true. If there is none QwtPlainTextEngine is returned.
 
    If no text engine is registered for the format QwtPlainTextEngine
    is returnd.
 
    \param text Text, needed in case of AutoText
    \param format Text format
+
+   \return Corresponding text engine
 */
 const QwtTextEngine *QwtText::textEngine( const QString &text,
     QwtText::TextFormat format )
Index: qwt_slider.h
===================================================================
--- qwt_slider.h	(revision 382)
+++ qwt_slider.h	(working copy)
@@ -11,7 +11,6 @@
 #define QWT_SLIDER_H
 
 #include "qwt_global.h"
-#include "qwt_abstract_scale.h"
 #include "qwt_abstract_slider.h"
 
 class QwtScaleDraw;
@@ -20,24 +19,28 @@
   \brief The Slider Widget
 
   QwtSlider is a slider widget which operates on an interval
-  of type double. QwtSlider supports different layouts as
-  well as a scale.
+  of type double. Its position is related to a scale showing
+  the current value.
 
-  \image html sliders.png
+  The slider can be customized by having a through, a groove - or both.
 
-  \sa QwtAbstractSlider and QwtAbstractScale for the descriptions
-      of the inherited members.
+  \image html sliders.png
 */
 
-class QWT_EXPORT QwtSlider : public QwtAbstractSlider, public QwtAbstractScale
+class QWT_EXPORT QwtSlider: public QwtAbstractSlider
 {
     Q_OBJECT
-    Q_ENUMS( ScalePos )
-    Q_ENUMS( BackgroundStyle )
-    Q_PROPERTY( ScalePos scalePosition READ scalePosition
+
+    Q_ENUMS( ScalePosition BackgroundStyle )
+
+    Q_PROPERTY( Qt::Orientation orientation
+                READ orientation WRITE setOrientation )
+    Q_PROPERTY( ScalePosition scalePosition READ scalePosition
         WRITE setScalePosition )
-    Q_PROPERTY( BackgroundStyles backgroundStyle 
-        READ backgroundStyle WRITE setBackgroundStyle )
+
+    Q_PROPERTY( bool trough READ hasTrough WRITE setTrough )
+    Q_PROPERTY( bool groove READ hasGroove WRITE setGroove )
+
     Q_PROPERTY( QSize handleSize READ handleSize WRITE setHandleSize )
     Q_PROPERTY( int borderWidth READ borderWidth WRITE setBorderWidth )
     Q_PROPERTY( int spacing READ spacing WRITE setSpacing )
@@ -45,63 +48,38 @@
 public:
 
     /*!
-      Scale position. QwtSlider tries to enforce valid combinations of its
-      orientation and scale position:
-
-      - Qt::Horizonal combines with NoScale, TopScale and BottomScale
-      - Qt::Vertical combines with NoScale, LeftScale and RightScale
-
-      \sa QwtSlider()
+      Position of the scale
+      \sa QwtSlider(), setScalePosition(), setOrientation()
      */
-    enum ScalePos
+    enum ScalePosition
     {
         //! The slider has no scale
         NoScale,
 
-        //! The scale is left of the slider
-        LeftScale,
+        //! The scale is right of a vertical or below a horizontal slider
+        LeadingScale,
 
-        //! The scale is right of the slider
-        RightScale,
-
-        //! The scale is above of the slider
-        TopScale,
-
-        //! The scale is below of the slider
-        BottomScale
+        //! The scale is left of a vertical or above a horizontal slider
+        TrailingScale
     };
 
-    /*!
-      Background style.
-      \sa QwtSlider()
-     */
-    enum BackgroundStyle
-    {
-        //! Trough background
-        Trough = 0x01,
+    explicit QwtSlider( QWidget *parent = NULL );
+    explicit QwtSlider( Qt::Orientation, QWidget *parent = NULL );
 
-        //! Groove
-        Groove = 0x02,
-    };
-
-    //! Background styles
-    typedef QFlags<BackgroundStyle> BackgroundStyles;
-
-    explicit QwtSlider( QWidget *parent,
-        Qt::Orientation = Qt::Horizontal,
-        ScalePos = NoScale, BackgroundStyles = Trough );
-
     virtual ~QwtSlider();
 
-    virtual void setOrientation( Qt::Orientation );
+    void setOrientation( Qt::Orientation );
+    Qt::Orientation orientation() const;
 
-    void setBackgroundStyle( BackgroundStyles );
-    BackgroundStyles backgroundStyle() const;
+    void setScalePosition( ScalePosition );
+    ScalePosition scalePosition() const;
 
-    void setScalePosition( ScalePos s );
-    ScalePos scalePosition() const;
+    void setTrough( bool );
+    bool hasTrough() const;
 
-    void setHandleSize( int width, int height );
+    void setGroove( bool );
+    bool hasGroove() const;
+
     void setHandleSize( const QSize & );
     QSize handleSize() const;
 
@@ -117,34 +95,36 @@
     void setScaleDraw( QwtScaleDraw * );
     const QwtScaleDraw *scaleDraw() const;
 
+    void setUpdateInterval( int );
+    int updateInterval() const;
+
 protected:
-    virtual double getValue( const QPoint &p );
-    virtual void getScrollMode( const QPoint &p,
-        QwtAbstractSlider::ScrollMode &, int &direction ) const;
+    virtual double scrolledTo( const QPoint & ) const;
+    virtual bool isScrollPosition( const QPoint & ) const;
 
     virtual void drawSlider ( QPainter *, const QRect & ) const;
     virtual void drawHandle( QPainter *, const QRect &, int pos ) const;
 
+    virtual void mousePressEvent( QMouseEvent * );
+    virtual void mouseReleaseEvent( QMouseEvent * );
     virtual void resizeEvent( QResizeEvent * );
     virtual void paintEvent ( QPaintEvent * );
     virtual void changeEvent( QEvent * );
+    virtual void timerEvent( QTimerEvent * );
 
-    virtual void valueChange();
-    virtual void rangeChange();
     virtual void scaleChange();
 
-    int transform( double v ) const;
+    QRect sliderRect() const;
+    QRect handleRect() const;
 
+private:
     QwtScaleDraw *scaleDraw();
 
-private:
     void layoutSlider( bool );
-    void initSlider( Qt::Orientation, ScalePos, BackgroundStyles );
+    void initSlider( Qt::Orientation );
 
     class PrivateData;
     PrivateData *d_data;
 };
 
-Q_DECLARE_OPERATORS_FOR_FLAGS( QwtSlider::BackgroundStyles )
-
 #endif
Index: qwt_abstract_scale_draw.cpp
===================================================================
--- qwt_abstract_scale_draw.cpp	(revision 382)
+++ qwt_abstract_scale_draw.cpp	(working copy)
@@ -37,7 +37,7 @@
     ScaleComponents components;
 
     QwtScaleMap map;
-    QwtScaleDiv scldiv;
+    QwtScaleDiv scaleDiv;
 
     double spacing;
     double tickLength[QwtScaleDiv::NTickTypes];
@@ -85,6 +85,9 @@
 
 /*!
   Check if a component is enabled
+
+  \param component Component type
+  \return true, when component is enabled
   \sa enableComponent()
 */
 bool QwtAbstractScaleDraw::hasComponent( ScaleComponent component ) const
@@ -94,12 +97,12 @@
 
 /*!
   Change the scale division
-  \param sd New scale division
+  \param scaleDiv New scale division
 */
-void QwtAbstractScaleDraw::setScaleDiv( const QwtScaleDiv &sd )
+void QwtAbstractScaleDraw::setScaleDiv( const QwtScaleDiv &scaleDiv )
 {
-    d_data->scldiv = sd;
-    d_data->map.setScaleInterval( sd.lowerBound(), sd.upperBound() );
+    d_data->scaleDiv = scaleDiv;
+    d_data->map.setScaleInterval( scaleDiv.lowerBound(), scaleDiv.upperBound() );
     d_data->labelCache.clear();
 }
 
@@ -108,7 +111,7 @@
   \param transformation New scale transformation
 */
 void QwtAbstractScaleDraw::setTransformation(
-    QwtScaleTransformation *transformation )
+    QwtTransform *transformation )
 {
     d_data->map.setTransformation( transformation );
 }
@@ -128,7 +131,7 @@
 //! \return scale division
 const QwtScaleDiv& QwtAbstractScaleDraw::scaleDiv() const
 {
-    return d_data->scldiv;
+    return d_data->scaleDiv;
 }
 
 /*!
@@ -178,13 +181,13 @@
         painter->setPen( palette.color( QPalette::Text ) ); // ignore pen style
 
         const QList<double> &majorTicks =
-            d_data->scldiv.ticks( QwtScaleDiv::MajorTick );
+            d_data->scaleDiv.ticks( QwtScaleDiv::MajorTick );
 
         for ( int i = 0; i < majorTicks.count(); i++ )
         {
             const double v = majorTicks[i];
-            if ( d_data->scldiv.contains( v ) )
-                drawLabel( painter, majorTicks[i] );
+            if ( d_data->scaleDiv.contains( v ) )
+                drawLabel( painter, v );
         }
 
         painter->restore();
@@ -203,11 +206,11 @@
         for ( int tickType = QwtScaleDiv::MinorTick;
             tickType < QwtScaleDiv::NTickTypes; tickType++ )
         {
-            const QList<double> &ticks = d_data->scldiv.ticks( tickType );
+            const QList<double> &ticks = d_data->scaleDiv.ticks( tickType );
             for ( int i = 0; i < ticks.count(); i++ )
             {
                 const double v = ticks[i];
-                if ( d_data->scldiv.contains( v ) )
+                if ( d_data->scaleDiv.contains( v ) )
                     drawTick( painter, v, d_data->tickLength[tickType] );
             }
         }
@@ -257,6 +260,7 @@
   The spacing is the distance between ticks and labels.
   The default spacing is 4 pixels.
 
+  \return Spacing
   \sa setSpacing()
 */
 double QwtAbstractScaleDraw::spacing() const
@@ -267,7 +271,7 @@
 /*!
   \brief Set a minimum for the extent
 
-  The extent is calculated from the coomponents of the
+  The extent is calculated from the components of the
   scale draw. In situations, where the labels are
   changing and the layout depends on the extent (f.e scrolling
   a scale), setting an upper limit as minimum extent will
@@ -287,6 +291,7 @@
 
 /*!
   Get the minimum extent
+  \return Minimum extent
   \sa extent(), setMinimumExtent()
 */
 double QwtAbstractScaleDraw::minimumExtent() const
@@ -322,8 +327,7 @@
 }
 
 /*!
-    Return the length of the ticks
-
+    \return Length of the ticks
     \sa setTickLength(), maxTickLength()
 */
 double QwtAbstractScaleDraw::tickLength( QwtScaleDiv::TickType tickType ) const
@@ -356,7 +360,7 @@
   \brief Convert a value into its representing label
 
   The value is converted to a plain text using
-  QLocale::system().toString(value).
+  QLocale().toString(value).
   This method is often overloaded by applications to have individual
   labels.
 
@@ -365,6 +369,9 @@
 */
 QwtText QwtAbstractScaleDraw::label( double value ) const
 {
+    if ( qFuzzyCompare( value + 1.0, 1.0 ) )
+        value = 0.0; 
+
     return QLocale().toString( value );
 }
 
@@ -400,7 +407,7 @@
 }
 
 /*!
-   Invalidate the cache used by QwtAbstractScaleDraw::tickLabel
+   Invalidate the cache used by tickLabel()
 
    The cache is invalidated, when a new QwtScaleDiv is set. If
    the labels need to be changed. while the same QwtScaleDiv is set,
Index: qwt_scale_map.h
===================================================================
--- qwt_scale_map.h	(revision 382)
+++ qwt_scale_map.h	(working copy)
@@ -11,8 +11,9 @@
 #define QWT_SCALE_MAP_H
 
 #include "qwt_global.h"
-#include "qwt_math.h"
+#include "qwt_transform.h"
 #include <qrect.h>
+
 #ifndef QT_NO_DEBUG_STREAM
 #include <qdebug.h>
 #endif
@@ -20,54 +21,6 @@
 class QRectF;
 
 /*!
-   \brief A transformation between coordinate systems
-
-   QwtScaleTransformation offers transformations from the coordinate system
-   of a scale into the linear coordinate system of a paint device 
-   and vice versa.
-*/
-class QWT_EXPORT QwtScaleTransformation
-{
-public:
-    //! Transformation type
-    enum Type
-    {
-        //! Transformation between 2 linear scales
-        Linear,
-
-        //! Transformation between a linear and a logarithmic ( base 10 ) scale
-        Log10,
-
-        //! Any other type of transformation
-        Other
-    };
-
-    QwtScaleTransformation( Type type );
-    virtual ~QwtScaleTransformation();
-
-    virtual double xForm( double s, double s1, double s2,
-        double p1, double p2 ) const;
-    virtual double invXForm( double p, double p1, double p2,
-        double s1, double s2 ) const;
-
-    Type type() const;
-
-    virtual QwtScaleTransformation *copy() const;
-
-private:
-    QwtScaleTransformation();
-    QwtScaleTransformation &operator=( const QwtScaleTransformation );
-
-    const Type d_type;
-};
-
-//! \return Transformation type
-inline QwtScaleTransformation::Type QwtScaleTransformation::type() const
-{
-    return d_type;
-}
-
-/*!
    \brief A scale map
 
    QwtScaleMap offers transformations from the coordinate system
@@ -84,8 +37,8 @@
 
     QwtScaleMap &operator=( const QwtScaleMap & );
 
-    void setTransformation( QwtScaleTransformation * );
-    const QwtScaleTransformation *transformation() const;
+    void setTransformation( QwtTransform * );
+    const QwtTransform *transformation() const;
 
     void setPaintInterval( double p1, double p2 );
     void setScaleInterval( double s1, double s2 );
@@ -102,9 +55,6 @@
     double pDist() const;
     double sDist() const;
 
-    QT_STATIC_CONST double LogMin;
-    QT_STATIC_CONST double LogMax;
-
     static QRectF transform( const QwtScaleMap &,
         const QwtScaleMap &, const QRectF & );
     static QRectF invTransform( const QwtScaleMap &,
@@ -118,15 +68,15 @@
     bool isInverting() const;
 
 private:
-    void newFactor();
+    void updateFactor();
 
     double d_s1, d_s2;     // scale interval boundaries
     double d_p1, d_p2;     // paint device interval boundaries
 
     double d_cnv;       // conversion factor
-    double d_cnvInv;    // conversion factor
+    double d_ts1;
 
-    QwtScaleTransformation *d_transformation;
+    QwtTransform *d_transform;
 };
 
 /*!
@@ -182,18 +132,16 @@
   related to the interval of the paint device
 
   \param s Value relative to the coordinates of the scale
+  \return Transformed value
+
+  \sa invTransform()
 */
 inline double QwtScaleMap::transform( double s ) const
 {
-    // try to inline code from QwtScaleTransformation
+    if ( d_transform )
+        s = d_transform->transform( s );
 
-    if ( d_transformation->type() == QwtScaleTransformation::Linear )
-        return d_p1 + ( s - d_s1 ) * d_cnv;
-
-    if ( d_transformation->type() == QwtScaleTransformation::Log10 )
-        return d_p1 + log( s / d_s1 ) * d_cnv;
-
-    return d_transformation->xForm( s, d_s1, d_s2, d_p1, d_p2 );
+    return d_p1 + ( s - d_ts1 ) * d_cnv;
 }
 
 /*!
@@ -201,21 +149,17 @@
   interval of the scale.
 
   \param p Value relative to the coordinates of the paint device
+  \return Transformed value
+
   \sa transform()
 */
 inline double QwtScaleMap::invTransform( double p ) const
 {
-    if ( d_transformation->type() == QwtScaleTransformation::Linear )
-        return d_s1 + ( p - d_p1 ) * d_cnvInv;
+    double s = d_ts1 + ( p - d_p1 ) / d_cnv;
+    if ( d_transform )
+        s = d_transform->invTransform( s );
 
-    if ( d_transformation->type() == QwtScaleTransformation::Log10 )
-#if QT_VERSION < 0x040601
-        return ::exp( ( p - d_p1 ) / d_cnv ) * d_s1;
-#else
-        return qExp( ( p - d_p1 ) / d_cnv ) * d_s1;
-#endif
-
-    return d_transformation->invXForm( p, d_p1, d_p2, d_s1, d_s2 );
+    return s;
 }
 
 //! \return True, when ( p1() < p2() ) != ( s1() < s2() )
Index: qwt_plot_histogram.cpp
===================================================================
--- qwt_plot_histogram.cpp	(revision 382)
+++ qwt_plot_histogram.cpp	(working copy)
@@ -60,7 +60,6 @@
   Constructor
   \param title Title of the histogram.
 */
-
 QwtPlotHistogram::QwtPlotHistogram( const QwtText &title ):
     QwtPlotSeriesItem( title )
 {
@@ -113,7 +112,7 @@
 }
 
 /*!
-    Return the current style
+    \return Style of the histogram
     \sa HistogramStyle, setStyle()
 */
 QwtPlotHistogram::HistogramStyle QwtPlotHistogram::style() const
@@ -122,6 +121,24 @@
 }
 
 /*!
+  Build and assign a pen
+    
+  In Qt5 the default pen width is 1.0 ( 0.0 in Qt4 ) what makes it
+  non cosmetic ( see QPen::isCosmetic() ). This method has been introduced
+  to hide this incompatibility.
+    
+  \param color Pen color
+  \param width Pen width
+  \param style Pen style
+    
+  \sa pen(), brush()
+ */
+void QwtPlotHistogram::setPen( const QColor &color, qreal width, Qt::PenStyle style )
+{   
+    setPen( QPen( color, width, style ) );
+}   
+
+/*!
   Assign a pen, that is used in a style() depending way.
 
   \param pen New pen
@@ -184,7 +201,7 @@
   \sa style(), symbol(), drawColumn(), pen(), brush()
 
   \note In applications, where different intervals need to be displayed
-        in a different way ( f.e different colors or even using differnt symbols)
+        in a different way ( f.e different colors or even using different symbols)
         it is recommended to overload drawColumn().
 */
 void QwtPlotHistogram::setSymbol( const QwtColumnSymbol *symbol )
@@ -285,12 +302,28 @@
 }
 
 /*!
+  Assign a series of samples
+    
+  setSamples() is just a wrapper for setData() without any additional
+  value - beside that it is easier to find for the developer.
+    
+  \param data Data
+  \warning The item takes ownership of the data object, deleting
+           it when its not used anymore.
+*/
+void QwtPlotHistogram::setSamples( 
+    QwtSeriesData<QwtIntervalSample> *data )
+{
+    setData( data );
+}
+
+/*!
   Draw a subset of the histogram samples
 
   \param painter Painter
   \param xMap Maps x-values into pixel coordinates.
   \param yMap Maps y-values into pixel coordinates.
-  \param canvasRect Contents rect of the canvas
+  \param canvasRect Contents rectangle of the canvas
   \param from Index of the first sample to be painted
   \param to Index of the last sample to be painted. If to < 0 the
          series will be painted to its last sample.
@@ -539,8 +572,11 @@
             polygon += QPointF( baseLine, polygon.last().y() );
             polygon += QPointF( baseLine, polygon.first().y() );
         }
+
         QwtPainter::drawPolygon( painter, polygon );
-        polygon.resize( polygon.size() - 2 );
+
+        polygon.pop_back();
+        polygon.pop_back();
     }
     if ( d_data->pen.style() != Qt::NoPen )
     {
@@ -608,7 +644,7 @@
   \param sample Sample to be displayed
 
   \note In applications, where different intervals need to be displayed
-        in a different way ( f.e different colors or even using differnt symbols)
+        in a different way ( f.e different colors or even using different symbols)
         it is recommended to overload drawColumn().
 */
 void QwtPlotHistogram::drawColumn( QPainter *painter,
@@ -637,13 +673,14 @@
 }
 
 /*!
-   A plain rectangle without pen using the brush()
+  A plain rectangle without pen using the brush()
 
-   \param index Index of the legend entry 
+  \param index Index of the legend entry 
                 ( ignored as there is only one )
-   \param size Icon size
+  \param size Icon size
+  \return A graphic displaying the icon
     
-   \sa QwtPlotItem::setLegendIconSize(), QwtPlotItem::legendData()
+  \sa QwtPlotItem::setLegendIconSize(), QwtPlotItem::legendData()
 */
 QwtGraphic QwtPlotHistogram::legendIcon( int index,
     const QSizeF &size ) const
Index: qwt_plot_intervalcurve.h
===================================================================
--- qwt_plot_intervalcurve.h	(revision 382)
+++ qwt_plot_intervalcurve.h	(working copy)
@@ -22,7 +22,7 @@
 
   The representation depends on the style() and an optional symbol()
   that is displayed for each interval. QwtPlotIntervalCurve might be used
-  to disply error bars or the area between 2 curves.
+  to display error bars or the area between 2 curves.
 */
 class QWT_EXPORT QwtPlotIntervalCurve: 
     public QwtPlotSeriesItem, public QwtSeriesStore<QwtIntervalSample>
@@ -87,7 +87,9 @@
     bool testPaintAttribute( PaintAttribute ) const;
 
     void setSamples( const QVector<QwtIntervalSample> & );
+    void setSamples( QwtSeriesData<QwtIntervalSample> * );
 
+    void setPen( const QColor &, qreal width = 0.0, Qt::PenStyle = Qt::SolidLine );
     void setPen( const QPen & );
     const QPen &pen() const;
 
Index: qwt_scale_div.h
===================================================================
--- qwt_scale_div.h	(revision 382)
+++ qwt_scale_div.h	(working copy)
@@ -13,6 +13,7 @@
 #include "qwt_global.h"
 #include "qwt_interval.h"
 #include <qlist.h>
+
 #ifndef QT_NO_DEBUG_STREAM
 #include <qdebug.h>
 #endif
@@ -20,12 +21,16 @@
 /*!
   \brief A class representing a scale division
 
-  A scale division consists of its limits and 3 list
-  of tick values qualified as major, medium and minor ticks.
+  A Qwt scale is defined by its boundaries and 3 list
+  for the positions of the major, medium and minor ticks.
 
-  In most cases scale divisions are calculated by a QwtScaleEngine.
+  The upperLimit() might be smaller than the lowerLimit()
+  to indicate inverted scales.
 
-  \sa subDivideInto(), subDivide()
+  Scale divisions can be calculated from a QwtScaleEngine.
+
+  \sa QwtScaleEngine::divideScale(), QwtPlot::setAxisScaleDiv(),
+      QwtAbstractSlider::setScaleDiv()
 */
 
 class QWT_EXPORT QwtScaleDiv
@@ -50,32 +55,46 @@
         NTickTypes
     };
 
-    explicit QwtScaleDiv();
+    explicit QwtScaleDiv( double lowerBound = 0.0, 
+        double upperBound = 0.0 );
+
     explicit QwtScaleDiv( const QwtInterval &, QList<double>[NTickTypes] );
-    explicit QwtScaleDiv( 
-        double lowerBound, double upperBound, QList<double>[NTickTypes] );
 
-    bool operator==( const QwtScaleDiv &s ) const;
-    bool operator!=( const QwtScaleDiv &s ) const;
+    explicit QwtScaleDiv( double lowerBound, double upperBound,
+        QList<double>[NTickTypes] );
 
+    explicit QwtScaleDiv( double lowerBound, double upperBound, 
+        const QList<double> &minorTicks, const QList<double> &mediumTicks,
+        const QList<double> &majorTicks );
+
+    bool operator==( const QwtScaleDiv & ) const;
+    bool operator!=( const QwtScaleDiv & ) const;
+
     void setInterval( double lowerBound, double upperBound );
     void setInterval( const QwtInterval & );
     QwtInterval interval() const;
 
+    void setLowerBound( double );
     double lowerBound() const;
+
+    void setUpperBound( double );
     double upperBound() const;
+
     double range() const;
 
-    bool contains( double v ) const;
+    bool contains( double value ) const;
 
-    void setTicks( int type, const QList<double> & );
-    const QList<double> &ticks( int type ) const;
+    void setTicks( int tickType, const QList<double> & );
+    QList<double> ticks( int tickType ) const;
 
     bool isEmpty() const;
     bool isIncreasing() const;
 
     void invert();
+    QwtScaleDiv inverted() const;
 
+    QwtScaleDiv bounded( double lowerBound, double upperBound ) const;
+
 private:
     double d_lowerBound;
     double d_upperBound;
@@ -88,49 +107,4 @@
 QWT_EXPORT QDebug operator<<( QDebug, const QwtScaleDiv & );
 #endif
 
-/*!
-   Change the interval
-   \param lowerBound lower bound
-   \param upperBound upper bound
-*/
-inline void QwtScaleDiv::setInterval( double lowerBound, double upperBound )
-{
-    d_lowerBound = lowerBound;
-    d_upperBound = upperBound;
-}
-
-/*!
-  \return lowerBound -> upperBound
-*/
-inline QwtInterval QwtScaleDiv::interval() const
-{
-    return QwtInterval( d_lowerBound, d_upperBound );
-}
-
-/*!
-  \return lower bound
-  \sa upperBound()
-*/
-inline double QwtScaleDiv::lowerBound() const
-{
-    return d_lowerBound;
-}
-
-/*!
-  \return upper bound
-  \sa lowerBound()
-*/
-inline double QwtScaleDiv::upperBound() const
-{
-    return d_upperBound;
-}
-
-/*!
-  \return upperBound() - lowerBound()
-*/
-inline double QwtScaleDiv::range() const
-{
-    return d_upperBound - d_lowerBound;
-}
-
 #endif
Index: qwt_plot_xml.cpp
===================================================================
--- qwt_plot_xml.cpp	(revision 382)
+++ qwt_plot_xml.cpp	(working copy)
@@ -28,6 +28,7 @@
   This method is intended for manipulating the plot widget
   from a specific editor in the Qwt designer plugin.
 
+  \return QString::null
   \warning The plot editor has never been implemented.
 */
 QString QwtPlot::grabProperties() const
Index: qwt_plot_multi_barchart.cpp
===================================================================
--- qwt_plot_multi_barchart.cpp	(revision 382)
+++ qwt_plot_multi_barchart.cpp	(working copy)
@@ -36,32 +36,37 @@
     PrivateData():
         style( QwtPlotMultiBarChart::Grouped )
     {
-        colorTable << Qt::red << Qt::blue << Qt::darkGreen << Qt::yellow
-            << Qt::darkCyan << Qt::darkMagenta << Qt::darkYellow
-            << Qt::darkBlue << Qt::green << Qt::magenta;
     }
 
     QwtPlotMultiBarChart::ChartStyle style;
-    QList<QBrush> colorTable;
     QList<QwtText> barTitles;
     QMap<int, QwtColumnSymbol *> symbolMap;
 };
 
+/*!
+  Constructor
+  \param title Title of the chart
+*/
 QwtPlotMultiBarChart::QwtPlotMultiBarChart( const QwtText &title ):
-    QwtPlotBarItem( title )
+    QwtPlotAbstractBarChart( title )
 {
     init();
 }
 
+/*!
+  Constructor
+  \param title Title of the chart
+*/
 QwtPlotMultiBarChart::QwtPlotMultiBarChart( const QString &title ):
-    QwtPlotBarItem( QwtText( title ) )
+    QwtPlotAbstractBarChart( QwtText( title ) )
 {
     init();
 }
 
+//! Destructor
 QwtPlotMultiBarChart::~QwtPlotMultiBarChart()
 {
-    clearSymbols();
+    resetSymbolMap();
     delete d_data;
 }
 
@@ -77,12 +82,20 @@
     return QwtPlotItem::Rtti_PlotMultiBarChart;
 }
 
+/*!
+  Initialize data with an array of samples.
+  \param samples Vector of points
+*/
 void QwtPlotMultiBarChart::setSamples(
     const QVector<QwtSetSample> &samples )
 {
     setData( new QwtSetSeriesData( samples ) );
 }
 
+/*!
+  Initialize data with an array of samples.
+  \param samples Vector of points
+*/
 void QwtPlotMultiBarChart::setSamples(
     const QVector< QVector<double> > &samples )
 {
@@ -93,42 +106,69 @@
     setData( new QwtSetSeriesData( s ) );
 }
 
-void QwtPlotMultiBarChart::setTitles( const QList<QwtText> &titles )
+/*!
+  Assign a series of samples
+    
+  setSamples() is just a wrapper for setData() without any additional
+  value - beside that it is easier to find for the developer.
+    
+  \param data Data
+  \warning The item takes ownership of the data object, deleting
+           it when its not used anymore.
+*/  
+void QwtPlotMultiBarChart::setSamples( 
+    QwtSeriesData<QwtSetSample> *data )
+{       
+    setData( data );
+}       
+
+/*!
+  \brief Set the titles for the bars
+
+  The titles are used for the legend.
+
+  \param titles Bar titles
+
+  \sa barTitles(), legendData()
+ */
+void QwtPlotMultiBarChart::setBarTitles( const QList<QwtText> &titles )
 {
     d_data->barTitles = titles;
     itemChanged();
 }
 
-QList<QwtText> QwtPlotMultiBarChart::titles() const
+/*! 
+  \return Bar titles
+  \sa setBarTitles(), legendData()
+ */
+QList<QwtText> QwtPlotMultiBarChart::barTitles() const
 {
     return d_data->barTitles;
 }
 
-void QwtPlotMultiBarChart::setColorTable( const QList<QBrush> &colorTable )
-{
-    d_data->colorTable = colorTable;
+/*!
+  \brief Add a symbol to the symbol map
 
-    legendChanged();
-    itemChanged();
-}
+  Assign a default symbol for drawing the bar representing all values
+  with the same index in a set.
 
-QList<QBrush> QwtPlotMultiBarChart::colorTable() const
-{
-    return d_data->colorTable;
-}
+  \param valueIndex Index of a value in a set
+  \param symbol Symbol used for drawing a bar
 
-void QwtPlotMultiBarChart::setSymbol( int barIndex, QwtColumnSymbol *symbol )
+  \sa symbol(), resetSymbolMap(), specialSymbol()
+*/
+void QwtPlotMultiBarChart::setSymbol( int valueIndex, QwtColumnSymbol *symbol )
 {
-    if ( barIndex < 0 )
+    if ( valueIndex < 0 )
         return;
 
     QMap<int, QwtColumnSymbol *>::iterator it = 
-        d_data->symbolMap.find(barIndex);
+        d_data->symbolMap.find(valueIndex);
     if ( it == d_data->symbolMap.end() )
     {
         if ( symbol != NULL )
         {
-            d_data->symbolMap.insert( barIndex, symbol );
+            d_data->symbolMap.insert( valueIndex, symbol );
 
             legendChanged();
             itemChanged();
@@ -142,7 +182,7 @@
 
             if ( symbol == NULL )
             {
-                d_data->symbolMap.remove( barIndex );
+                d_data->symbolMap.remove( valueIndex );
             }
             else
             {
@@ -155,23 +195,42 @@
     }
 }
 
-const QwtColumnSymbol *QwtPlotMultiBarChart::symbol( int barIndex ) const
+/*!
+  Find a symbol in the symbol map
+
+  \param valueIndex Index of a value in a set
+  \return The symbol, that had been set by setSymbol() or NULL.
+
+  \sa setSymbol(), specialSymbol(), drawBar()
+*/
+const QwtColumnSymbol *QwtPlotMultiBarChart::symbol( int valueIndex ) const
 {
     QMap<int, QwtColumnSymbol *>::const_iterator it =
-        d_data->symbolMap.find(barIndex);
+        d_data->symbolMap.find( valueIndex );
 
     return ( it == d_data->symbolMap.end() ) ? NULL : it.value();
 }
 
-QwtColumnSymbol *QwtPlotMultiBarChart::symbol( int barIndex ) 
+/*!
+  Find a symbol in the symbol map
+
+  \param valueIndex Index of a value in a set
+  \return The symbol, that had been set by setSymbol() or NULL.
+
+  \sa setSymbol(), specialSymbol(), drawBar()
+*/
+QwtColumnSymbol *QwtPlotMultiBarChart::symbol( int valueIndex ) 
 {
     QMap<int, QwtColumnSymbol *>::iterator it =
-        d_data->symbolMap.find(barIndex);
+        d_data->symbolMap.find( valueIndex );
 
     return ( it == d_data->symbolMap.end() ) ? NULL : it.value();
 }
 
-void QwtPlotMultiBarChart::clearSymbols()
+/*!
+  Remove all symbols from the symbol map
+ */
+void QwtPlotMultiBarChart::resetSymbolMap()
 {
     for ( QMap<int, QwtColumnSymbol *>::iterator it 
         = d_data->symbolMap.begin(); it != d_data->symbolMap.end(); ++it )
@@ -182,6 +241,41 @@
     d_data->symbolMap.clear();
 }
 
+/*!
+  \brief Create a symbol for special values
+
+  Usually the symbols for displaying a bar are set by setSymbols() and
+  common for all sets. By overloading specialSymbol() it is possible to
+  create a temporary symbol() for displaying a special value.
+
+  The symbol has to be created by new each time specialSymbol() is
+  called. As soon as the symbol is painted this symbol gets deleted.
+
+  When no symbol ( NULL ) is returned, the value will be displayed
+  with the standard symbol that is used for all symbols with the same 
+  valueIndex.
+
+  \param sampleIndex Index of the sample
+  \param valueIndex Index of the value in the set
+
+  \return NULL, meaning that the value is not special
+    
+ */
+QwtColumnSymbol *QwtPlotMultiBarChart::specialSymbol( 
+    int sampleIndex, int valueIndex ) const
+{
+    Q_UNUSED( sampleIndex );
+    Q_UNUSED( valueIndex );
+
+    return NULL;
+}
+
+/*!
+  Set the style of the chart
+
+  \param style Chart style
+  \sa style()
+ */
 void QwtPlotMultiBarChart::setStyle( ChartStyle style )
 {
     if ( style != d_data->style )
@@ -193,11 +287,19 @@
     }
 }
 
+/*!
+  \return Style of the chart
+  \sa setStyle()
+ */
 QwtPlotMultiBarChart::ChartStyle QwtPlotMultiBarChart::style() const
 {
     return d_data->style;
 }
 
+/*!
+  \return Bounding rectangle of all samples.
+  For an empty series the rectangle is invalid.
+*/
 QRectF QwtPlotMultiBarChart::boundingRect() const
 {
     const size_t numSamples = dataSize();
@@ -259,7 +361,7 @@
   \param painter Painter
   \param xMap Maps x-values into pixel coordinates.
   \param yMap Maps y-values into pixel coordinates.
-  \param canvasRect Contents rect of the canvas
+  \param canvasRect Contents rectangle of the canvas
   \param from Index of the first point to be painted
   \param to Index of the last point to be painted. If to < 0 the
          curve will be painted to its last point.
@@ -300,10 +402,10 @@
   \param painter Painter
   \param xMap x map
   \param yMap y map
-  \param canvasRect Contents rect of the canvas
+  \param canvasRect Contents rectangle of the canvas
   \param boundingInterval Bounding interval of sample values
-  \param from Index of the first point to be painted
-  \param to Index of the last point to be painted
+  \param index Index of the sample to be painted
+  \param sample Sample value
 
   \sa drawSeries()
 */
@@ -340,6 +442,19 @@
     }
 }
 
+/*!
+  Draw a grouped sample
+
+  \param painter Painter
+  \param xMap x map
+  \param yMap y map
+  \param canvasRect Contents rectangle of the canvas
+  \param index Index of the sample to be painted
+  \param sampleWidth Boundng width for all bars of the smaple
+  \param sample Sample 
+
+  \sa drawSeries(), sampleWidth()
+*/
 void QwtPlotMultiBarChart::drawGroupedBars( QPainter *painter,
     const QwtScaleMap &xMap, const QwtScaleMap &yMap,
     const QRectF &canvasRect, int index, double sampleWidth,
@@ -365,23 +480,17 @@
 
             const double y2 = yMap.transform( sample.set[i] );
 
-            QwtColumnRect bar;
-            bar.direction = ( y1 < y2 ) ?
+            QwtColumnRect barRect;
+            barRect.direction = ( y1 < y2 ) ?
                 QwtColumnRect::TopToBottom : QwtColumnRect::BottomToTop;
 
-            bar.hInterval = QwtInterval( x1, x2 ).normalized();
+            barRect.hInterval = QwtInterval( x1, x2 ).normalized();
             if ( i != 0 )
-                bar.hInterval.setBorderFlags( QwtInterval::ExcludeMinimum );
+                barRect.hInterval.setBorderFlags( QwtInterval::ExcludeMinimum );
 
-            bar.vInterval = QwtInterval( y1, y2 ).normalized();
+            barRect.vInterval = QwtInterval( y1, y2 ).normalized();
 
-            drawBar( painter, index, i, bar );
-
-            if ( testChartAttribute( QwtPlotBarItem::ShowLabels ) )
-            {
-                const QwtText text = label( index, i, sample );
-                drawLabel( painter, index, i, bar, text );
-            }
+            drawBar( painter, index, i, barRect );
         }
     }
     else
@@ -398,27 +507,34 @@
 
             double x2 = xMap.transform( sample.set[i] );
 
-            QwtColumnRect bar;
-            bar.direction = x1 < x2 ?
+            QwtColumnRect barRect;
+            barRect.direction = x1 < x2 ?
                 QwtColumnRect::LeftToRight : QwtColumnRect::RightToLeft;
 
-            bar.hInterval = QwtInterval( x1, x2 ).normalized();
+            barRect.hInterval = QwtInterval( x1, x2 ).normalized();
 
-            bar.vInterval = QwtInterval( y1, y2 );
+            barRect.vInterval = QwtInterval( y1, y2 );
             if ( i != 0 )
-                bar.vInterval.setBorderFlags( QwtInterval::ExcludeMinimum );
+                barRect.vInterval.setBorderFlags( QwtInterval::ExcludeMinimum );
 
-            drawBar( painter, index, i, bar );
-
-            if ( testChartAttribute( QwtPlotBarItem::ShowLabels ) )
-            {
-                const QwtText text = label( index, i, sample );
-                drawLabel( painter, index, i, bar, text );
-            }
+            drawBar( painter, index, i, barRect );
         }
     }
 }
 
+/*!
+  Draw a stacked sample
+
+  \param painter Painter
+  \param xMap x map
+  \param yMap y map
+  \param canvasRect Contents rectangle of the canvas
+  \param index Index of the sample to be painted
+  \param sampleWidth Width of the bars
+  \param sample Sample 
+
+  \sa drawSeries(), sampleWidth()
+*/
 void QwtPlotMultiBarChart::drawStackedBars( QPainter *painter,
     const QwtScaleMap &xMap, const QwtScaleMap &yMap,
     const QRectF &canvasRect, int index, 
@@ -520,61 +636,52 @@
     }
 }
 
+/*!
+  Draw a bar
+
+  \param painter Painter
+  \param sampleIndex Index of the sample - might be -1 when the
+                     bar is painted for the legend
+  \param valueIndex Index of a value in a set
+  \param rect Directed target rectangle for the bar
+
+  \sa drawSeries()
+*/
 void QwtPlotMultiBarChart::drawBar( QPainter *painter,
-    int sampleIndex, int barIndex, const QwtColumnRect &rect ) const
+    int sampleIndex, int valueIndex, const QwtColumnRect &rect ) const
 {
-    Q_UNUSED( sampleIndex );
+    const QwtColumnSymbol *specialSym = NULL;
+    if ( sampleIndex >= 0 )
+        specialSym = specialSymbol( sampleIndex, valueIndex );
 
-    const QwtColumnSymbol *sym = symbol( barIndex );
+    const QwtColumnSymbol *sym = specialSym;
+    if ( sym == NULL )
+        sym = symbol( valueIndex );
+
     if ( sym )
     {
         sym->draw( painter, rect );
     }
     else
     {
-        QBrush brush( Qt::white );
-
-        if ( d_data->colorTable.size() > 0 )
-        {
-            const int colorIndex = barIndex % d_data->colorTable.size();
-            brush = d_data->colorTable[ colorIndex ];
-        }
-
-        QPalette palette;
-        palette.setBrush( QPalette::Window, brush );
-        palette.setColor( QPalette::Dark, Qt::black );
-
+        // we build a temporary default symbol
         QwtColumnSymbol sym( QwtColumnSymbol::Box );
-        sym.setPalette( palette );
-        sym.setLineWidth( 0 );
+        sym.setLineWidth( 1 );
         sym.setFrameStyle( QwtColumnSymbol::Plain );
         sym.draw( painter, rect );
     }
-}
 
-void QwtPlotMultiBarChart::drawLabel( QPainter *painter, int sampleIndex,
-    int barIndex, const QwtColumnRect &rect, const QwtText &text ) const
-{
-    Q_UNUSED( painter );
-    Q_UNUSED( sampleIndex );
-    Q_UNUSED( barIndex );
-    Q_UNUSED( rect );
-    Q_UNUSED( text );
+    delete specialSym;
 }
 
+/*!
+  \return Information to be displayed on the legend
 
-QwtText QwtPlotMultiBarChart::label(
-    int sampleIndex, int barIndex, const QwtSetSample& sample ) const
-{
-    Q_UNUSED( sampleIndex );
+  The chart is represented by a list of entries - one for each bar title.
+  Each element contains a bar title and an icon showing its corresponding bar.
 
-    QString labelText;
-    if ( barIndex >= 0 && barIndex <= sample.set.size() )
-        labelText.setNum( sample.set[ barIndex ] );
-
-    return QwtText( labelText );
-}
-
+  \sa barTitles(), legendIcon(), legendIconSize()
+*/
 QList<QwtLegendData> QwtPlotMultiBarChart::legendData() const
 {
     QList<QwtLegendData> list;
@@ -602,6 +709,15 @@
     return list;
 }
 
+/*!
+  \return Icon for representing a bar on the legend
+
+  \param index Index of the bar
+  \param size Icon size
+  
+  \return An icon showing a bar
+  \sa drawBar(), legendData()
+ */
 QwtGraphic QwtPlotMultiBarChart::legendIcon( int index,
     const QSizeF &size ) const
 {
Index: qwt_plot_magnifier.cpp
===================================================================
--- qwt_plot_magnifier.cpp	(revision 382)
+++ qwt_plot_magnifier.cpp	(working copy)
@@ -8,7 +8,6 @@
  *****************************************************************************/
 
 #include "qwt_plot.h"
-#include "qwt_plot_canvas.h"
 #include "qwt_scale_div.h"
 #include "qwt_plot_magnifier.h"
 #include <qevent.h>
@@ -29,7 +28,7 @@
    Constructor
    \param canvas Plot canvas to be magnified
 */
-QwtPlotMagnifier::QwtPlotMagnifier( QwtPlotCanvas *canvas ):
+QwtPlotMagnifier::QwtPlotMagnifier( QWidget *canvas ):
     QwtMagnifier( canvas )
 {
     d_data = new PrivateData();
@@ -75,35 +74,35 @@
 }
 
 //! Return observed plot canvas
-QwtPlotCanvas *QwtPlotMagnifier::canvas()
+QWidget *QwtPlotMagnifier::canvas()
 {
-    return qobject_cast<QwtPlotCanvas *>( parent() );
+    return parentWidget();
 }
 
 //! Return Observed plot canvas
-const QwtPlotCanvas *QwtPlotMagnifier::canvas() const
+const QWidget *QwtPlotMagnifier::canvas() const
 {
-    return qobject_cast<const QwtPlotCanvas *>( parent() );
+    return parentWidget();
 }
 
 //! Return plot widget, containing the observed plot canvas
 QwtPlot *QwtPlotMagnifier::plot()
 {
-    QwtPlotCanvas *w = canvas();
+    QWidget *w = canvas();
     if ( w )
-        return w->plot();
+        w = w->parentWidget();
 
-    return NULL;
+    return qobject_cast<QwtPlot *>( w );
 }
 
 //! Return plot widget, containing the observed plot canvas
 const QwtPlot *QwtPlotMagnifier::plot() const
 {
-    const QwtPlotCanvas *w = canvas();
+    const QWidget *w = canvas();
     if ( w )
-        return w->plot();
+        w = w->parentWidget();
 
-    return NULL;
+    return qobject_cast<const QwtPlot *>( w );
 }
 
 /*!
@@ -112,12 +111,15 @@
 */
 void QwtPlotMagnifier::rescale( double factor )
 {
+    QwtPlot* plt = plot();
+    if ( plt == NULL )
+        return;
+
     factor = qAbs( factor );
     if ( factor == 1.0 || factor == 0.0 )
         return;
 
     bool doReplot = false;
-    QwtPlot* plt = plot();
 
     const bool autoReplot = plt->autoReplot();
     plt->setAutoReplot( false );
Index: qwt_point_mapper.h
===================================================================
--- qwt_point_mapper.h	(revision 382)
+++ qwt_point_mapper.h	(working copy)
@@ -21,9 +21,10 @@
 /*!
   \brief A helper class for translating a series of points
 
-  QwtPointMapper is aA collection of methods for translating a 
-  series of points into paint device coordinates. It is used
-  by QwtPlotCurve.
+  QwtPointMapper is a collection of methods and optimizations
+  for translating a series of points into paint device coordinates. 
+  It is used by QwtPlotCurve but might also be useful for 
+  similar plot items displaying a QwtSeriesData<QPointF>.
  */
 class QWT_EXPORT QwtPointMapper
 {
@@ -75,7 +76,8 @@
         const QwtSeriesData<QPointF> *series, int from, int to ) const;
 
     QImage toImage( const QwtScaleMap &xMap, const QwtScaleMap &yMap,
-        const QwtSeriesData<QPointF> *series, int from, int to, QRgb rgb ) const;
+        const QwtSeriesData<QPointF> *series, int from, int to, 
+        const QPen &, bool antialiased, uint numThreads ) const;
 
 private:
     class PrivateData;
Index: qwt_dyngrid_layout.h
===================================================================
--- qwt_dyngrid_layout.h	(revision 382)
+++ qwt_dyngrid_layout.h	(working copy)
@@ -21,7 +21,7 @@
 
   QwtDynGridLayout takes the space it gets, divides it up into rows and
   columns, and puts each of the widgets it manages into the correct cell(s).
-  It lays out as many number of columns as possible (limited by maxCols()).
+  It lays out as many number of columns as possible (limited by maxColumns()).
 */
 
 class QWT_EXPORT QwtDynGridLayout : public QLayout
@@ -35,11 +35,11 @@
 
     virtual void invalidate();
 
-    void setMaxCols( uint maxCols );
-    uint maxCols() const;
+    void setMaxColumns( uint maxCols );
+    uint maxColumns() const;
 
     uint numRows () const;
-    uint numCols () const;
+    uint numColumns () const;
 
     virtual void addItem( QLayoutItem * );
 
Index: qwt_clipper.h
===================================================================
--- qwt_clipper.h	(revision 382)
+++ qwt_clipper.h	(working copy)
@@ -19,7 +19,7 @@
 class QRectF;
 
 /*!
-  \brief Some clipping algos
+  \brief Some clipping algorithms
 */
 
 class QWT_EXPORT QwtClipper
Index: qwt_plot_rescaler.h
===================================================================
--- qwt_plot_rescaler.h	(revision 382)
+++ qwt_plot_rescaler.h	(working copy)
@@ -15,14 +15,13 @@
 #include "qwt_plot.h"
 #include <qobject.h>
 
-class QwtPlotCanvas;
 class QwtPlot;
 class QResizeEvent;
 
 /*!
     \brief QwtPlotRescaler takes care of fixed aspect ratios for plot scales
 
-    QwtPlotRescaler autoadjusts the axes of a QwtPlot according
+    QwtPlotRescaler auto adjusts the axes of a QwtPlot according
     to fixed aspect ratios.
 */
 
@@ -45,7 +44,7 @@
         Fixed,
 
         /*!
-          The interval of the reference axis will be shrinked/expanded,
+          The interval of the reference axis will be shrunk/expanded,
           when the geometry of the canvas changes. All other axes
           will be adjusted according to their aspect ratio.
 
@@ -77,7 +76,7 @@
         ExpandBoth
     };
 
-    explicit QwtPlotRescaler( QwtPlotCanvas *,
+    explicit QwtPlotRescaler( QWidget *canvas,
         int referenceAxis = QwtPlot::xBottom,
         RescalePolicy = Expanding );
 
@@ -103,8 +102,8 @@
     void setIntervalHint( int axis, const QwtInterval& );
     QwtInterval intervalHint( int axis ) const;
 
-    QwtPlotCanvas *canvas();
-    const QwtPlotCanvas *canvas() const;
+    QWidget *canvas();
+    const QWidget *canvas() const;
 
     QwtPlot *plot();
     const QwtPlot *plot() const;
Index: qwt_painter_command.h
===================================================================
--- qwt_painter_command.h	(revision 382)
+++ qwt_painter_command.h	(working copy)
@@ -18,19 +18,38 @@
 
 class QPainterPath;
 
+/*!
+  QwtPainterCommand represents the attributes of a paint operation
+  how it is used between QPainter and QPaintDevice
+
+  It is used by QwtGraphic to record and replay paint operations
+
+  \sa QwtGraphic::commands()
+ */
+  
 class QWT_EXPORT QwtPainterCommand
 {
 public:
+    //! Type of the paint command
     enum Type
     {
+        //! Invalid command
         Invalid = -1,
 
+        //! Draw a QPainterPath
         Path,
+
+        //! Draw a QPixmap
         Pixmap,
+
+        //! Draw a QImage
         Image,
+
+        //! QPainter state change
         State
     };
 
+    //! Attributes how to paint a QPixmap 
     struct PixmapData
     {
         QRectF rect;
@@ -38,6 +57,7 @@
         QRectF subRect;
     };
 
+    //! Attributes how to paint a QImage 
     struct ImageData
     {
         QRectF rect;
@@ -46,6 +66,7 @@
         Qt::ImageConversionFlags flags;
     };
 
+    //! Attributes of a state change
     struct StateData
     {
         QPaintEngine::DirtyFlags flags;
@@ -116,28 +137,33 @@
     };
 };
 
+//! \return Type of the command
 inline QwtPainterCommand::Type QwtPainterCommand::type() const
 {
     return d_type;
 }
 
+//! \return Painter path to be painted
 inline const QPainterPath *QwtPainterCommand::path() const
 {
     return d_path;
 }
 
+//! \return Attributes how to paint a QPixmap
 inline const QwtPainterCommand::PixmapData* 
 QwtPainterCommand::pixmapData() const
 {
     return d_pixmapData;
 }
 
+//! \return Attributes how to paint a QImage
 inline const QwtPainterCommand::ImageData * 
 QwtPainterCommand::imageData() const
 {
     return d_imageData;
 }
 
+//! \return Attributes of a state change
 inline const QwtPainterCommand::StateData * 
 QwtPainterCommand::stateData() const
 {
Index: qwt_picker_machine.h
===================================================================
--- qwt_picker_machine.h	(revision 382)
+++ qwt_picker_machine.h	(working copy)
@@ -168,6 +168,30 @@
 };
 
 /*!
+  \brief A state machine for line selections
+    
+  Pressing QwtEventPattern::MouseSelect1 selects
+  the first point, releasing it the second point.
+  Pressing QwtEventPattern::KeySelect1 also selects the
+  first point, a second press selects the second point and terminates
+  the selection.
+
+  A common use case of QwtPickerDragLineMachine are pickers for
+  distance measurements.
+  
+  \sa QwtEventPattern::MousePatternCode, QwtEventPattern::KeyPatternCode
+*/              
+                    
+class QWT_EXPORT QwtPickerDragLineMachine: public QwtPickerMachine
+{
+public:
+    QwtPickerDragLineMachine();
+
+    virtual QList<Command> transition(
+        const QwtEventPattern &, const QEvent * );
+};
+
+/*!
   \brief A state machine for polygon selections
 
   Pressing QwtEventPattern::MouseSelect1 or QwtEventPattern::KeySelect1
Index: qwt_text_engine.cpp
===================================================================
--- qwt_text_engine.cpp	(revision 382)
+++ qwt_text_engine.cpp	(working copy)
@@ -248,7 +248,7 @@
    Find the height for a given width
 
    \param font Font of the text
-   \param flags Bitwise OR of the flags used like in QPainter::drawText
+   \param flags Bitwise OR of the flags used like in QPainter::drawText()
    \param text Text to be rendered
    \param width Width
 
@@ -267,7 +267,7 @@
   Returns the size, that is needed to render text
 
   \param font Font of the text
-  \param flags Bitwise OR of the flags used like in QPainter::drawText
+  \param flags Bitwise OR of the flags used like in QPainter::drawText()
   \param text Text to be rendered
 
   \return Caluclated size
@@ -294,7 +294,7 @@
 
   \param painter Painter
   \param rect Clipping rectangle
-  \param flags Bitwise OR of the flags like in for QPainter::drawText
+  \param flags Bitwise OR of the flags like in for QPainter::drawText()
   \param text Text to be rendered
 */
 void QwtRichTextEngine::draw( QPainter *painter, const QRectF &rect,
@@ -308,7 +308,7 @@
    Wrap text into <div align=...> </div> tags according flags
 
    \param text Text
-   \param flags Bitwise OR of the flags like in for QPainter::drawText
+   \param flags Bitwise OR of the flags like in for QPainter::drawText()
 
    \return Tagged text
 */
@@ -321,7 +321,7 @@
   Test if a string can be rendered by this text engine
 
   \param text Text to be tested
-  \return QStyleSheet::mightBeRichText(text);
+  \return Qt::mightBeRichText(text);
 */
 bool QwtRichTextEngine::mightRender( const QString &text ) const
 {
Index: qwt_series_store.h
===================================================================
--- qwt_series_store.h	(revision 382)
+++ qwt_series_store.h	(working copy)
@@ -24,13 +24,14 @@
 class QwtAbstractSeriesStore
 {
 protected:
+    //! Destructor
     virtual ~QwtAbstractSeriesStore() {}
 
     //! dataChanged() indicates, that the series has been changed.
     virtual void dataChanged() = 0;
 
     /*!
-      Set a the "rect of interest" for the stored series
+      Set a the "rectangle of interest" for the stored series
       \sa QwtSeriesData<T>::setRectOfInterest()
      */
     virtual void setRectOfInterest( const QRectF & ) = 0;
@@ -56,89 +57,111 @@
 class QwtSeriesStore: public virtual QwtAbstractSeriesStore
 {
 public:
+    /*!
+      \brief Constructor
+      The store contains no series
+    */
     explicit QwtSeriesStore<T>();
+
+    //! Destructor
     ~QwtSeriesStore<T>();
 
-    void setData( QwtSeriesData<T> * );
+    /*!
+      Assign a series of samples
 
+      \param series Data
+      \warning The item takes ownership of the data object, deleting
+               it when its not used anymore.
+    */
+    void setData( QwtSeriesData<T> *series );
+
+    //! \return the the series data
     QwtSeriesData<T> *data();
+
+    //! \return the the series data
     const QwtSeriesData<T> *data() const;
 
+    /*!
+        \param index Index
+        \return Sample at position index
+    */
     T sample( int index ) const;
 
+    /*!
+      \return Number of samples of the series
+      \sa setData(), QwtSeriesData<T>::size()
+    */
     virtual size_t dataSize() const;
+
+    /*!
+      \return Bounding rectangle of the series
+              or an invalid rectangle, when no series is stored
+
+      \sa QwtSeriesData<T>::boundingRect()
+    */
     virtual QRectF dataRect() const;
 
-    virtual void setRectOfInterest( const QRectF & );
+    /*!
+      Set a the "rect of interest" for the series
 
+      \param rect Rectangle of interest
+      \sa QwtSeriesData<T>::setRectOfInterest()
+    */
+    virtual void setRectOfInterest( const QRectF &rect );
+
+    /*!
+      Replace a series without deleting the previous one
+
+      \param series New series
+      \return Previously assigned series
+     */
+    QwtSeriesData<T> *swapData( QwtSeriesData<T> *series );
+
 private:
     QwtSeriesData<T> *d_series;
 };
 
-/*!
-  \brief Constructor
-  The store contains no series
-*/
 template <typename T>
 QwtSeriesStore<T>::QwtSeriesStore():
     d_series( NULL )
 {
 }
 
-//! Destructor
 template <typename T>
 QwtSeriesStore<T>::~QwtSeriesStore()
 {
     delete d_series;
 }
 
-//! \return the the series data
 template <typename T>
 inline QwtSeriesData<T> *QwtSeriesStore<T>::data()
 {
     return d_series;
 }
 
-//! \return the the series data
 template <typename T>
 inline const QwtSeriesData<T> *QwtSeriesStore<T>::data() const
 {
     return d_series;
 }
 
-/*!
-    \param index Index
-    \return Sample at position index
-*/
 template <typename T>
 inline T QwtSeriesStore<T>::sample( int index ) const
 {
     return d_series ? d_series->sample( index ) : T();
 }
 
-/*!
-  Assign a series of samples
-
-  \param data Data
-  \warning The item takes ownership of the data object, deleting
-           it when its not used anymore.
-*/
 template <typename T>
-void QwtSeriesStore<T>::setData( QwtSeriesData<T> *data )
+void QwtSeriesStore<T>::setData( QwtSeriesData<T> *series )
 {
-    if ( d_series != data )
+    if ( d_series != series )
     {
         delete d_series;
-        d_series = data;
+        d_series = series;
         dataChanged();
     }
 }
 
-/*!
-  Return the number of samples of the series
-
-  \sa setData(), QwtSeriesData<T>::size()
-*/
 template <typename T>
 size_t QwtSeriesStore<T>::dataSize() const
 {
@@ -148,12 +171,6 @@
     return d_series->size();
 }
 
-/*!
-  Return the bounding rectangle of the series
-  or an invalid rectangle, when no series is stored
-
-  \sa QwtSeriesData<T>::boundingRect()
-*/
 template <typename T>
 QRectF QwtSeriesStore<T>::dataRect() const
 {
@@ -163,10 +180,6 @@
     return d_series->boundingRect();
 }
 
-/*!
-   Set a the "rect of interest" for the series
-   \sa QwtSeriesData<T>::setRectOfInterest()
-*/
 template <typename T>
 void QwtSeriesStore<T>::setRectOfInterest( const QRectF &rect )
 {
@@ -174,4 +187,13 @@
         d_series->setRectOfInterest( rect );
 }
 
+template <typename T>
+QwtSeriesData<T>* QwtSeriesStore<T>::swapData( QwtSeriesData<T> *series )
+{
+    QwtSeriesData<T> * swappedSeries = d_series;
+    d_series = series;
+
+    return swappedSeries;
+}
+
 #endif
Index: qwt_plot_layout.cpp
===================================================================
--- qwt_plot_layout.cpp	(revision 382)
+++ qwt_plot_layout.cpp	(working copy)
@@ -10,7 +10,6 @@
 #include "qwt_plot_layout.h"
 #include "qwt_text.h"
 #include "qwt_text_label.h"
-#include "qwt_plot_canvas.h"
 #include "qwt_scale_widget.h"
 #include "qwt_abstract_legend.h"
 #include <qscrollbar.h>
@@ -55,20 +54,19 @@
 
     struct t_canvasData
     {
-        int frameWidth;
+        int contentsMargins[ QwtPlot::axisCnt ];
+
     } canvas;
 };
 
 /*
   Extract all layout relevant data from the plot components
 */
-
 void QwtPlotLayout::LayoutData::init( const QwtPlot *plot, const QRectF &rect )
 {
     // legend
 
-    if ( plot->plotLayout()->legendPosition() != QwtPlot::ExternalLegend
-        && plot->legend() )
+    if ( plot->legend() )
     {
         legend.frameWidth = plot->legend()->frameWidth();
         legend.hScrollExtent =
@@ -80,7 +78,7 @@
 
         int w = qMin( hint.width(), qFloor( rect.width() ) );
         int h = plot->legend()->heightForWidth( w );
-        if ( h == 0 )
+        if ( h <= 0 )
             h = hint.height();
 
         if ( h > rect.height() )
@@ -167,7 +165,11 @@
 
     // canvas
 
-    canvas.frameWidth = plot->canvas()->frameWidth();
+    plot->canvas()->getContentsMargins( 
+        &canvas.contentsMargins[ QwtPlot::yLeft ], 
+        &canvas.contentsMargins[ QwtPlot::xTop ],
+        &canvas.contentsMargins[ QwtPlot::yRight ],
+        &canvas.contentsMargins[ QwtPlot::xBottom ] );
 }
 
 class QwtPlotLayout::PrivateData
@@ -272,12 +274,12 @@
   - extend beyond the axis scale ends to maximize its size,
   - align with the axis scale ends to control its size.
 
-  The axis parameter is somhow confusing as it identifies a border
+  The axisId parameter is somehow confusing as it identifies a border
   of the plot and not the axes, that are aligned. F.e when QwtPlot::yLeft
   is set, the left end of the the x-axes ( QwtPlot::xTop, QwtPlot::xBottom )
   is aligned.
 
-  \param axis Axis index
+  \param axisId Axis index
   \param on New align-canvas-to-axis-scales setting
 
   \sa setCanvasMargin(), alignCanvasToScale(), setAlignCanvasToScales()
@@ -330,8 +332,8 @@
 /*!
   \brief Specify the position of the legend
   \param pos The legend's position.
-  \param ratio Ratio between legend and the bounding rect
-               of title, footer, canvas and axes. The legend will be shrinked
+  \param ratio Ratio between legend and the bounding rectangle
+               of title, footer, canvas and axes. The legend will be shrunk
                if it would need more space than the given ratio.
                The ratio is limited to ]0.0 .. 1.0]. In case of <= 0.0
                it will be reset to the default ratio.
@@ -361,9 +363,6 @@
             d_data->legendRatio = ratio;
             d_data->legendPos = pos;
             break;
-        case QwtPlot::ExternalLegend:
-            d_data->legendRatio = ratio; // meaningless
-            d_data->legendPos = pos;
         default:
             break;
     }
@@ -394,8 +393,8 @@
 
 /*!
   Specify the relative size of the legend in the plot
-  \param ratio Ratio between legend and the bounding rect
-               of title, footer, canvas and axes. The legend will be shrinked
+  \param ratio Ratio between legend and the bounding rectangle
+               of title, footer, canvas and axes. The legend will be shrunk
                if it would need more space than the given ratio.
                The ratio is limited to ]0.0 .. 1.0]. In case of <= 0.0
                it will be reset to the default ratio.
@@ -416,38 +415,96 @@
 }
 
 /*!
+  \brief Set the geometry for the title
+
+  This method is intended to be used from derived layouts
+  overloading activate()
+
+  \sa titleRect(), activate()
+ */
+void QwtPlotLayout::setTitleRect( const QRectF &rect )
+{
+    d_data->titleRect = rect;
+}
+
+/*!
   \return Geometry for the title
   \sa activate(), invalidate()
 */
-const QRectF &QwtPlotLayout::titleRect() const
+QRectF QwtPlotLayout::titleRect() const
 {
     return d_data->titleRect;
 }
 
 /*!
+  \brief Set the geometry for the footer
+
+  This method is intended to be used from derived layouts
+  overloading activate()
+
+  \sa footerRect(), activate()
+ */
+void QwtPlotLayout::setFooterRect( const QRectF &rect )
+{
+    d_data->footerRect = rect;
+}
+
+/*!
   \return Geometry for the footer
   \sa activate(), invalidate()
 */
-const QRectF &QwtPlotLayout::footerRect() const
+QRectF QwtPlotLayout::footerRect() const
 {
     return d_data->footerRect;
 }
 
 /*!
+  \brief Set the geometry for the legend
+
+  This method is intended to be used from derived layouts
+  overloading activate()
+
+  \param rect Rectangle for the legend
+
+  \sa legendRect(), activate()
+ */
+void QwtPlotLayout::setLegendRect( const QRectF &rect )
+{
+    d_data->legendRect = rect;
+}
+
+/*!
   \return Geometry for the legend
   \sa activate(), invalidate()
 */
-const QRectF &QwtPlotLayout::legendRect() const
+QRectF QwtPlotLayout::legendRect() const
 {
     return d_data->legendRect;
 }
 
 /*!
+  \brief Set the geometry for an axis
+
+  This method is intended to be used from derived layouts
+  overloading activate()
+
   \param axis Axis index
+  \param rect Rectangle for the scale
+
+  \sa scaleRect(), activate()
+ */
+void QwtPlotLayout::setScaleRect( int axis, const QRectF &rect )
+{
+    if ( axis >= 0 && axis < QwtPlot::axisCnt )
+        d_data->scaleRect[axis] = rect;
+}
+
+/*!
+  \param axis Axis index
   \return Geometry for the scale
   \sa activate(), invalidate()
 */
-const QRectF &QwtPlotLayout::scaleRect( int axis ) const
+QRectF QwtPlotLayout::scaleRect( int axis ) const
 {
     if ( axis < 0 || axis >= QwtPlot::axisCnt )
     {
@@ -458,10 +515,23 @@
 }
 
 /*!
+  \brief Set the geometry for the canvas
+
+  This method is intended to be used from derived layouts
+  overloading activate()
+
+  \sa canvasRect(), activate()
+ */
+void QwtPlotLayout::setCanvasRect( const QRectF &rect )
+{
+    d_data->canvasRect = rect;
+}
+
+/*!
   \return Geometry for the canvas
   \sa activate(), invalidate()
 */
-const QRectF &QwtPlotLayout::canvasRect() const
+QRectF QwtPlotLayout::canvasRect() const
 {
     return d_data->canvasRect;
 }
@@ -480,7 +550,9 @@
 }
 
 /*!
-  \brief Return a minimum size hint
+  \return Minimum size hint
+  \param plot Plot widget
+
   \sa QwtPlot::minimumSizeHint()
 */
 
@@ -503,6 +575,9 @@
 
     int canvasBorder[QwtPlot::axisCnt];
 
+    int fw;
+    plot->canvas()->getContentsMargins( &fw, NULL, NULL, NULL );
+
     int axis;
     for ( axis = 0; axis < QwtPlot::axisCnt; axis++ )
     {
@@ -520,9 +595,7 @@
                 sd.tickOffset += qCeil( scl->scaleDraw()->maxTickLength() );
         }
 
-        canvasBorder[axis] = plot->canvas()->frameWidth() +
-            d_data->canvasMargin[axis] + 1;
-
+        canvasBorder[axis] = fw + d_data->canvasMargin[axis] + 1;
     }
 
 
@@ -574,17 +647,21 @@
         }
     }
 
-    const QwtPlotCanvas *canvas = plot->canvas();
+    const QWidget *canvas = plot->canvas();
+
+    int left, top, right, bottom;
+    canvas->getContentsMargins( &left, &top, &right, &bottom );
+
     const QSize minCanvasSize = canvas->minimumSize();
 
     int w = scaleData[QwtPlot::yLeft].w + scaleData[QwtPlot::yRight].w;
     int cw = qMax( scaleData[QwtPlot::xBottom].w, scaleData[QwtPlot::xTop].w )
-        + 2 * ( canvas->frameWidth() + 1 );
+        + left + 1 + right + 1;
     w += qMax( cw, minCanvasSize.width() );
 
     int h = scaleData[QwtPlot::xBottom].h + scaleData[QwtPlot::xTop].h;
     int ch = qMax( scaleData[QwtPlot::yLeft].h, scaleData[QwtPlot::yRight].h )
-        + 2 * ( canvas->frameWidth() + 1 );
+        + top + 1 + bottom + 1;
     h += qMax( ch, minCanvasSize.height() );
 
     const QwtTextLabel *labels[2];
@@ -627,8 +704,7 @@
     // Compute the legend contribution
 
     const QwtAbstractLegend *legend = plot->legend();
-    if ( d_data->legendPos != QwtPlot::ExternalLegend
-        && legend && !legend->isEmpty() )
+    if ( legend && !legend->isEmpty() )
     {
         if ( d_data->legendPos == QwtPlot::LeftLegend
             || d_data->legendPos == QwtPlot::RightLegend )
@@ -723,8 +799,6 @@
             legendRect.setY( rect.bottom() - dim );
             legendRect.setHeight( dim );
             break;
-        case QwtPlot::ExternalLegend:
-            break;
     }
 
     return legendRect;
@@ -769,7 +843,7 @@
   of their widgets in orientation of the text.
 
   \param options Options how to layout the legend
-  \param rect Bounding rect for title, footer, axes and canvas.
+  \param rect Bounding rectangle for title, footer, axes and canvas.
   \param dimTitle Expanded height of the title widget
   \param dimFooter Expanded height of the footer widget
   \param dimAxis Expanded heights of the axis in axis orientation.
@@ -788,7 +862,7 @@
     {
         backboneOffset[axis] = 0;
         if ( !( options & IgnoreFrames ) )
-            backboneOffset[axis] += d_data->layoutData.canvas.frameWidth;
+            backboneOffset[axis] += d_data->layoutData.canvas.contentsMargins[ axis ];
 
         if ( !d_data->alignCanvasToScales[axis] )
             backboneOffset[axis] += d_data->canvasMargin[axis];
@@ -859,7 +933,7 @@
                 d_data->layoutData.scale[axis];
 
             if ( scaleData.isEnabled )
-        {
+            {
                 double length;
                 if ( axis == QwtPlot::xTop || axis == QwtPlot::xBottom )
                 {
@@ -925,6 +999,10 @@
   Align the ticks of the axis to the canvas borders using
   the empty corners.
 
+  \param options Layout options
+  \param canvasRect Geometry of the canvas ( IN/OUT )
+  \param scaleRect Geometries of the scales ( IN/OUT )
+
   \sa Options
 */
 
@@ -937,10 +1015,15 @@
         backboneOffset[axis] = 0;
 
         if ( !d_data->alignCanvasToScales[axis] )
+        {
             backboneOffset[axis] += d_data->canvasMargin[axis];
+        }
 
         if ( !( options & IgnoreFrames ) )
-            backboneOffset[axis] += d_data->layoutData.canvas.frameWidth;
+        {
+            backboneOffset[axis] += 
+                d_data->layoutData.canvas.contentsMargins[axis];
+        }
     }
 
     for ( int axis = 0; axis < QwtPlot::axisCnt; axis++ )
@@ -1111,9 +1194,6 @@
       border distances. Now we have to realign the other scale.
      */
 
-    int fw = 0;
-    if ( !( options & IgnoreFrames ) )
-        fw = d_data->layoutData.canvas.frameWidth;
 
     for ( int axis = 0; axis < QwtPlot::axisCnt; axis++ )
     {
@@ -1126,13 +1206,19 @@
         {
             if ( d_data->alignCanvasToScales[QwtPlot::yLeft] )
             {
-                sRect.setLeft( canvasRect.left() + fw
-                    - d_data->layoutData.scale[axis].start );
+                double y = canvasRect.left() - d_data->layoutData.scale[axis].start;
+                if ( !( options & IgnoreFrames ) )
+                    y += d_data->layoutData.canvas.contentsMargins[ QwtPlot::yLeft ];
+
+                sRect.setLeft( y );
             }
             if ( d_data->alignCanvasToScales[QwtPlot::yRight] )
             {
-                sRect.setRight( canvasRect.right() - fw - 1
-                    + d_data->layoutData.scale[axis].end );
+                double y = canvasRect.right() - 1 + d_data->layoutData.scale[axis].end;
+                if ( !( options & IgnoreFrames ) )
+                    y -= d_data->layoutData.canvas.contentsMargins[ QwtPlot::yRight ];
+
+                sRect.setRight( y );
             }
 
             if ( d_data->alignCanvasToScales[ axis ] )
@@ -1147,13 +1233,19 @@
         {
             if ( d_data->alignCanvasToScales[QwtPlot::xTop] )
             {
-                sRect.setTop( canvasRect.top() + fw
-                    - d_data->layoutData.scale[axis].start );
+                double x = canvasRect.top() - d_data->layoutData.scale[axis].start;
+                if ( !( options & IgnoreFrames ) )
+                    x += d_data->layoutData.canvas.contentsMargins[ QwtPlot::xTop ];
+
+                sRect.setTop( x );
             }
             if ( d_data->alignCanvasToScales[QwtPlot::xBottom] )
             {
-                sRect.setBottom( canvasRect.bottom() - fw - 1
-                    + d_data->layoutData.scale[axis].end );
+                double x = canvasRect.bottom() - 1 + d_data->layoutData.scale[axis].end;
+                if ( !( options & IgnoreFrames ) )
+                    x -= d_data->layoutData.canvas.contentsMargins[ QwtPlot::xBottom ];
+
+                sRect.setBottom( x );
             }
 
             if ( d_data->alignCanvasToScales[ axis ] )
@@ -1171,7 +1263,7 @@
   \brief Recalculate the geometry of all components.
 
   \param plot Plot to be layout
-  \param plotRect Rect where to place the components
+  \param plotRect Rectangle where to place the components
   \param options Layout options
 
   \sa invalidate(), titleRect(), footerRect()
@@ -1184,13 +1276,12 @@
 
     QRectF rect( plotRect );  // undistributed rest of the plot rect
 
-    // We extract all layout relevant data from the widgets,
-    // filter them through pfilter and save them to d_data->layoutData.
+    // We extract all layout relevant parameters from the widgets,
+    // and save them to d_data->layoutData.
 
     d_data->layoutData.init( plot, rect );
 
     if ( !( options & IgnoreLegend )
-        && d_data->legendPos != QwtPlot::ExternalLegend
         && plot->legend() && !plot->legend()->isEmpty() )
     {
         d_data->legendRect = layoutLegend( options, rect );
@@ -1198,7 +1289,7 @@
         // subtract d_data->legendRect from rect
 
         const QRegion region( rect.toRect() );
-        rect = region.subtract( d_data->legendRect.toRect() ).boundingRect();
+        rect = region.subtracted( d_data->legendRect.toRect() ).boundingRect();
 
         switch ( d_data->legendPos )
         {
@@ -1214,8 +1305,6 @@
             case QwtPlot::BottomLegend:
                 rect.setBottom( rect.bottom() - d_data->spacing );
                 break;
-            case QwtPlot::ExternalLegend:
-                break; // suppress compiler warning
         }
     }
 
Index: qwt_plot_svgitem.cpp
===================================================================
--- qwt_plot_svgitem.cpp	(revision 382)
+++ qwt_plot_svgitem.cpp	(working copy)
@@ -63,6 +63,7 @@
 void QwtPlotSvgItem::init()
 {
     d_data = new PrivateData();
+    d_data->boundingRect = QwtPlotItem::boundingRect();
 
     setItemAttribute( QwtPlotItem::AutoScale, true );
     setItemAttribute( QwtPlotItem::Legend, false );
@@ -116,7 +117,7 @@
     return ok;
 }
 
-//! Bounding rect of the item
+//! Bounding rectangle of the item
 QRectF QwtPlotSvgItem::boundingRect() const
 {
     return d_data->boundingRect;
@@ -164,8 +165,8 @@
   Render the SVG data
 
   \param painter Painter
-  \param viewBox View Box, see QSvgRenderer::viewBox
-  \param rect Traget rectangle on the paint device
+  \param viewBox View Box, see QSvgRenderer::viewBox()
+  \param rect Target rectangle on the paint device
 */
 void QwtPlotSvgItem::render( QPainter *painter,
     const QRectF &viewBox, const QRectF &rect ) const
@@ -188,10 +189,10 @@
 }
 
 /*!
-  Calculate the viewBox from an rect and boundingRect().
+  Calculate the view box from rect and boundingRect().
 
   \param rect Rectangle in scale coordinates
-  \return viewBox View Box, see QSvgRenderer::viewBox
+  \return View box, see QSvgRenderer::viewBox()
 */
 QRectF QwtPlotSvgItem::viewBox( const QRectF &rect ) const
 {
Index: qwt_event_pattern.cpp
===================================================================
--- qwt_event_pattern.cpp	(revision 382)
+++ qwt_event_pattern.cpp	(working copy)
@@ -37,10 +37,6 @@
 */
 void QwtEventPattern::initMousePattern( int numButtons )
 {
-    const int altButton = Qt::AltModifier;
-    const int controlButton = Qt::ControlModifier;
-    const int shiftButton = Qt::ShiftModifier;
-
     d_mousePattern.resize( MousePatternCount );
 
     switch ( numButtons )
@@ -48,15 +44,15 @@
         case 1:
         {
             setMousePattern( MouseSelect1, Qt::LeftButton );
-            setMousePattern( MouseSelect2, Qt::LeftButton, controlButton );
-            setMousePattern( MouseSelect3, Qt::LeftButton, altButton );
+            setMousePattern( MouseSelect2, Qt::LeftButton, Qt::ControlModifier );
+            setMousePattern( MouseSelect3, Qt::LeftButton, Qt::AltModifier );
             break;
         }
         case 2:
         {
             setMousePattern( MouseSelect1, Qt::LeftButton );
             setMousePattern( MouseSelect2, Qt::RightButton );
-            setMousePattern( MouseSelect3, Qt::LeftButton, altButton );
+            setMousePattern( MouseSelect3, Qt::LeftButton, Qt::AltModifier );
             break;
         }
         default:
@@ -66,12 +62,15 @@
             setMousePattern( MouseSelect3, Qt::MidButton );
         }
     }
-    for ( int i = 0; i < 3; i++ )
-    {
-        setMousePattern( MouseSelect4 + i,
-                         d_mousePattern[MouseSelect1 + i].button,
-                         d_mousePattern[MouseSelect1 + i].state | shiftButton );
-    }
+
+    setMousePattern( MouseSelect4, d_mousePattern[MouseSelect1].button,
+        d_mousePattern[MouseSelect1].modifiers | Qt::ShiftModifier );
+
+    setMousePattern( MouseSelect5, d_mousePattern[MouseSelect2].button,
+        d_mousePattern[MouseSelect2].modifiers | Qt::ShiftModifier );
+
+    setMousePattern( MouseSelect6, d_mousePattern[MouseSelect3].button,
+        d_mousePattern[MouseSelect3].modifiers | Qt::ShiftModifier );
 }
 
 /*!
@@ -102,16 +101,17 @@
 
   \param pattern Index of the pattern
   \param button Button
-  \param state State
+  \param modifiers Keyboard modifiers
 
   \sa QMouseEvent
 */
-void QwtEventPattern::setMousePattern( uint pattern, int button, int state )
+void QwtEventPattern::setMousePattern( MousePatternCode pattern, 
+    Qt::MouseButton button, Qt::KeyboardModifiers modifiers )
 {
-    if ( pattern < static_cast<uint>( d_mousePattern.count() ) )
+    if ( pattern >= 0 && pattern < MousePatternCount )
     {
         d_mousePattern[ pattern ].button = button;
-        d_mousePattern[ pattern ].state = state;
+        d_mousePattern[ pattern ].modifiers = modifiers;
     }
 }
 
@@ -120,16 +120,17 @@
 
   \param pattern Index of the pattern
   \param key Key
-  \param state State
+  \param modifiers Keyboard modifiers
 
   \sa QKeyEvent
 */
-void QwtEventPattern::setKeyPattern( uint pattern, int key, int state )
+void QwtEventPattern::setKeyPattern( KeyPatternCode pattern, 
+    int key, Qt::KeyboardModifiers modifiers )
 {
-    if ( pattern < static_cast<uint>( d_keyPattern.count() ) )
+    if ( pattern >= 0 && pattern < KeyPatternCount )
     {
         d_keyPattern[ pattern ].key = key;
-        d_keyPattern[ pattern ].state = state;
+        d_keyPattern[ pattern ].modifiers = modifiers;
     }
 }
 
@@ -145,27 +146,27 @@
     d_keyPattern = pattern;
 }
 
-//! Return mouse patterns
+//! \return Mouse pattern
 const QVector<QwtEventPattern::MousePattern> &
 QwtEventPattern::mousePattern() const
 {
     return d_mousePattern;
 }
 
-//! Return key patterns
+//! \return Key pattern
 const QVector<QwtEventPattern::KeyPattern> &
 QwtEventPattern::keyPattern() const
 {
     return d_keyPattern;
 }
 
-//! Return ,ouse patterns
+//! \return Mouse pattern
 QVector<QwtEventPattern::MousePattern> &QwtEventPattern::mousePattern()
 {
     return d_mousePattern;
 }
 
-//! Return Key patterns
+//! \return Key pattern
 QVector<QwtEventPattern::KeyPattern> &QwtEventPattern::keyPattern()
 {
     return d_keyPattern;
@@ -178,21 +179,19 @@
   value and in the state value the same key flags(Qt::KeyButtonMask)
   are set.
 
-  \param pattern Index of the event pattern
+  \param code Index of the event pattern
   \param event Mouse event
   \return true if matches
 
   \sa keyMatch()
 */
-bool QwtEventPattern::mouseMatch( uint pattern, 
+bool QwtEventPattern::mouseMatch( MousePatternCode code, 
     const QMouseEvent *event ) const
 {
-    bool ok = false;
+    if ( code >= 0 && code < MousePatternCount )
+        return mouseMatch( d_mousePattern[ code ], event );
 
-    if ( event && pattern < static_cast<uint>( d_mousePattern.count() ) )
-        ok = mouseMatch( d_mousePattern[ pattern ], event );
-
-    return ok;
+    return false;
 }
 
 /*!
@@ -212,14 +211,11 @@
 bool QwtEventPattern::mouseMatch( const MousePattern &pattern,
     const QMouseEvent *event ) const
 {
-    if ( event->button() != pattern.button )
+    if ( event == NULL )
         return false;
 
-    const bool matched =
-        ( event->modifiers() & Qt::KeyboardModifierMask ) ==
-            ( int )( pattern.state & Qt::KeyboardModifierMask );
-
-    return matched;
+    const MousePattern mousePattern( event->button(), event->modifiers() );
+    return mousePattern == pattern;
 }
 
 /*!
@@ -229,21 +225,19 @@
   value and in the state value the same key flags (Qt::KeyButtonMask)
   are set.
 
-  \param pattern Index of the event pattern
+  \param code Index of the event pattern
   \param event Key event
   \return true if matches
 
   \sa mouseMatch()
 */
-bool QwtEventPattern::keyMatch( uint pattern, 
+bool QwtEventPattern::keyMatch( KeyPatternCode code, 
     const QKeyEvent *event ) const
 {
-    bool ok = false;
+    if ( code >= 0 && code < KeyPatternCount )
+        return keyMatch( d_keyPattern[ code ], event );
 
-    if ( event && pattern < static_cast<uint>( d_keyPattern.count() ) )
-        ok = keyMatch( d_keyPattern[ pattern ], event );
-
-    return ok;
+    return false;
 }
 
 /*!
@@ -263,12 +257,9 @@
 bool QwtEventPattern::keyMatch(
     const KeyPattern &pattern, const QKeyEvent *event ) const
 {
-    if ( event->key() != pattern.key )
+    if ( event == NULL )
         return false;
 
-    const bool matched =
-        ( event->modifiers() & Qt::KeyboardModifierMask ) ==
-            ( int )( pattern.state & Qt::KeyboardModifierMask );
-
-    return matched;
+    const KeyPattern keyPattern( event->key(), event->modifiers() );
+    return keyPattern == pattern;
 }
Index: qwt_plot.cpp
===================================================================
--- qwt_plot.cpp	(revision 382)
+++ qwt_plot.cpp	(working copy)
@@ -16,6 +16,7 @@
 #include "qwt_legend.h"
 #include "qwt_legend_data.h"
 #include "qwt_plot_canvas.h"
+#include <qmath.h>
 #include <qpainter.h>
 #include <qpointer.h>
 #include <qpaintengine.h>
@@ -28,17 +29,17 @@
     {
         QObject::connect( 
             plot, SIGNAL( legendDataChanged(
-                const QwtPlotItem *, const QList<QwtLegendData> & ) ),
+                const QVariant &, const QList<QwtLegendData> & ) ),
             plot, SLOT( updateLegendItems( 
-                const QwtPlotItem *, const QList<QwtLegendData> & ) ) );
+                const QVariant &, const QList<QwtLegendData> & ) ) );
     }
     else
     {
         QObject::disconnect( 
             plot, SIGNAL( legendDataChanged(
-                const QwtPlotItem *, const QList<QwtLegendData> & ) ),
+                const QVariant &, const QList<QwtLegendData> & ) ),
             plot, SLOT( updateLegendItems( 
-                const QwtPlotItem *, const QList<QwtLegendData> & ) ) );
+                const QVariant &, const QList<QwtLegendData> & ) ) );
     }
 }
 
@@ -51,7 +52,7 @@
 
     if ( withChildren )
     {
-        QList<QWidget *> children = qFindChildren<QWidget *>( second );
+        QList<QWidget *> children = second->findChildren<QWidget *>();
 
         QWidget *w = second->nextInFocusChain();
         while ( children.contains( w ) )
@@ -95,7 +96,7 @@
 public:
     QPointer<QwtTextLabel> titleLabel;
     QPointer<QwtTextLabel> footerLabel;
-    QPointer<QwtPlotCanvas> canvas;
+    QPointer<QWidget> canvas;
     QPointer<QwtAbstractLegend> legend;
     QwtPlotLayout *layout;
 
@@ -170,8 +171,6 @@
     // canvas
     d_data->canvas = new QwtPlotCanvas( this );
     d_data->canvas->setObjectName( "QwtPlotCanvas" );
-    d_data->canvas->setFrameStyle( QFrame::Panel | QFrame::Sunken );
-    d_data->canvas->setLineWidth( 2 );
     d_data->canvas->installEventFilter( this );
 
     setSizePolicy( QSizePolicy::MinimumExpanding,
@@ -191,8 +190,52 @@
 }
 
 /*!
+  \brief Set the drawing canvas of the plot widget
+
+  QwtPlot invokes methods of the canvas as meta methods ( see QMetaObject ).
+  In opposite to using conventional C++ techniques like virtual methods
+  they allow to use canvas implementations that are derived from 
+  QWidget or QGLWidget.
+
+  The following meta methods could be implemented:
+
+  - replot()
+    When the canvas doesn't offer a replot method, QwtPlot calls
+    update() instead.
+
+  - borderPath()
+    The border path is necessary to clip the content of the canvas
+    When the canvas doesn't have any special border ( f.e rounded corners )
+    it is o.k. not to implement this method.
+
+  The default canvas is a QwtPlotCanvas 
+
+  \param canvas Canvas Widget
+  \sa canvas()
+ */
+void QwtPlot::setCanvas( QWidget *canvas )
+{
+    if ( canvas == d_data->canvas )
+        return;
+
+    delete d_data->canvas;
+    d_data->canvas = canvas;
+
+    if ( canvas )
+    {
+        canvas->setParent( this );
+        canvas->installEventFilter( this );
+
+        if ( isVisible() )
+            canvas->show();
+    }
+}
+
+/*!
   \brief Adds handling of layout requests
   \param event Event
+
+  \return See QFrame::event()
 */
 bool QwtPlot::event( QEvent *event )
 {
@@ -210,12 +253,36 @@
     return ok;
 }
 
+/*!
+  \brief Event filter
+
+  The plot handles the following events for the canvas:
+
+  - QEvent::Resize
+    The canvas margins might depend on its size
+
+  - QEvent::ContentsRectChange
+    The layout needs to be recalculated
+
+  \param object Object to be filtered
+  \param event Event
+
+  \return See QFrame::eventFilter()
+
+  \sa updateCanvasMargins(), updateLayout()
+*/
 bool QwtPlot::eventFilter( QObject *object, QEvent *event )
 {
     if ( object == d_data->canvas )
     {
         if ( event->type() == QEvent::Resize )
+        {
             updateCanvasMargins();
+        }
+        else if ( event->type() == QEvent::ContentsRectChange )
+        {
+            updateLayout();
+        }
     }
 
     return QFrame::eventFilter( object, event );
@@ -289,13 +356,13 @@
     return d_data->titleLabel->text();
 }
 
-//! \return Titel label widget.
+//! \return Title label widget.
 QwtTextLabel *QwtPlot::titleLabel()
 {
     return d_data->titleLabel;
 }
 
-//! \return Titel label widget.
+//! \return Title label widget.
 const QwtTextLabel *QwtPlot::titleLabel() const
 {
     return d_data->titleLabel;
@@ -345,6 +412,23 @@
     return d_data->footerLabel;
 }
 
+/*!
+   \brief Assign a new plot layout
+
+   \param layout Layout()
+   \sa plotLayout()
+ */
+void QwtPlot::setPlotLayout( QwtPlotLayout *layout )
+{
+    if ( layout != d_data->layout )
+    {
+        delete d_data->layout;
+        layout = d_data->layout;
+
+        updateLayout();
+    }
+}
+
 //! \return the plot's layout
 QwtPlotLayout *QwtPlot::plotLayout()
 {
@@ -379,7 +463,7 @@
 /*!
   \return the plot's canvas
 */
-QwtPlotCanvas *QwtPlot::canvas()
+QWidget *QwtPlot::canvas()
 {
     return d_data->canvas;
 }
@@ -387,16 +471,15 @@
 /*!
   \return the plot's canvas
 */
-const QwtPlotCanvas *QwtPlot::canvas() const
+const QWidget *QwtPlot::canvas() const
 {
     return d_data->canvas;
 }
 
 /*!
-  Return sizeHint
+  \return Size hint for the plot widget
   \sa minimumSizeHint()
 */
-
 QSize QwtPlot::sizeHint() const
 {
     int dw = 0;
@@ -457,8 +540,7 @@
   or if any curves are attached to raw data, the plot has to
   be refreshed explicitly in order to make changes visible.
 
-  \sa setAutoReplot()
-  \warning Calls canvas()->repaint, take care of infinite recursions
+  \sa updateAxes(), setAutoReplot()
 */
 void QwtPlot::replot()
 {
@@ -474,7 +556,16 @@
      */
     QApplication::sendPostedEvents( this, QEvent::LayoutRequest );
 
-    d_data->canvas->replot();
+    if ( d_data->canvas )
+    {
+        const bool ok = QMetaObject::invokeMethod( 
+            d_data->canvas, "replot", Qt::DirectConnection );
+        if ( !ok )
+        {
+            // fallback, when canvas has no a replot method
+            d_data->canvas->update( d_data->canvas->contentsRect() );
+        }
+    }
 
     setAutoReplot( doAutoReplot );
 }
@@ -528,9 +619,9 @@
 
                 QRegion r( scaleRect[axisId] );
                 if ( axisEnabled( yLeft ) )
-                    r = r.subtract( QRegion( scaleRect[yLeft] ) );
+                    r = r.subtracted( QRegion( scaleRect[yLeft] ) );
                 if ( axisEnabled( yRight ) )
-                    r = r.subtract( QRegion( scaleRect[yRight] ) );
+                    r = r.subtracted( QRegion( scaleRect[yRight] ) );
                 r.translate( -scaleRect[ axisId ].x(),
                     -scaleRect[axisId].y() );
 
@@ -544,8 +635,7 @@
             axisWidget( axisId )->hide();
     }
 
-    if ( d_data->legend &&
-        d_data->layout->legendPosition() != ExternalLegend )
+    if ( d_data->legend )
     {
         if ( d_data->legend->isEmpty() )
         {
@@ -561,6 +651,21 @@
     d_data->canvas->setGeometry( canvasRect );
 }
 
+/*!
+  \brief Calculate the canvas margins
+
+  \param maps QwtPlot::axisCnt maps, mapping between plot and paint device coordinates
+  \param canvasRect Bounding rectangle where to paint
+  \param left Return parameter for the left margin
+  \param top Return parameter for the top margin
+  \param right Return parameter for the right margin
+  \param bottom Return parameter for the bottom margin
+
+  Plot items might indicate, that they need some extra space
+  at the borders of the canvas by the QwtPlotItem::Margins flag.
+
+  updateCanvasMargins(), QwtPlotItem::getCanvasMarginHint()
+ */
 void QwtPlot::getCanvasMarginsHint(
     const QwtScaleMap maps[], const QRectF &canvasRect,
     double &left, double &top, double &right, double &bottom) const
@@ -587,6 +692,14 @@
     }
 }
 
+/*!
+  \brief Update the canvas margins
+
+  Plot items might indicate, that they need some extra space
+  at the borders of the canvas by the QwtPlotItem::Margins flag.
+
+  getCanvasMarginsHint(), QwtPlotItem::getCanvasMarginHint()
+ */
 void QwtPlot::updateCanvasMargins()
 {
     QwtScaleMap maps[axisCnt];
@@ -632,13 +745,19 @@
 
 /*!
   Redraw the canvas items.
+
   \param painter Painter used for drawing
   \param canvasRect Bounding rectangle where to paint
-  \param map QwtPlot::axisCnt maps, mapping between plot and paint device coordinates
+  \param maps QwtPlot::axisCnt maps, mapping between plot and paint device coordinates
+
+  \note Usually canvasRect is contentsRect() of the plot canvas.
+        Due to a bug in Qt this rectangle might be wrong for certain 
+        frame styles ( f.e QFrame::Box ) and it might be necessary to 
+        fix the margins manually using QWidget::setContentsMargins()
 */
 
 void QwtPlot::drawItems( QPainter *painter, const QRectF &canvasRect,
-        const QwtScaleMap map[axisCnt] ) const
+        const QwtScaleMap maps[axisCnt] ) const
 {
     const QwtPlotItemList& itmList = itemList();
     for ( QwtPlotItemIterator it = itmList.begin();
@@ -651,9 +770,11 @@
 
             painter->setRenderHint( QPainter::Antialiasing,
                 item->testRenderHint( QwtPlotItem::RenderAntialiased ) );
+            painter->setRenderHint( QPainter::HighQualityAntialiasing,
+                item->testRenderHint( QwtPlotItem::RenderAntialiased ) );
 
             item->draw( painter,
-                map[item->xAxis()], map[item->yAxis()],
+                maps[item->xAxis()], maps[item->yAxis()],
                 canvasRect );
 
             painter->restore();
@@ -719,7 +840,7 @@
 /*!
   \brief Change the background of the plotting area
 
-  Sets brush to QPalette::Window of all colorgroups of
+  Sets brush to QPalette::Window of all color groups of
   the palette of the canvas. Using canvas()->setPalette()
   is a more powerful way to set these colors.
 
@@ -748,31 +869,6 @@
 }
 
 /*!
-  \brief Change the border width of the plotting area
-
-  Nothing else than canvas()->setLineWidth(w),
-  left for compatibility only.
-
-  \param width New border width
-*/
-void QwtPlot::setCanvasLineWidth( int width )
-{
-    canvas()->setLineWidth( width );
-    updateLayout();
-}
-
-/*!
-  Nothing else than: canvas()->lineWidth(),
-  left for compatibility only.
-
-  \return the border width of the plotting area
-*/
-int QwtPlot::canvasLineWidth() const
-{
-    return canvas()->lineWidth();
-}
-
-/*!
   \return \c true if the specified axis exists, otherwise \c false
   \param axisId axis index
  */
@@ -789,17 +885,23 @@
   Otherwise the legend items will be placed in a table
   with a best fit number of columns from left to right.
 
-  If pos != QwtPlot::ExternalLegend the plot widget will become
-  parent of the legend. It will be deleted when the plot is deleted,
-  or another legend is set with insertLegend().
+  insertLegend() will set the plot widget as parent for the legend.
+  The legend will be deleted in the destructor of the plot or when 
+  another legend is inserted.
 
+  Legends, that are not inserted into the layout of the plot widget
+  need to connect to the legendDataChanged() signal. Calling updateLegend()
+  initiates this signal for an initial update. When the application code
+  wants to implement its own layout this also needs to be done for
+  rendering plots to a document ( see QwtPlotRenderer ).
+
   \param legend Legend
   \param pos The legend's position. For top/left position the number
-             of colums will be limited to 1, otherwise it will be set to
+             of columns will be limited to 1, otherwise it will be set to
              unlimited.
 
-  \param ratio Ratio between legend and the bounding rect
-               of title, canvas and axes. The legend will be shrinked
+  \param ratio Ratio between legend and the bounding rectangle
+               of title, canvas and axes. The legend will be shrunk
                if it would need more space than the given ratio.
                The ratio is limited to ]0.0 .. 1.0]. In case of <= 0.0
                it will be reset to the default ratio.
@@ -824,17 +926,14 @@
         {
             connect( this, 
                 SIGNAL( legendDataChanged( 
-                    const QwtPlotItem *, const QList<QwtLegendData> & ) ),
+                    const QVariant &, const QList<QwtLegendData> & ) ),
                 d_data->legend, 
                 SLOT( updateLegend( 
-                    const QwtPlotItem *, const QList<QwtLegendData> & ) ) 
+                    const QVariant &, const QList<QwtLegendData> & ) ) 
             );
 
-            if ( pos != ExternalLegend )
-            {
-                if ( d_data->legend->parent() != this )
-                    d_data->legend->setParent( this );
-            }
+            if ( d_data->legend->parent() != this )
+                d_data->legend->setParent( this );
 
             qwtEnableLegendItems( this, false );
             updateLegend();
@@ -886,8 +985,6 @@
                     previousInChain = footerLabel();
                     break;
                 }
-                default:
-                    break;
             }
 
             if ( previousInChain )
@@ -898,6 +995,11 @@
     updateLayout();
 }
 
+/*!
+  Emit legendDataChanged() for all plot item
+
+  \sa QwtPlotItem::legendData(), legendDataChanged()
+ */
 void QwtPlot::updateLegend()
 {
     const QwtPlotItemList& itmList = itemList();
@@ -908,6 +1010,12 @@
     }
 }
 
+/*!
+  Emit legendDataChanged() for a plot item
+
+  \param plotItem Plot item
+  \sa QwtPlotItem::legendData(), legendDataChanged()
+ */
 void QwtPlot::updateLegend( const QwtPlotItem *plotItem )
 {
     if ( plotItem == NULL )
@@ -918,19 +1026,36 @@
     if ( plotItem->testItemAttribute( QwtPlotItem::Legend ) )
         legendData = plotItem->legendData();
 
-    Q_EMIT legendDataChanged( plotItem, legendData );
+    const QVariant itemInfo = itemToInfo( const_cast< QwtPlotItem *>( plotItem) );
+    Q_EMIT legendDataChanged( itemInfo, legendData );
 }
 
-void QwtPlot::updateLegendItems( const QwtPlotItem *plotItem,
-    const QList<QwtLegendData> &data )
+/*!
+  \brief Update all plot items interested in legend attributes
+
+  Call QwtPlotItem::updateLegend(), when the QwtPlotItem::LegendInterest
+  flag is set.
+
+  \param itemInfo Info about the plot item
+  \param legendData Entries to be displayed for the plot item ( usually 1 )
+
+  \sa QwtPlotItem::LegendInterest,
+      QwtPlotLegendItem, QwtPlotItem::updateLegend()
+ */
+void QwtPlot::updateLegendItems( const QVariant &itemInfo,
+    const QList<QwtLegendData> &legendData )
 {
-    const QwtPlotItemList& itmList = itemList();
-    for ( QwtPlotItemIterator it = itmList.begin();
-        it != itmList.end(); ++it )
+    QwtPlotItem *plotItem = infoToItem( itemInfo );
+    if ( plotItem )
     {
-        QwtPlotItem *item = *it;
-        if ( item->testItemInterest( QwtPlotItem::LegendInterest ) )
-            item->updateLegend( plotItem, data );
+        const QwtPlotItemList& itmList = itemList();
+        for ( QwtPlotItemIterator it = itmList.begin();
+            it != itmList.end(); ++it )
+        {
+            QwtPlotItem *item = *it;
+            if ( item->testItemInterest( QwtPlotItem::LegendInterest ) )
+                item->updateLegend( plotItem, legendData );
+        }
     }
 }
 
@@ -973,12 +1098,66 @@
         // the item wants to be represented on the legend
 
         if ( on )
+        {
             updateLegend( plotItem );
+        }
         else
-            Q_EMIT legendDataChanged( plotItem, QList<QwtLegendData>() );
+        {
+            const QVariant itemInfo = itemToInfo( plotItem );
+            Q_EMIT legendDataChanged( itemInfo, QList<QwtLegendData>() );
+        }
     }
 
     if ( autoReplot() )
         update();
 }
 
+/*!
+  \brief Build an information, that can be used to identify
+         a plot item on the legend.
+
+  The default implementation simply wraps the plot item
+  into a QVariant object. When overloading itemToInfo()
+  usually infoToItem() needs to reimplemeted too.
+
+\code
+    QVariant itemInfo;
+    qVariantSetValue( itemInfo, plotItem );
+\endcode
+
+  \param plotItem Plot item
+  \return Plot item embedded in a QVariant
+  \sa infoToItem()
+ */
+QVariant QwtPlot::itemToInfo( QwtPlotItem *plotItem ) const
+{
+    QVariant itemInfo;
+    qVariantSetValue( itemInfo, plotItem );
+
+    return itemInfo;
+}
+
+/*!
+  \brief Identify the plot item according to an item info object,
+         that has bee generated from itemToInfo().
+
+  The default implementation simply tries to unwrap a QwtPlotItem 
+  pointer:
+
+\code
+    if ( itemInfo.canConvert<QwtPlotItem *>() )
+        return qvariant_cast<QwtPlotItem *>( itemInfo );
+\endcode
+  \param itemInfo Plot item
+  \return A plot item, when successful, otherwise a NULL pointer.
+  \sa itemToInfo()
+*/
+QwtPlotItem *QwtPlot::infoToItem( const QVariant &itemInfo ) const
+{
+    if ( itemInfo.canConvert<QwtPlotItem *>() )
+        return qvariant_cast<QwtPlotItem *>( itemInfo );
+
+    return NULL;
+}
+
+
Index: qwt_round_scale_draw.h
===================================================================
--- qwt_round_scale_draw.h	(revision 382)
+++ qwt_round_scale_draw.h	(working copy)
@@ -14,15 +14,13 @@
 #include "qwt_abstract_scale_draw.h"
 #include <qpoint.h>
 
-class QPen;
-
 /*!
   \brief A class for drawing round scales
 
   QwtRoundScaleDraw can be used to draw round scales.
-  The circle segment can be adjusted by QwtRoundScaleDraw::setAngleRange().
+  The circle segment can be adjusted by setAngleRange().
   The geometry of the scale can be specified with
-  QwtRoundScaleDraw::moveCenter() and QwtRoundScaleDraw::setRadius().
+  moveCenter() and setRadius().
 
   After a scale division has been specified as a QwtScaleDiv object
   using QwtAbstractScaleDraw::setScaleDiv(const QwtScaleDiv &s),
@@ -47,9 +45,9 @@
     virtual double extent( const QFont & ) const;
 
 protected:
-    virtual void drawTick( QPainter *p, double val, double len ) const;
-    virtual void drawBackbone( QPainter *p ) const;
-    virtual void drawLabel( QPainter *p, double val ) const;
+    virtual void drawTick( QPainter *, double val, double len ) const;
+    virtual void drawBackbone( QPainter * ) const;
+    virtual void drawLabel( QPainter *, double val ) const;
 
 private:
     QwtRoundScaleDraw( const QwtRoundScaleDraw & );
Index: qwt_plot_legenditem.h
===================================================================
--- qwt_plot_legenditem.h	(revision 382)
+++ qwt_plot_legenditem.h	(working copy)
@@ -16,12 +16,48 @@
 
 class QFont;
 
+/*!
+  \brief A class which draws a legend inside the plot canvas
+
+  QwtPlotLegendItem can be used to draw a inside the plot canvas.
+  It can be used together with a QwtLegend or instead of it
+  to have more space for the plot canvas.
+
+  In opposite to QwtLegend the legend item is not interactive. 
+  To identify mouse clicks on a legend item an event filter
+  needs to be installed catching mouse events ob the plot canvas.
+  The geometries of the legend items are available using
+  legendGeometries().
+  
+  The legend item is aligned to plot canvas according to 
+  its alignment() flags. It might have a background for the
+  complete legend ( usually semi transparent ) or for
+  each legend item.
+
+  \note An external QwtLegend with a transparent background 
+        on top the plot canvas might be another option 
+        with a similar effect.
+*/
+
 class QWT_EXPORT QwtPlotLegendItem: public QwtPlotItem
 {
 public:
+    /*!
+      \brief Background mode
+
+      Depending on the mode the complete legend or each item 
+      might have an background.
+
+      The default setting is LegendBackground.
+
+       \sa setBackgroundMode(), setBackgroundBrush(), drawBackground()
+     */
     enum BackgroundMode
     {
+        //! The legend has a background
         LegendBackground,
+
+        //! Each item has a background
         ItemBackground
     };
 
@@ -78,18 +114,21 @@
     virtual void updateLegend( const QwtPlotItem *,
         const QList<QwtLegendData> & );
 
-    QRect geometry( const QRectF &canvasRect ) const;
+    virtual QRect geometry( const QRectF &canvasRect ) const;
 
     virtual QSize minimumSize( const QwtLegendData & ) const;
     virtual int heightForWidth( const QwtLegendData &, int w ) const;
 
+    QList< const QwtPlotItem * > plotItems() const;
+    QList< QRect > legendGeometries( const QwtPlotItem * ) const;
+
 protected:
     virtual void drawLegendData( QPainter *painter, 
         const QwtPlotItem *, const QwtLegendData &, const QRectF & ) const;
 
+    virtual void drawBackground( QPainter *, const QRectF &rect ) const;
+
 private:
-    void drawBackground( QPainter *, const QRectF &rect ) const;
-
     class PrivateData;
     PrivateData *d_data;
 };
Index: qwt_scale_engine.h
===================================================================
--- qwt_scale_engine.h	(revision 382)
+++ qwt_scale_engine.h	(working copy)
@@ -14,7 +14,7 @@
 #include "qwt_scale_div.h"
 #include "qwt_interval.h"
 
-class QwtScaleTransformation;
+class QwtTransform;
 
 /*!
   \brief Arithmetic including a tolerance
@@ -27,8 +27,8 @@
 
     static double divideEps( double interval, double steps );
 
-    static double ceil125( double x );
-    static double floor125( double x );
+    static double divideInterval( double interval, 
+        int numSteps, uint base );
 };
 
 /*!
@@ -39,9 +39,7 @@
 
   The layout of the scale can be varied with setAttribute().
 
-  Qwt offers implementations for logarithmic (log10)
-  and linear scales. Contributions for other types of scale engines
-  (date/time, log2 ... ) are welcome.
+  Qwt offers implementations for logarithmic and linear scales. 
 */
 
 class QWT_EXPORT QwtScaleEngine
@@ -80,9 +78,12 @@
     //! Layout attributes
     typedef QFlags<Attribute> Attributes;
 
-    explicit QwtScaleEngine();
+    explicit QwtScaleEngine( uint base = 10 );
     virtual ~QwtScaleEngine();
 
+    void setBase( uint base );
+    uint base() const;
+
     void setAttribute( Attribute, bool on = true );
     bool testAttribute( Attribute ) const;
 
@@ -112,21 +113,24 @@
 
       \param x1 First interval limit
       \param x2 Second interval limit
-      \param maxMajSteps Maximum for the number of major steps
-      \param maxMinSteps Maximum number of minor steps
+      \param maxMajorSteps Maximum for the number of major steps
+      \param maxMinorSteps Maximum number of minor steps
       \param stepSize Step size. If stepSize == 0.0, the scaleEngine
                    calculates one.
+
+      \return Calculated scale division
     */
     virtual QwtScaleDiv divideScale( double x1, double x2,
-        int maxMajSteps, int maxMinSteps,
+        int maxMajorSteps, int maxMinorSteps,
         double stepSize = 0.0 ) const = 0;
 
-    //! \return a transformation
-    virtual QwtScaleTransformation *transformation() const = 0;
+    void setTransformation( QwtTransform * );
+    QwtTransform *transformation() const;
 
 protected:
     bool contains( const QwtInterval &, double val ) const;
     QList<double> strip( const QList<double>&, const QwtInterval & ) const;
+
     double divideInterval( double interval, int numSteps ) const;
 
     QwtInterval buildInterval( double v ) const;
@@ -146,6 +150,9 @@
 class QWT_EXPORT QwtLinearScaleEngine: public QwtScaleEngine
 {
 public:
+    QwtLinearScaleEngine( uint base = 10 );
+    virtual ~QwtLinearScaleEngine();
+
     virtual void autoScale( int maxSteps,
         double &x1, double &x2, double &stepSize ) const;
 
@@ -153,7 +160,6 @@
         int numMajorSteps, int numMinorSteps,
                                      double stepSize = 0.0 ) const;
 
-    virtual QwtScaleTransformation *transformation() const;
 
 protected:
     QwtInterval align( const QwtInterval&, double stepSize ) const;
@@ -165,14 +171,13 @@
     QList<double> buildMajorTicks(
         const QwtInterval &interval, double stepSize ) const;
 
-    void buildMinorTicks(
-        const QList<double>& majorTicks,
-        int maxMinMark, double step,
-        QList<double> &, QList<double> & ) const;
+    void buildMinorTicks( const QList<double>& majorTicks,
+        int maxMinorSteps, double stepSize,
+        QList<double> &minorTicks, QList<double> &mediumTicks ) const;
 };
 
 /*!
-  \brief A scale engine for logarithmic (base 10) scales
+  \brief A scale engine for logarithmic scales
 
   The step size is measured in *decades*
   and the major step size will be adjusted to fit the pattern
@@ -182,9 +187,12 @@
   \warning the step size as well as the margins are measured in *decades*.
 */
 
-class QWT_EXPORT QwtLog10ScaleEngine: public QwtScaleEngine
+class QWT_EXPORT QwtLogScaleEngine: public QwtScaleEngine
 {
 public:
+    QwtLogScaleEngine( uint base = 10 );
+    virtual ~QwtLogScaleEngine();
+
     virtual void autoScale( int maxSteps,
         double &x1, double &x2, double &stepSize ) const;
 
@@ -192,12 +200,7 @@
         int numMajorSteps, int numMinorSteps,
         double stepSize = 0.0 ) const;
 
-    virtual QwtScaleTransformation *transformation() const;
-
 protected:
-    QwtInterval log10( const QwtInterval& ) const;
-    QwtInterval pow10( const QwtInterval& ) const;
-
     QwtInterval align( const QwtInterval&, double stepSize ) const;
 
     void buildTicks(
@@ -207,9 +210,9 @@
     QList<double> buildMajorTicks(
         const QwtInterval &interval, double stepSize ) const;
 
-    QList<double> buildMinorTicks(
-        const QList<double>& majorTicks,
-        int maxMinMark, double step ) const;
+    void buildMinorTicks( const QList<double>& majorTicks,
+        int maxMinorSteps, double stepSize,
+        QList<double> &minorTicks, QList<double> &mediumTicks ) const;
 };
 
 Q_DECLARE_OPERATORS_FOR_FLAGS( QwtScaleEngine::Attributes )
Index: qwt_plot_baritem.cpp
===================================================================
--- qwt_plot_baritem.cpp	(revision 382)
+++ qwt_plot_baritem.cpp	(working copy)
@@ -1,267 +0,0 @@
-/* -*- mode: C++ ; c-file-style: "stroustrup" -*- *****************************
- * Qwt Widget Library
- * Copyright (C) 1997   Josef Wilgen
- * Copyright (C) 2002   Uwe Rathmann
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the Qwt License, Version 1.0
- *****************************************************************************/
-
-#include "qwt_plot_baritem.h"
-#include "qwt_scale_map.h"
-
-static inline double qwtTransformWidth(
-    const QwtScaleMap &map, double value, double width )
-{
-    const double w2 = 0.5 * width;
-
-    const double v1 = map.transform( value - w2 );
-    const double v2 = map.transform( value + w2 );
-
-    return qAbs( v2 - v1 );
-}
-
-class QwtPlotBarItem::PrivateData
-{
-public:
-    PrivateData():
-        layoutPolicy( QwtPlotBarItem::AutoAdjustSamples ),
-        layoutHint( 0.5 ),
-        spacing( 10 ),
-        margin( 5 ),
-        baseline( 0.0 )
-    {
-    }
-
-    QwtPlotBarItem::LayoutPolicy layoutPolicy;
-    double layoutHint;
-    int spacing;
-    int margin;
-    double baseline;
-    ChartAttributes chartAttributes;
-};
-
-QwtPlotBarItem::QwtPlotBarItem( const QwtText &title ):
-    QwtPlotSeriesItem( title )
-{
-    d_data = new PrivateData;
-
-    setItemAttribute( QwtPlotItem::Legend, true );
-    setItemAttribute( QwtPlotItem::AutoScale, true );
-    setItemAttribute( QwtPlotItem::Margins, true );
-    setZ( 19.0 );
-}
-
-QwtPlotBarItem::~QwtPlotBarItem()
-{
-    delete d_data;
-}
-
-void QwtPlotBarItem::setChartAttribute( ChartAttribute attribute, bool on )
-{
-    if ( on )
-        d_data->chartAttributes |= attribute;
-    else
-        d_data->chartAttributes &= ~attribute;
-}
-
-bool QwtPlotBarItem::testChartAttribute( ChartAttribute attribute ) const
-{
-    return ( d_data->chartAttributes & attribute );
-}
-
-void QwtPlotBarItem::setLayoutPolicy( LayoutPolicy policy )
-{
-    if ( policy != d_data->layoutPolicy )
-    {
-        d_data->layoutPolicy = policy;
-        itemChanged();
-    }
-}
-
-QwtPlotBarItem::LayoutPolicy QwtPlotBarItem::layoutPolicy() const
-{
-    return d_data->layoutPolicy;
-}
-
-void QwtPlotBarItem::setLayoutHint( double hint )
-{
-    hint = qMax( 0.0, hint );
-    if ( hint != d_data->layoutHint )
-    {
-        d_data->layoutHint = hint;
-        itemChanged();
-    }
-}
-
-double QwtPlotBarItem::layoutHint() const
-{
-    return d_data->layoutHint;
-}
-
-void QwtPlotBarItem::setSpacing( int spacing )
-{
-    spacing = qMax( spacing, 0 );
-    if ( spacing != d_data->spacing )
-    {
-        d_data->spacing = spacing;
-        itemChanged();
-    }
-}
-
-int QwtPlotBarItem::spacing() const
-{
-    return d_data->spacing;
-}
-
-void QwtPlotBarItem::setMargin( int margin )
-{
-    margin = qMax( margin, 0 );
-    if ( margin != d_data->margin )
-    {
-        d_data->margin = margin;
-        itemChanged();
-    }
-}
-
-int QwtPlotBarItem::margin() const
-{
-    return d_data->margin;
-}
-
-void QwtPlotBarItem::setBaseline( double value )
-{
-    if ( value != d_data->baseline )
-    {
-        d_data->baseline = value;
-        itemChanged();
-    }
-}
-
-double QwtPlotBarItem::baseline() const
-{
-    return d_data->baseline;
-}
-
-double QwtPlotBarItem::sampleWidth( const QwtScaleMap &map,
-    double canvasSize, double boundingSize, double value ) const
-{
-    double width;
-
-    switch( d_data->layoutPolicy )
-    {
-        case ScaleSamplesToAxes:
-        {
-            width = qwtTransformWidth( map, value, d_data->layoutHint );
-            break;
-        }
-        case ScaleSampleToCanvas:
-        {
-            width = canvasSize * d_data->layoutHint;
-            break;
-        }
-        case FixedSampleSize:
-        {
-            width = d_data->layoutHint;
-            break;
-        }
-        case AutoAdjustSamples:
-        default:
-        {
-            const size_t numSamples = dataSize();
-
-            double w = 1.0;
-            if ( numSamples > 1 )
-            {
-                w = qAbs( boundingSize / ( numSamples - 1 ) );
-            }
-
-            width = qwtTransformWidth( map, value, w );
-            width -= d_data->spacing;
-        }
-    }
-
-    return width;
-}
-
-void QwtPlotBarItem::getCanvasMarginHint( const QwtScaleMap &xMap, 
-    const QwtScaleMap &yMap, const QRectF &canvasRect,
-    double &left, double &top, double &right, double &bottom ) const
-{
-    double hint = -1.0;
-
-    switch( layoutPolicy() )
-    {
-        case ScaleSampleToCanvas:
-        {
-            if ( orientation() == Qt::Vertical )
-                hint = 0.5 * canvasRect.width() * d_data->layoutHint;
-            else
-                hint = 0.5 * canvasRect.height() * d_data->layoutHint;
-
-            break;
-        }
-        case FixedSampleSize:
-        {
-            hint = 0.5 * d_data->layoutHint;
-            break;
-        }
-        case AutoAdjustSamples:
-        case ScaleSamplesToAxes:
-        default:
-        {
-            const size_t numSamples = dataSize();
-            if ( numSamples <= 0 )
-                break;
-
-            // doesn't work for nonlinear scales
-
-            const QRectF br = dataRect();
-            double spacing = 0.0;
-            double sampleWidthS = 1.0;
-
-            if ( layoutPolicy() == ScaleSamplesToAxes )
-            {
-                sampleWidthS = qMax( d_data->layoutHint, 0.0 );
-            }
-            else
-            {
-                spacing = d_data->spacing;
-
-                if ( numSamples > 1 )
-                {
-                    sampleWidthS = qAbs( br.width() / ( numSamples - 1 ) );
-                }
-            }
-
-            double ds, w;
-            if ( orientation() == Qt::Vertical )
-            {
-                ds = qAbs( xMap.sDist() );
-                w = canvasRect.width();
-            }
-            else
-            {
-                ds = qAbs( yMap.sDist() );
-                w = canvasRect.height();
-            }
-
-            const double sampleWidthP = ( w - spacing * ds ) 
-                * sampleWidthS / ( ds + sampleWidthS );
-
-            hint = 0.5 * sampleWidthP;
-            hint += qMax( d_data->margin, 0 );
-        }
-    }
-
-    if ( orientation() == Qt::Vertical )
-    {
-        left = right = hint;
-        top = bottom = -1.0; // no hint
-    }
-    else
-    {
-        left = right = -1.0; // no hint
-        top = bottom = hint;
-    }
-}
Index: qwt_plot_panner.cpp
===================================================================
--- qwt_plot_panner.cpp	(revision 382)
+++ qwt_plot_panner.cpp	(working copy)
@@ -10,8 +10,83 @@
 #include "qwt_plot_panner.h"
 #include "qwt_scale_div.h"
 #include "qwt_plot.h"
-#include "qwt_plot_canvas.h"
+#include "qwt_painter.h"
+#include <qbitmap.h>
+#include <qstyle.h>
+#include <qstyleoption.h>
 
+static QBitmap qwtBorderMask( const QWidget *canvas, const QSize &size )
+{
+    const QRect r( 0, 0, size.width(), size.height() );
+
+    QPainterPath borderPath;
+
+    ( void )QMetaObject::invokeMethod( 
+        const_cast< QWidget *>( canvas ), "borderPath", Qt::DirectConnection,
+        Q_RETURN_ARG( QPainterPath, borderPath ), Q_ARG( QRect, r ) );
+
+    if ( borderPath.isEmpty() )
+    {
+        if ( canvas->contentsRect() == canvas->rect() )
+            return QBitmap();
+
+        QBitmap mask( size );
+        mask.fill( Qt::color0 );
+
+        QPainter painter( &mask );
+        painter.fillRect( canvas->contentsRect(), Qt::color1 );
+
+        return mask;
+    }
+
+    QImage image( size, QImage::Format_ARGB32_Premultiplied );
+    image.fill( Qt::color0 );
+
+    QPainter painter( &image );
+    painter.setClipPath( borderPath );
+    painter.fillRect( r, Qt::color1 );
+
+    // now erase the frame
+
+    painter.setCompositionMode( QPainter::CompositionMode_DestinationOut );
+
+    if ( canvas->testAttribute(Qt::WA_StyledBackground ) )
+    {
+        QStyleOptionFrame opt;
+        opt.initFrom(canvas);
+        opt.rect = r;
+        canvas->style()->drawPrimitive( QStyle::PE_Frame, &opt, &painter, canvas );
+    }
+    else
+    {
+        const QVariant borderRadius = canvas->property( "borderRadius" );
+        const QVariant frameWidth = canvas->property( "frameWidth" );
+
+        if ( borderRadius.type() == QVariant::Double 
+            && frameWidth.type() == QVariant::Int )
+        {
+            const double br = borderRadius.toDouble();
+            const int fw = frameWidth.toInt();
+        
+            if ( br > 0.0 && fw > 0 )
+            {
+                painter.setPen( QPen( Qt::color1, fw ) );
+                painter.setBrush( Qt::NoBrush );
+                painter.setRenderHint( QPainter::Antialiasing, true );
+
+                painter.drawPath( borderPath );
+            }
+        }
+    }
+
+    painter.end();
+
+    const QImage mask = image.createMaskFromColor(
+        QColor( Qt::color1 ).rgb(), Qt::MaskOutColor );
+
+    return QBitmap::fromImage( mask );
+}
+
 class QwtPlotPanner::PrivateData
 {
 public:
@@ -25,7 +100,7 @@
 };
 
 /*!
-  \brief Create a plot panner
+  \brief A panner for the canvas of a QwtPlot
 
   The panner is enabled for all axes
 
@@ -33,7 +108,7 @@
 
   \sa setAxisEnabled()
 */
-QwtPlotPanner::QwtPlotPanner( QwtPlotCanvas *canvas ):
+QwtPlotPanner::QwtPlotPanner( QWidget *canvas ):
     QwtPanner( canvas )
 {
     d_data = new PrivateData();
@@ -82,35 +157,35 @@
 }
 
 //! Return observed plot canvas
-QwtPlotCanvas *QwtPlotPanner::canvas()
+QWidget *QwtPlotPanner::canvas()
 {
-    return qobject_cast<QwtPlotCanvas *>( parentWidget() );
+    return parentWidget();
 }
 
 //! Return Observed plot canvas
-const QwtPlotCanvas *QwtPlotPanner::canvas() const
+const QWidget *QwtPlotPanner::canvas() const
 {
-    return qobject_cast<const QwtPlotCanvas *>( parentWidget() );
+    return parentWidget();
 }
 
 //! Return plot widget, containing the observed plot canvas
 QwtPlot *QwtPlotPanner::plot()
 {
-    QwtPlotCanvas *w = canvas();
+    QWidget *w = canvas();
     if ( w )
-        return w->plot();
+        w = w->parentWidget();
 
-    return NULL;
+    return qobject_cast<QwtPlot *>( w );
 }
 
 //! Return plot widget, containing the observed plot canvas
 const QwtPlot *QwtPlotPanner::plot() const
 {
-    const QwtPlotCanvas *w = canvas();
+    const QWidget *w = canvas();
     if ( w )
-        return w->plot();
+        w = w->parentWidget();
 
-    return NULL;
+    return qobject_cast<const QwtPlot *>( w );
 }
 
 /*!
@@ -163,13 +238,38 @@
 }
 
 /*!
-    Calculate a mask from the border mask of the canvas
-    \sa QwtPlotCanvas::borderMask()
+   Calculate a mask from the border path of the canvas
+
+   \return Mask as bitmap
+   \sa QwtPlotCanvas::borderPath()
 */
 QBitmap QwtPlotPanner::contentsMask() const
 {
     if ( canvas() )
-        return canvas()->borderMask( size() );
+        return qwtBorderMask( canvas(), size() );
 
     return QwtPanner::contentsMask();
 }
+
+/*!
+   \return Pixmap with the content of the canvas
+ */
+QPixmap QwtPlotPanner::grab() const
+{   
+    const QWidget *cv = canvas();
+    if ( cv && cv->inherits( "QGLWidget" ) )
+    {
+        // we can't grab from a QGLWidget
+
+        QPixmap pm( cv->size() );
+        QwtPainter::fillPixmap( cv, pm );
+
+        QPainter painter( &pm );
+        const_cast<QwtPlot *>( plot() )->drawCanvas( &painter );
+
+        return pm;
+    }
+
+    return QwtPanner::grab();
+}   
+
Index: qwt_slider.cpp
===================================================================
--- qwt_slider.cpp	(revision 382)
+++ qwt_slider.cpp	(working copy)
@@ -20,56 +20,132 @@
 #include <qstyleoption.h>
 #include <qapplication.h>
 
+static QSize qwtHandleSize( const QSize &size, 
+    Qt::Orientation orientation, bool hasTrough )
+{
+    QSize handleSize = size;
+
+    if ( handleSize.isEmpty() )
+    {
+        const int handleThickness = 16;
+        handleSize.setWidth( 2 * handleThickness );
+        handleSize.setHeight( handleThickness );
+
+        if ( !hasTrough )
+            handleSize.transpose();
+
+        if ( orientation == Qt::Vertical )
+            handleSize.transpose();
+    }
+
+    return handleSize;
+}
+
+static QwtScaleDraw::Alignment qwtScaleDrawAlignment( 
+    Qt::Orientation orientation, QwtSlider::ScalePosition scalePos )
+{
+    QwtScaleDraw::Alignment align;
+
+    if ( orientation == Qt::Vertical )
+    {
+        // NoScale lays out like Left
+        if ( scalePos == QwtSlider::LeadingScale )
+            align = QwtScaleDraw::RightScale;
+        else
+            align = QwtScaleDraw::LeftScale;
+    }
+    else
+    {
+        // NoScale lays out like Bottom
+        if ( scalePos == QwtSlider::TrailingScale )
+            align = QwtScaleDraw::TopScale;
+        else
+            align = QwtScaleDraw::BottomScale;
+    }
+
+    return align;
+}
+
 class QwtSlider::PrivateData
 {
 public:
+    PrivateData():
+        repeatTimerId( 0 ),
+        updateInterval( 150 ),
+        stepsIncrement( 0 ),
+        pendingValueChange( false ),
+        borderWidth( 2 ),
+        spacing( 4 ),
+        scalePosition( QwtSlider::TrailingScale ),
+        hasTrough( true ),
+        hasGroove( false ),
+        mouseOffset( 0 )
+    {
+    }
+
+    int repeatTimerId;
+    bool timerTick;
+    int updateInterval;
+    int stepsIncrement;
+    bool pendingValueChange;
+
     QRect sliderRect;
 
     QSize handleSize;
     int borderWidth;
     int spacing;
 
-    QwtSlider::ScalePos scalePos;
-    QwtSlider::BackgroundStyles bgStyle;
+    Qt::Orientation orientation;
+    QwtSlider::ScalePosition scalePosition;
 
-    /*
-      Scale and values might have different maps. This is
-      confusing and I can't see strong arguments for such
-      a feature. TODO ...
-     */
-    QwtScaleMap map; // linear map
+    bool hasTrough;
+    bool hasGroove;
+
+    int mouseOffset;
+
     mutable QSize sizeHintCache;
 };
+/*!
+  Construct vertical slider in QwtSlider::Trough style
+  with a scale to the left. 
 
+  The scale is initialized to [0.0, 100.0] and the value set to 0.0.
+
+  \param parent Parent widget
+
+  \sa setOrientation(), setScalePosition(), setBackgroundStyle()
+*/
+QwtSlider::QwtSlider( QWidget *parent ):
+    QwtAbstractSlider( parent )
+{
+    initSlider( Qt::Vertical );
+}
+
 /*!
-  \brief Constructor
-  \param parent parent widget
-  \param orientation Orientation of the slider. Can be Qt::Horizontal
-         or Qt::Vertical. Defaults to Qt::Horizontal.
-  \param scalePos Position of the scale.
-         Defaults to QwtSlider::NoScale.
-  \param bgStyle Background style. QwtSlider::Trough draws the
-         slider button in a trough, QwtSlider::Slot draws
-         a slot underneath the button. An or-combination of both
-         may also be used. The default is QwtSlider::Trough.
+  Construct a slider in QwtSlider::Trough style
 
-  QwtSlider enforces valid combinations of its orientation and scale position.
-  If the combination is invalid, the scale position will be set to NoScale.
-  Valid combinations are:
-  - Qt::Horizonal with NoScale, TopScale, or BottomScale;
-  - Qt::Vertical with NoScale, LeftScale, or RightScale.
+  When orientation is Qt::Vertical the scale will be aligned to
+  the left - otherwise at the the top of the slider.
+
+  The scale is initialized to [0.0, 100.0] and the value set to 0.0.
+
+  \param parent Parent widget
+  \param orientation Orientation of the slider. 
 */
-QwtSlider::QwtSlider( QWidget *parent,
-        Qt::Orientation orientation, ScalePos scalePos, 
-        BackgroundStyles bgStyle ):
-    QwtAbstractSlider( orientation, parent )
+QwtSlider::QwtSlider( Qt::Orientation orientation, QWidget *parent ):
+    QwtAbstractSlider( parent )
 {
-    initSlider( orientation, scalePos, bgStyle );
+    initSlider( orientation );
 }
 
-void QwtSlider::initSlider( Qt::Orientation orientation,
-    ScalePos scalePos, BackgroundStyles bgStyle )
+//! Destructor
+QwtSlider::~QwtSlider()
 {
+    delete d_data;
+}
+
+void QwtSlider::initSlider( Qt::Orientation orientation )
+{
     if ( orientation == Qt::Vertical )
         setSizePolicy( QSizePolicy::Fixed, QSizePolicy::Expanding );
     else
@@ -79,97 +155,32 @@
 
     d_data = new QwtSlider::PrivateData;
 
-    d_data->borderWidth = 2;
-    d_data->spacing = 4;
-    d_data->scalePos = scalePos;
-    d_data->bgStyle = bgStyle;
+    d_data->orientation = orientation;
 
-    const int handleThickness = 16;
-    d_data->handleSize.setWidth( 2 * handleThickness );
-    d_data->handleSize.setHeight( handleThickness );
-
-    if ( !( bgStyle & QwtSlider::Trough ) )
-        d_data->handleSize.transpose();
-
-    if ( orientation == Qt::Vertical )
-        d_data->handleSize.transpose();
-
-    d_data->sliderRect.setRect( 0, 0, 8, 8 );
-
-    QwtScaleDraw::Alignment align;
-    if ( orientation == Qt::Vertical )
-    {
-        // enforce a valid combination of scale position and orientation
-        if ( ( d_data->scalePos == QwtSlider::BottomScale ) 
-            || ( d_data->scalePos == QwtSlider::TopScale ) )
-        {
-            d_data->scalePos = NoScale;
-        }
-
-        // adopt the policy of layoutSlider (NoScale lays out like Left)
-        if ( d_data->scalePos == QwtSlider::RightScale )
-            align = QwtScaleDraw::RightScale;
-        else
-            align = QwtScaleDraw::LeftScale;
-    }
-    else
-    {
-        // enforce a valid combination of scale position and orientation
-        if ( ( d_data->scalePos == QwtSlider::LeftScale ) 
-            || ( d_data->scalePos == QwtSlider::RightScale ) )
-        {
-            d_data->scalePos = QwtSlider::NoScale;
-        }
-
-        // adopt the policy of layoutSlider (NoScale lays out like Bottom)
-        if ( d_data->scalePos == QwtSlider::TopScale )
-            align = QwtScaleDraw::TopScale;
-        else
-            align = QwtScaleDraw::BottomScale;
-    }
-
-    scaleDraw()->setAlignment( align );
+    scaleDraw()->setAlignment( 
+        qwtScaleDrawAlignment( orientation, d_data->scalePosition ) );
     scaleDraw()->setLength( 100 );
 
-    setRange( 0.0, 100.0, 1.0 );
+    setScale( 0.0, 100.0 );
     setValue( 0.0 );
 }
 
-QwtSlider::~QwtSlider()
-{
-    delete d_data;
-}
-
 /*!
   \brief Set the orientation.
-  \param o Orientation. Allowed values are Qt::Horizontal and Qt::Vertical.
+  \param orientation Allowed values are Qt::Horizontal and Qt::Vertical.
 
-  If the new orientation and the old scale position are an invalid combination,
-  the scale position will be set to QwtSlider::NoScale.
-  \sa QwtAbstractSlider::orientation()
+  \sa orientation(), scalePosition()
 */
-void QwtSlider::setOrientation( Qt::Orientation o )
+void QwtSlider::setOrientation( Qt::Orientation orientation )
 {
-    if ( o == orientation() )
+    if ( orientation == d_data->orientation )
         return;
 
-    if ( o == Qt::Horizontal )
-    {
-        if ( d_data->scalePos == LeftScale 
-            || d_data->scalePos == RightScale )
-        {
-            d_data->scalePos = NoScale;
-        }
-    }
-    else // if (o == Qt::Vertical)
-    {
-        if ( d_data->scalePos == BottomScale || 
-            d_data->scalePos == TopScale )
-        {
-            d_data->scalePos = NoScale;
-        }
-    }
+    d_data->orientation = orientation;
 
+    scaleDraw()->setAlignment( 
+        qwtScaleDrawAlignment( orientation, d_data->scalePosition ) );
+
     if ( !testAttribute( Qt::WA_WState_OwnSizePolicy ) )
     {
         QSizePolicy sp = sizePolicy();
@@ -179,74 +190,55 @@
         setAttribute( Qt::WA_WState_OwnSizePolicy, false );
     }
 
-    QwtAbstractSlider::setOrientation( o );
-    layoutSlider( true );
+    if ( testAttribute( Qt::WA_WState_Polished ) )
+        layoutSlider( true );
 }
 
 /*!
-  \brief Change the scale position (and slider orientation).
+  \return Orientation
+  \sa setOrientation()
+*/
+Qt::Orientation QwtSlider::orientation() const
+{
+    return d_data->orientation;
+}
 
-  \param scalePos Position of the scale.
+/*!
+  \brief Change the position of the scale
+  \param scalePosition Position of the scale.
 
-  A valid combination of scale position and orientation is enforced:
-  - if the new scale position is Left or Right, the scale orientation will
-    become Qt::Vertical;
-  - if the new scale position is Bottom or Top the scale orientation will
-    become Qt::Horizontal;
-  - if the new scale position is QwtSlider::NoScale, the scale
-    orientation will not change.
+  \sa ScalePosition, scalePosition()
 */
-void QwtSlider::setScalePosition( ScalePos scalePos )
+void QwtSlider::setScalePosition( ScalePosition scalePosition )
 {
-    if ( d_data->scalePos == scalePos )
+    if ( d_data->scalePosition == scalePosition )
         return;
 
-    d_data->scalePos = scalePos;
+    d_data->scalePosition = scalePosition;
+    scaleDraw()->setAlignment( 
+        qwtScaleDrawAlignment( d_data->orientation, scalePosition ) );
 
-    switch ( d_data->scalePos )
-    {
-        case QwtSlider::BottomScale:
-        {
-            setOrientation( Qt::Horizontal );
-            scaleDraw()->setAlignment( QwtScaleDraw::BottomScale );
-            break;
-        }
-        case QwtSlider::TopScale:
-        {
-            setOrientation( Qt::Horizontal );
-            scaleDraw()->setAlignment( QwtScaleDraw::TopScale );
-            break;
-        }
-        case QwtSlider::LeftScale:
-        {
-            setOrientation( Qt::Vertical );
-            scaleDraw()->setAlignment( QwtScaleDraw::LeftScale );
-            break;
-        }
-        case RightScale:
-        {
-            QwtSlider::setOrientation( Qt::Vertical );
-            scaleDraw()->setAlignment( QwtScaleDraw::RightScale );
-            break;
-        }
-        default:
-        {
-            // nothing
-        }
-    }
-
-    layoutSlider( true );
+    if ( testAttribute( Qt::WA_WState_Polished ) )
+        layoutSlider( true );
 }
 
-//! Return the scale position.
-QwtSlider::ScalePos QwtSlider::scalePosition() const
+/*! 
+  \return Position of the scale
+  \sa setScalePosition()
+ */
+QwtSlider::ScalePosition QwtSlider::scalePosition() const
 {
-    return d_data->scalePos;
+    return d_data->scalePosition;
 }
 
 /*!
   \brief Change the slider's border width
+
+  The border width is used for drawing the slider handle and the
+  trough.
+
   \param width Border width
+  \sa borderWidth()
 */
 void QwtSlider::setBorderWidth( int width )
 {
@@ -256,7 +248,9 @@
     if ( width != d_data->borderWidth )
     {
         d_data->borderWidth = width;
-        layoutSlider( true );
+
+        if ( testAttribute( Qt::WA_WState_Polished ) )
+            layoutSlider( true );
     }
 }
 
@@ -270,10 +264,10 @@
 }
 
 /*!
-  \brief Change the spacing between pipe and scale
+  \brief Change the spacing between trough and scale
 
-  A spacing of 0 means, that the backbone of the scale is below
-  the trough.
+  A spacing of 0 means, that the backbone of the scale is covered
+  by the trough.
 
   The default setting is 4 pixels.
 
@@ -288,7 +282,9 @@
     if ( spacing != d_data->spacing  )
     {
         d_data->spacing = spacing;
-        layoutSlider( true );
+
+        if ( testAttribute( Qt::WA_WState_Polished ) )
+            layoutSlider( true );
     }
 }
 
@@ -303,29 +299,22 @@
 
 /*!
   \brief Set the slider's handle size
-  \param width Width
-  \param height Height
 
-  \sa handleSize()
-*/
-void QwtSlider::setHandleSize( int width, int height )
-{
-    setHandleSize( QSize( width, height ) );
-}
+  When the size is empty the slider handle will be painted with a
+  default size depending on its orientation() and backgroundStyle().
 
-/*!
-  \brief Set the slider's handle size
   \param size New size
 
   \sa handleSize()
 */
 void QwtSlider::setHandleSize( const QSize &size )
 {
-    const QSize handleSize = size.expandedTo( QSize( 8, 4 ) );
-    if ( handleSize != d_data->handleSize )
+    if ( size != d_data->handleSize )
     {
-        d_data->handleSize = handleSize;
-        layoutSlider( true );
+        d_data->handleSize = size;
+
+        if ( testAttribute( Qt::WA_WState_Polished ) )
+            layoutSlider( true );
     }
 }
 
@@ -346,7 +335,7 @@
   overload QwtScaleDraw::label().
 
   \param scaleDraw ScaleDraw object, that has to be created with
-                   new and will be deleted in ~QwtSlider or the next
+                   new and will be deleted in ~QwtSlider() or the next
                    call of setScaleDraw().
 
   \sa scaleDraw()
@@ -361,7 +350,9 @@
         scaleDraw->setAlignment( previousScaleDraw->alignment() );
 
     setAbstractScaleDraw( scaleDraw );
-    layoutSlider( true );
+
+    if ( testAttribute( Qt::WA_WState_Polished ) )
+        layoutSlider( true );
 }
 
 /*!
@@ -385,10 +376,36 @@
 //! Notify changed scale
 void QwtSlider::scaleChange()
 {
-    layoutSlider( true );
+    QwtAbstractSlider::scaleChange();
+
+    if ( testAttribute( Qt::WA_WState_Polished ) )
+        layoutSlider( true );
 }
 
 /*!
+  \brief Specify the update interval for automatic scrolling
+
+  The minimal accepted value is 50 ms.
+
+  \param interval Update interval in milliseconds
+
+  \sa setUpdateInterval()
+*/
+void QwtSlider::setUpdateInterval( int interval )
+{
+    d_data->updateInterval = qMax( interval, 50 );
+}
+
+/*!
+  \return Update interval in milliseconds for automatic scrolling
+  \sa setUpdateInterval()
+ */
+int QwtSlider::updateInterval() const
+{
+    return d_data->updateInterval;
+}
+
+/*!
    Draw the slider into the specified rectangle.
 
    \param painter Painter
@@ -399,155 +416,246 @@
 {
     QRect innerRect( sliderRect );
 
-    if ( d_data->bgStyle & QwtSlider::Trough )
+    if ( d_data->hasTrough )
     {
         const int bw = d_data->borderWidth;
+        innerRect = sliderRect.adjusted( bw, bw, -bw, -bw );
 
+        painter->fillRect( innerRect, palette().brush( QPalette::Mid ) );
         qDrawShadePanel( painter, sliderRect, palette(), true, bw, NULL );
-
-        innerRect = sliderRect.adjusted( bw, bw, -bw, -bw );
-        painter->fillRect( innerRect, palette().brush( QPalette::Mid ) );
     }
 
-    if ( d_data->bgStyle & QwtSlider::Groove )
+    const QSize handleSize = qwtHandleSize( d_data->handleSize,
+        d_data->orientation, d_data->hasTrough );
+
+    if ( d_data->hasGroove )
     {
-        int ws = 4;
-        int ds = d_data->handleSize.width() / 2 - 4;
-        if ( ds < 1 )
-            ds = 1;
+        const int slotExtent = 4;
+        const int slotMargin = 4;
 
-        QRect rSlot;
+        QRect slotRect; 
         if ( orientation() == Qt::Horizontal )
         {
-            if ( innerRect.height() & 1 )
-                ws++;
+            int slotOffset = qMax( 1, handleSize.width() / 2 - slotMargin );
+            int slotHeight = slotExtent + ( innerRect.height() % 2 );
 
-            rSlot = QRect( innerRect.x() + ds,
-                    innerRect.y() + ( innerRect.height() - ws ) / 2,
-                    innerRect.width() - 2 * ds, ws );
+            slotRect.setWidth( innerRect.width() - 2 * slotOffset );
+            slotRect.setHeight( slotHeight );
         }
         else
         {
-            if ( innerRect.width() & 1 )
-                ws++;
+            int slotOffset = qMax( 1, handleSize.height() / 2 - slotMargin );
+            int slotWidth = slotExtent + ( innerRect.width() % 2 );
 
-            rSlot = QRect( innerRect.x() + ( innerRect.width() - ws ) / 2,
-                           innerRect.y() + ds,
-                           ws, innerRect.height() - 2 * ds );
+            slotRect.setWidth( slotWidth );
+            slotRect.setHeight( innerRect.height() - 2 * slotOffset );
+
         }
 
+        slotRect.moveCenter( innerRect.center() );
+
         QBrush brush = palette().brush( QPalette::Dark );
-        qDrawShadePanel( painter, rSlot, palette(), true, 1 , &brush );
+        qDrawShadePanel( painter, slotRect, palette(), true, 1 , &brush );
     }
 
     if ( isValid() )
-        drawHandle( painter, innerRect, transform( value() ) );
+        drawHandle( painter, handleRect(), transform( value() ) );
 }
 
 /*!
   Draw the thumb at a position
 
   \param painter Painter
-  \param sliderRect Bounding rectangle of the slider
-  \param pos Position of the slider thumb
+  \param handleRect Bounding rectangle of the handle
+  \param pos Position of the handle marker in widget coordinates
 */
 void QwtSlider::drawHandle( QPainter *painter, 
-    const QRect &sliderRect, int pos ) const
+    const QRect &handleRect, int pos ) const
 {
     const int bw = d_data->borderWidth;
 
+    qDrawShadePanel( painter, 
+        handleRect, palette(), false, bw,
+        &palette().brush( QPalette::Button ) );
+
     pos++; // shade line points one pixel below
     if ( orientation() == Qt::Horizontal )
     {
-        QRect handleRect(
-            pos - d_data->handleSize.width() / 2,
-            sliderRect.y(), 
-            d_data->handleSize.width(), 
-            sliderRect.height()
-        );
-
-        qDrawShadePanel( painter, 
-            handleRect, palette(), false, bw,
-            &palette().brush( QPalette::Button ) );
-
-        qDrawShadeLine( painter, pos, sliderRect.top() + bw,
-            pos, sliderRect.bottom() - bw,
-            palette(), true, 1 );
+        qDrawShadeLine( painter, pos, handleRect.top() + bw,
+            pos, handleRect.bottom() - bw, palette(), true, 1 );
     }
     else // Vertical
     {
-        QRect handleRect(
-            sliderRect.left(), 
-            pos - d_data->handleSize.height() / 2,
-            sliderRect.width(), 
-            d_data->handleSize.height()
-        );
+        qDrawShadeLine( painter, handleRect.left() + bw, pos,
+            handleRect.right() - bw, pos, palette(), true, 1 );
+    }
+}
 
-        qDrawShadePanel( painter, 
-            handleRect, palette(), false, bw,
-            &palette().brush( QPalette::Button ) );
+/*!
+  \brief Determine what to do when the user presses a mouse button.
 
-        qDrawShadeLine( painter, sliderRect.left() + bw, pos,
-            sliderRect.right() - bw, pos,
-            palette(), true, 1 );
+  \param pos Mouse position
+
+  \retval True, when handleRect() contains pos 
+  \sa scrolledTo()
+*/
+bool QwtSlider::isScrollPosition( const QPoint &pos ) const
+{
+    if ( handleRect().contains( pos ) )
+    {
+        const double v = ( orientation() == Qt::Horizontal ) 
+            ? pos.x() : pos.y();
+
+        d_data->mouseOffset = v - transform( value() );
+        return true;
     }
+
+    return false;
 }
 
 /*!
-   Map and round a value into widget coordinates
-   \param value Value
+  \brief Determine the value for a new position of the
+         slider handle.
+
+  \param pos Mouse position
+
+  \return Value for the mouse position
+  \sa isScrollPosition()
 */
-int QwtSlider::transform( double value ) const
+double QwtSlider::scrolledTo( const QPoint &pos ) const
 {
-    return qRound( d_data->map.transform( value ) );
+    int p = ( orientation() == Qt::Horizontal ) 
+        ? pos.x() : pos.y();
+
+    p -= d_data->mouseOffset;
+
+    int min = transform( lowerBound() );
+    int max = transform( upperBound() );
+    if ( min > max )
+        qSwap( min, max );
+
+    p = qBound( min, p, max );
+
+    return invTransform( p );
 }
 
 /*!
-   Determine the value corresponding to a specified mouse location.
-   \param pos Mouse position
+   Mouse press event handler
+   \param event Mouse event
 */
-double QwtSlider::getValue( const QPoint &pos )
+void QwtSlider::mousePressEvent( QMouseEvent *event )
 {
-    return d_data->map.invTransform(
-        orientation() == Qt::Horizontal ? pos.x() : pos.y() );
+    if ( isReadOnly() )
+    {
+        event->ignore();
+        return;
+    }
+
+    const QPoint pos = event->pos();
+
+    if ( isValid() && d_data->sliderRect.contains( pos ) )
+    {
+        if ( !handleRect().contains( pos ) )
+        {
+            const int markerPos = transform( value() );
+
+            d_data->stepsIncrement = pageSteps();
+
+            if ( d_data->orientation == Qt::Horizontal )
+            {
+                if ( pos.x() < markerPos )
+                    d_data->stepsIncrement = -d_data->stepsIncrement;
+            }
+            else
+            {
+                if ( pos.y() < markerPos )
+                    d_data->stepsIncrement = -d_data->stepsIncrement;
+            }
+
+            if ( isInverted() )
+                d_data->stepsIncrement = -d_data->stepsIncrement;
+
+            d_data->timerTick = false;
+            d_data->repeatTimerId = startTimer( qMax( 250, 2 * updateInterval() ) );
+
+            return;
+        }
+    }
+
+    QwtAbstractSlider::mousePressEvent( event );
 }
 
 /*!
-  \brief Determine scrolling mode and direction
-  \param p point
-  \param scrollMode Scrolling mode
-  \param direction Direction
+   Mouse release event handler
+   \param event Mouse event
 */
-void QwtSlider::getScrollMode( const QPoint &p,
-    QwtAbstractSlider::ScrollMode &scrollMode, int &direction ) const
+void QwtSlider::mouseReleaseEvent( QMouseEvent *event )
 {
-    if ( !d_data->sliderRect.contains( p ) )
+    if ( d_data->repeatTimerId > 0 )
     {
-        scrollMode = QwtAbstractSlider::ScrNone;
-        direction = 0;
-        return;
+        killTimer( d_data->repeatTimerId );
+        d_data->repeatTimerId = 0;
+        d_data->timerTick = false;
+        d_data->stepsIncrement = 0;
     }
 
-    const int pos = ( orientation() == Qt::Horizontal ) ? p.x() : p.y();
-    const int markerPos = transform( value() );
+    if ( d_data->pendingValueChange )
+    {
+        d_data->pendingValueChange = false;
+        Q_EMIT valueChanged( value() );
+    }
 
-    if ( ( pos > markerPos - d_data->handleSize.width() / 2 )
-        && ( pos < markerPos + d_data->handleSize.width() / 2 ) )
+    QwtAbstractSlider::mouseReleaseEvent( event );
+}
+
+/*!
+   Timer event handler
+
+   Handles the timer, when the mouse stays pressed
+   inside the sliderRect().
+
+   \param event Mouse event
+*/  
+void QwtSlider::timerEvent( QTimerEvent *event )
+{
+    if ( event->timerId() != d_data->repeatTimerId )
     {
-        scrollMode = QwtAbstractSlider::ScrMouse;
-        direction = 0;
+        QwtAbstractSlider::timerEvent( event );
         return;
     }
 
-    scrollMode = QwtAbstractSlider::ScrPage;
-    direction = ( pos > markerPos ) ? 1 : -1;
+    if ( !isValid() )
+    {
+        killTimer( d_data->repeatTimerId );
+        d_data->repeatTimerId = 0;
+        return;
+    }
 
-    if ( scaleDraw()->scaleMap().p1() > scaleDraw()->scaleMap().p2() )
-        direction = -direction;
+    const double v = value();
+    incrementValue( d_data->stepsIncrement );
+
+    if ( v != value() )
+    {
+        if ( isTracking() )
+            Q_EMIT valueChanged( value() );
+        else
+            d_data->pendingValueChange = true;
+
+        Q_EMIT sliderMoved( value() );
+    }
+
+    if ( !d_data->timerTick )
+    {
+        // restart the timer with a shorter interval
+        killTimer( d_data->repeatTimerId );
+        d_data->repeatTimerId = startTimer( updateInterval() );
+        
+        d_data->timerTick = true;
+    }   
 }
 
 /*!
-   Qt paint event
+   Qt paint event handler
    \param event Paint event
 */
 void QwtSlider::paintEvent( QPaintEvent *event )
@@ -559,7 +667,7 @@
     opt.init(this);
     style()->drawPrimitive(QStyle::PE_Widget, &opt, &painter, this);
 
-    if ( d_data->scalePos != QwtSlider::NoScale )
+    if ( d_data->scalePosition != QwtSlider::NoScale )
     {
         if ( !d_data->sliderRect.contains( event->rect() ) )
             scaleDraw()->draw( &painter, palette() );
@@ -571,128 +679,140 @@
         QwtPainter::drawFocusRect( &painter, this, d_data->sliderRect );
 }
 
-//! Qt resize event
-void QwtSlider::resizeEvent( QResizeEvent * )
+/*!
+   Qt resize event handler
+   \param event Resize event
+*/
+void QwtSlider::resizeEvent( QResizeEvent *event )
 {
+    Q_UNUSED( event );
+
     layoutSlider( false );
 }
 
-//! Qt change event handler
+/*!
+   Handles QEvent::StyleChange and QEvent::FontChange events
+   \param event Change event
+*/
 void QwtSlider::changeEvent( QEvent *event )
 {
-    switch( event->type() )
+    if ( event->type() == QEvent::StyleChange || 
+        event->type() == QEvent::FontChange )
     {
-        case QEvent::StyleChange:
-        case QEvent::FontChange:
+        if ( testAttribute( Qt::WA_WState_Polished ) )
             layoutSlider( true );
-            break;
-        default: 
-            break;
     }
+
+    QwtAbstractSlider::changeEvent( event );
 }
 
 /*!
   Recalculate the slider's geometry and layout based on
-  the current rect and fonts.
+  the current geometry and fonts.
+
   \param update_geometry  notify the layout system and call update
          to redraw the scale
 */
 void QwtSlider::layoutSlider( bool update_geometry )
 {
-    int handleThickness;
-    if ( orientation() == Qt::Horizontal )
-        handleThickness = d_data->handleSize.width();
-    else
-        handleThickness = d_data->handleSize.height();
+    int bw = 0;
+    if ( d_data->hasTrough )
+        bw = d_data->borderWidth;
 
-    int sld1 = handleThickness / 2 - 1;
-    int sld2 = handleThickness / 2 + handleThickness % 2;
+    const QSize handleSize = qwtHandleSize( d_data->handleSize,
+        d_data->orientation, d_data->hasTrough );
 
-    if ( d_data->bgStyle & QwtSlider::Trough )
-    {
-        sld1 += d_data->borderWidth;
-        sld2 += d_data->borderWidth;
-    }
+    QRect sliderRect = contentsRect();
 
-    int scd = 0;
-    if ( d_data->scalePos != QwtSlider::NoScale )
+    /*
+       The marker line of the handle needs to be aligned to
+       the scale. But the marker is in the center 
+       and we need space enough to display the rest of the handle.
+
+       But the scale itself usually needs margins for displaying
+       the tick labels, that also might needs space beyond the
+       backbone.
+
+       Now it depends on what needs more margins. If it is the
+       slider the scale gets shrunk, otherwise the slider.
+     */
+
+    int scaleMargin = 0;
+    if ( d_data->scalePosition != QwtSlider::NoScale )
     {
         int d1, d2;
         scaleDraw()->getBorderDistHint( font(), d1, d2 );
-        scd = qMax( d1, d2 );
+
+        scaleMargin = qMax( d1, d2 ) - bw;
     }
 
-    int slo = scd - sld1;
-    if ( slo < 0 )
-        slo = 0;
+    int scaleX, scaleY, scaleLength;
 
-    int x, y, length;
-    QRect sliderRect;
+    if ( d_data->orientation == Qt::Horizontal )
+    {
+        const int handleMargin = handleSize.width() / 2 - 1;
+        if ( scaleMargin > handleMargin )
+        {
+            int off = scaleMargin - handleMargin;
+            sliderRect.adjust( off, 0, -off, 0 );
+        }
 
-    length = x = y = 0;
+        scaleX = sliderRect.left() + bw + handleSize.width() / 2 - 1;
+        scaleLength = sliderRect.width() - handleSize.width();
+    }
+    else
+    {
+        int handleMargin = handleSize.height() / 2 - 1;
+        if ( scaleMargin > handleMargin )
+        {
+            int off = scaleMargin - handleMargin;
+            sliderRect.adjust( 0, off, 0, -off );
+        }
 
-    const QRect cr = contentsRect();
-    if ( orientation() == Qt::Horizontal )
+        scaleY = sliderRect.top() + bw + handleSize.height() / 2 - 1;
+        scaleLength = sliderRect.height() - handleSize.height();
+    }
+
+    scaleLength -= 2 * bw;
+
+    // now align slider and scale according to the ScalePosition
+
+    if ( d_data->orientation == Qt::Horizontal )
     {
-        int sh = d_data->handleSize.height();
-        if ( d_data->bgStyle & QwtSlider::Trough )
-            sh += 2 * d_data->borderWidth;
+        const int h = handleSize.height() + 2 * bw;
 
-        sliderRect.setLeft( cr.left() + slo );
-        sliderRect.setRight( cr.right() - slo );
-        sliderRect.setTop( cr.top() );
-        sliderRect.setBottom( cr.top() + sh - 1);
-
-        if ( d_data->scalePos == QwtSlider::BottomScale )
+        if ( d_data->scalePosition == QwtSlider::TrailingScale )
         {
-            y = sliderRect.bottom() + d_data->spacing;
+            sliderRect.setTop( sliderRect.bottom() + 1 - h );
+            scaleY = sliderRect.top() - d_data->spacing;
         }
-        else if ( d_data->scalePos == QwtSlider::TopScale )
+        else
         {
-            sliderRect.setTop( cr.bottom() - sh + 1 );
-            sliderRect.setBottom( cr.bottom() );
-
-            y = sliderRect.top() - d_data->spacing;
+            sliderRect.setHeight( h );
+            scaleY = sliderRect.bottom() + 1 + d_data->spacing;
         }
-
-        x = sliderRect.left() + sld1;
-        length = sliderRect.width() - ( sld1 + sld2 );
     }
     else // Qt::Vertical
     {
-        int sw = d_data->handleSize.width();
-        if ( d_data->bgStyle & QwtSlider::Trough )
-            sw += 2 * d_data->borderWidth;
+        const int w = handleSize.width() + 2 * bw;
 
-        sliderRect.setLeft( cr.right() - sw + 1 );
-        sliderRect.setRight( cr.right() );
-        sliderRect.setTop( cr.top() + slo );
-        sliderRect.setBottom( cr.bottom() - slo );
-
-        if ( d_data->scalePos == QwtSlider::LeftScale )
+        if ( d_data->scalePosition == QwtSlider::LeadingScale )
         {
-            x = sliderRect.left() - d_data->spacing;
+            sliderRect.setWidth( w );
+            scaleX = sliderRect.right() + 1 + d_data->spacing;
         }
-        else if ( d_data->scalePos == QwtSlider::RightScale )
+        else
         {
-            sliderRect.setLeft( cr.left() );
-            sliderRect.setRight( cr.left() + sw - 1);
-
-            x = sliderRect.right() + d_data->spacing;
+            sliderRect.setLeft( sliderRect.right() + 1 - w );
+            scaleX = sliderRect.left() - d_data->spacing;
         }
-
-        y = sliderRect.top() + sld1;
-        length = sliderRect.height() - ( sld1 + sld2 );
     }
 
     d_data->sliderRect = sliderRect;
 
-    scaleDraw()->move( x, y );
-    scaleDraw()->setLength( length );
+    scaleDraw()->move( scaleX, scaleY );
+    scaleDraw()->setLength( scaleLength );
 
-    d_data->map.setPaintInterval( scaleDraw()->scaleMap().p1(),
-        scaleDraw()->scaleMap().p2() );
-
     if ( update_geometry )
     {
         d_data->sizeHintCache = QSize(); // invalidate
@@ -701,45 +821,66 @@
     }
 }
 
-//! Notify change of value
-void QwtSlider::valueChange()
-{
-    QwtAbstractSlider::valueChange();
-    update();
-}
+/*!
+  En/Disable the trough
 
+  The slider can be cutomized by showing a trough for the
+  handle.
 
-//! Notify change of range
-void QwtSlider::rangeChange()
+  \param on When true, the groove is visible
+  \sa hasTrough(), setGroove()
+ */
+void QwtSlider::setTrough( bool on )
 {
-    d_data->map.setScaleInterval( minValue(), maxValue() );
+    if ( d_data->hasTrough != on )
+    {
+        d_data->hasTrough = on;
 
-    if ( autoScale() )
-        rescale( minValue(), maxValue() );
-
-    QwtAbstractSlider::rangeChange();
-    layoutSlider( true );
+        if ( testAttribute( Qt::WA_WState_Polished ) )
+            layoutSlider( true );
+    }
 }
 
 /*!
-  Set the background style.
-*/
-void QwtSlider::setBackgroundStyle( BackgroundStyles style )
+  \return True, when the trough is visisble
+  \sa setTrough(), hasGroove()
+ */
+bool QwtSlider::hasTrough() const
 {
-    d_data->bgStyle = style;
-    layoutSlider( true );
+    return d_data->hasTrough;
 }
 
 /*!
-  \return the background style.
-*/
-QwtSlider::BackgroundStyles QwtSlider::backgroundStyle() const
+  En/Disable the groove
+
+  The slider can be cutomized by showing a groove for the
+  handle.
+
+  \param on When true, the groove is visible
+  \sa hasGroove(), setThrough()
+ */
+void QwtSlider::setGroove( bool on )
 {
-    return d_data->bgStyle;
+    if ( d_data->hasGroove != on )
+    {
+        d_data->hasGroove = on;
+        
+        if ( testAttribute( Qt::WA_WState_Polished ) )
+            layoutSlider( true );
+    }
 }
 
 /*!
-  \return QwtSlider::minimumSizeHint()
+  \return True, when the groove is visisble
+  \sa setGroove(), hasTrough()
+ */
+bool QwtSlider::hasGroove() const
+{
+    return d_data->hasGroove;
+} 
+
+/*!
+  \return minimumSizeHint()
 */
 QSize QwtSlider::sizeHint() const
 {
@@ -748,52 +889,65 @@
 }
 
 /*!
-  \brief Return a minimum size hint
-  \warning The return value of QwtSlider::minimumSizeHint() depends on
-           the font and the scale.
+  \return Minimum size hint
+  \sa sizeHint()
 */
 QSize QwtSlider::minimumSizeHint() const
 {
     if ( !d_data->sizeHintCache.isEmpty() )
         return d_data->sizeHintCache;
 
-    const int minLength = 84; // from QSlider
+    const QSize handleSize = qwtHandleSize( d_data->handleSize,
+        d_data->orientation, d_data->hasTrough );
 
-    int handleLength = d_data->handleSize.width();
-    int handleThickness = d_data->handleSize.height();
+    int bw = 0;
+    if ( d_data->hasTrough )
+        bw = d_data->borderWidth;
 
-    if ( orientation() == Qt::Vertical )
-        qSwap( handleLength, handleThickness );
+    int sliderLength = 0; 
+    int scaleExtent = 0;
 
-    int w = minLength; 
-    int h = handleThickness;
-
-    if ( d_data->scalePos != QwtSlider::NoScale )
+    if ( d_data->scalePosition != QwtSlider::NoScale )
     {
         int d1, d2;
         scaleDraw()->getBorderDistHint( font(), d1, d2 );
 
-        const int sdBorderDist = 2 * qMax( d1, d2 );
-        const int sdExtent = qCeil( scaleDraw()->extent( font() ) );
-        const int sdLength = scaleDraw()->minLength( font() );
+        const int scaleBorderDist = 2 * ( qMax( d1, d2 ) - bw );
 
-        int l = sdLength;
-        if ( handleLength > sdBorderDist )
+        int handleBorderDist;
+        if ( d_data->orientation == Qt::Horizontal )
+            handleBorderDist = handleSize.width();
+        else
+            handleBorderDist = handleSize.height();
+
+        sliderLength = scaleDraw()->minLength( font() );
+        if ( handleBorderDist > scaleBorderDist )
         {
             // We need additional space for the overlapping handle
-            l += handleLength - sdBorderDist;
+            sliderLength += handleBorderDist - scaleBorderDist;
         }
 
-        w = qMax( l, w );
-        h += sdExtent + d_data->spacing;
+        scaleExtent += d_data->spacing;
+        scaleExtent += qCeil( scaleDraw()->extent( font() ) );
     }
 
-    if ( d_data->bgStyle & QwtSlider::Trough )
-        h += 2 * d_data->borderWidth;
+    sliderLength = qMax( sliderLength, 84 ); // from QSlider
 
-    if ( orientation() == Qt::Vertical )
-        qSwap( w, h );
+    int w = 0;
+    int h = 0;
 
+    if ( d_data->orientation == Qt::Horizontal )
+    {
+        w = sliderLength;
+        h = handleSize.height() + 2 * bw + scaleExtent;
+    }
+    else
+    {
+        w = handleSize.width() + 2 * bw + scaleExtent;
+        h = sliderLength;
+    }
+
+    // finally add margins
     int left, right, top, bottom;
     getContentsMargins( &left, &top, &right, &bottom );
 
@@ -803,3 +957,35 @@
     d_data->sizeHintCache = QSize( w, h );
     return d_data->sizeHintCache;
 }
+
+/*!
+   \return Bounding rectangle of the slider handle
+ */
+QRect QwtSlider::handleRect() const
+{
+    if ( !isValid() )
+        return QRect();
+
+    const int markerPos = transform( value() );
+
+    QPoint center = d_data->sliderRect.center();
+    if ( d_data->orientation == Qt::Horizontal )
+        center.setX( markerPos );
+    else
+        center.setY( markerPos );
+
+    QRect rect;
+    rect.setSize( qwtHandleSize( d_data->handleSize,
+        d_data->orientation, d_data->hasTrough ) );
+    rect.moveCenter( center );
+
+    return rect;
+}
+
+/*!
+ \return Bounding rectangle of the slider - without the scale
+ */
+QRect QwtSlider::sliderRect() const
+{
+    return d_data->sliderRect;
+}
Index: qwt_matrix_raster_data.h
===================================================================
--- qwt_matrix_raster_data.h	(revision 382)
+++ qwt_matrix_raster_data.h	(working copy)
@@ -51,12 +51,15 @@
     ResampleMode resampleMode() const;
 
     virtual void setInterval( Qt::Axis, const QwtInterval & );
-    void setValueMatrix( const QVector<double> &values, size_t numColumns );
-    
+
+    void setValueMatrix( const QVector<double> &values, int numColumns );
     const QVector<double> valueMatrix() const;
-    size_t numColumns() const;
-    size_t numRows() const;
 
+    void setValue( int row, int col, double value );
+
+    int numColumns() const;
+    int numRows() const;
+
     virtual QRectF pixelHint( const QRectF & ) const;
 
     virtual double value( double x, double y ) const;
Index: qwt_interval.cpp
===================================================================
--- qwt_interval.cpp	(revision 382)
+++ qwt_interval.cpp	(working copy)
@@ -12,12 +12,12 @@
 #include <qalgorithms.h>
 
 /*!
-   \brief Normalize the limits of the interval
+  \brief Normalize the limits of the interval
 
-   If maxValue() < minValue() the limits will be inverted.
-   \return Normalized interval
+  If maxValue() < minValue() the limits will be inverted.
+  \return Normalized interval
 
-   \sa isValid(), inverted()
+  \sa isValid(), inverted()
 */
 QwtInterval QwtInterval::normalized() const
 {
@@ -34,9 +34,9 @@
 }
 
 /*!
-   Invert the limits of the interval
-   \return Inverted interval
-   \sa normalized()
+  Invert the limits of the interval
+  \return Inverted interval
+  \sa normalized()
 */
 QwtInterval QwtInterval::inverted() const
 {
@@ -130,7 +130,12 @@
     return united;
 }
 
-//! Intersect 2 intervals
+/*! 
+  \brief Intersect 2 intervals
+  
+  \param other Interval to be intersect with
+  \return Intersection
+ */
 QwtInterval QwtInterval::intersect( const QwtInterval &other ) const
 {
     if ( !other.isValid() || !isValid() )
@@ -192,22 +197,35 @@
     return intersected;
 }
 
-//! Unites this interval with the given interval.
-QwtInterval& QwtInterval::operator|=( const QwtInterval & interval )
+/*! 
+  \brief Unite this interval with the given interval.
+
+  \param other Interval to be united with
+  \return This interval
+ */
+QwtInterval& QwtInterval::operator|=( const QwtInterval &other )
 {
-    *this = *this | interval;
+    *this = *this | other;
     return *this;
 }
 
-//! Intersects this interval with the given interval.
-QwtInterval& QwtInterval::operator&=( const QwtInterval & interval )
+/*! 
+  \brief Intersect this interval with the given interval.
+
+  \param other Interval to be intersected with
+  \return This interval
+ */
+QwtInterval& QwtInterval::operator&=( const QwtInterval &other )
 {
-    *this = *this & interval;
+    *this = *this & other;
     return *this;
 }
 
 /*!
-   Test if two intervals overlap
+  \brief Test if two intervals overlap
+
+  \param other Interval
+  \return True, when the intervals are intersecting
 */
 bool QwtInterval::intersects( const QwtInterval &other ) const
 {
@@ -243,11 +261,11 @@
 }
 
 /*!
-   Adjust the limit that is closer to value, so that value becomes
-   the center of the interval.
+  Adjust the limit that is closer to value, so that value becomes
+  the center of the interval.
 
-   \param value Center
-   \return Interval with value as center
+  \param value Center
+  \return Interval with value as center
 */
 QwtInterval QwtInterval::symmetrize( double value ) const
 {
@@ -261,12 +279,12 @@
 }
 
 /*!
-   Limit the interval, keeping the border modes
+  Limit the interval, keeping the border modes
 
-   \param lowerBound Lower limit
-   \param upperBound Upper limit
+  \param lowerBound Lower limit
+  \param upperBound Upper limit
 
-   \return Limited interval
+  \return Limited interval
 */
 QwtInterval QwtInterval::limited( double lowerBound, double upperBound ) const
 {
@@ -283,15 +301,17 @@
 }
 
 /*!
-   Extend the interval
+  \brief Extend the interval
 
-   If value is below minValue, value becomes the lower limit.
-   If value is above maxValue, value becomes the upper limit.
+  If value is below minValue(), value becomes the lower limit.
+  If value is above maxValue(), value becomes the upper limit.
 
-   extend has no effect for invalid intervals
+  extend() has no effect for invalid intervals
 
-   \param value Value
-   \sa isValid()
+  \param value Value
+  \return extended interval
+
+  \sa isValid()
 */
 QwtInterval QwtInterval::extend( double value ) const
 {
@@ -303,12 +323,12 @@
 }
 
 /*!
-   Extend an interval
+  Extend an interval
 
-   \param value Value
-   \return Reference of the extended interval
+  \param value Value
+  \return Reference of the extended interval
 
-   \sa extend()
+  \sa extend()
 */
 QwtInterval& QwtInterval::operator|=( double value )
 {
Index: qwt_plot_spectrogram.cpp
===================================================================
--- qwt_plot_spectrogram.cpp	(revision 382)
+++ qwt_plot_spectrogram.cpp	(working copy)
@@ -33,7 +33,9 @@
         displayMode = ImageMode;
 
         conrecFlags = QwtRasterData::IgnoreAllVerticesOnLevel;
+#if 0
         conrecFlags |= QwtRasterData::IgnoreOutOfRange;
+#endif
     }
     ~PrivateData()
     {
@@ -153,6 +155,25 @@
     return d_data->colorMap;
 }
 
+/*! 
+  Build and assign the default pen for the contour lines
+    
+  In Qt5 the default pen width is 1.0 ( 0.0 in Qt4 ) what makes it
+  non cosmetic ( see QPen::isCosmetic() ). This method has been introduced
+  to hide this incompatibility.
+    
+  \param color Pen color
+  \param width Pen width
+  \param style Pen style
+    
+  \sa pen(), brush()
+ */ 
+void QwtPlotSpectrogram::setDefaultContourPen( 
+    const QColor &color, qreal width, Qt::PenStyle style )
+{   
+    setDefaultContourPen( QPen( color, width, style ) );
+}
+
 /*!
    \brief Set the default pen for the contour lines
 
@@ -236,6 +257,8 @@
    \param flag CONREC flag
    \return true, is enabled
 
+   The default setting enables QwtRasterData::IgnoreAllVerticesOnLevel
+
    \sa setConrecClag(), renderContourLines(),
        QwtRasterData::contourLines()
 */
@@ -264,7 +287,7 @@
 }
 
 /*!
-   \brief Return the levels of the contour lines.
+   \return Levels of the contour lines.
 
    The levels are sorted in increasing order.
 
@@ -356,7 +379,7 @@
 /*!
    \brief Render an image from data and color map.
 
-   For each pixel of rect the value is mapped into a color.
+   For each pixel of area the value is mapped into a color.
 
   \param xMap X-Scale Map
   \param yMap Y-Scale Map
@@ -493,14 +516,14 @@
 /*!
    \brief Return the raster to be used by the CONREC contour algorithm.
 
-   A larger size will improve the precisision of the CONREC algorithm,
+   A larger size will improve the precision of the CONREC algorithm,
    but will slow down the time that is needed to calculate the lines.
 
    The default implementation returns rect.size() / 2 bounded to
    the resolution depending on pixelSize().
 
-   \param area Rect, where to calculate the contour lines
-   \param rect Rect in pixel coordinates, where to paint the contour lines
+   \param area Rectangle, where to calculate the contour lines
+   \param rect Rectangle in pixel coordinates, where to paint the contour lines
    \return Raster to be used by the CONREC contour algorithm.
 
    \note The size will be bounded to rect.size().
@@ -528,6 +551,7 @@
 
    \param rect Rectangle, where to calculate the contour lines
    \param raster Raster, used by the CONREC algorithm
+   \return Calculated contour lines
 
    \sa contourLevels(), setConrecFlag(),
        QwtRasterData::contourLines()
@@ -559,8 +583,6 @@
     if ( d_data->data == NULL )
         return;
 
-    const QwtInterval intensityRange = d_data->data->interval( Qt::ZAxis );
-
     const int numLevels = d_data->contourLevels.size();
     for ( int l = 0; l < numLevels; l++ )
     {
@@ -594,7 +616,7 @@
   \param painter Painter
   \param xMap Maps x-values into pixel coordinates.
   \param yMap Maps y-values into pixel coordinates.
-  \param canvasRect Contents rect of the canvas in painter coordinates
+  \param canvasRect Contents rectangle of the canvas in painter coordinates
 
   \sa setDisplayMode(), renderImage(),
       QwtPlotRasterItem::draw(), drawContourLines()
Index: qwt_abstract_legend.h
===================================================================
--- qwt_abstract_legend.h	(revision 382)
+++ qwt_abstract_legend.h	(working copy)
@@ -15,7 +15,7 @@
 #include <qframe.h>
 #include <qlist.h>
 
-class QwtPlotItem;
+class QVariant;
 
 /*!
   \brief Abstract base class for legend widgets
@@ -61,10 +61,10 @@
     /*!
       \brief Update the entries for a plot item
 
-      \param plotItem Plot items
-      \param data List of legend entry attributes of plotItem
+      \param itemInfo Info about an item
+      \param data List of legend entry attributes for the  item
      */
-    virtual void updateLegend( const QwtPlotItem *plotItem, 
+    virtual void updateLegend( const QVariant &itemInfo, 
         const QList<QwtLegendData> &data ) = 0;
 };
 
Index: qwt_series_data.h
===================================================================
--- qwt_series_data.h	(revision 382)
+++ qwt_series_data.h	(working copy)
@@ -38,7 +38,7 @@
      Should return the bounding rectangle of the data series.
      It is used for autoscaling and might help certain algorithms for displaying
      the data. You can use qwtBoundingRect() for an implementation
-     but often it is possible to implement a more efficient alogrithm 
+     but often it is possible to implement a more efficient algorithm 
      depending on the characteristics of the series.
      The member d_boundingRect is intended for caching the calculated rectangle.
     
@@ -47,7 +47,10 @@
 class QwtSeriesData
 {
 public:
+    //! Constructor
     QwtSeriesData();
+
+    //! Destructor
     virtual ~QwtSeriesData();
 
     //! \return Number of samples
@@ -68,12 +71,25 @@
 
        qwtBoundingRect(...) offers slow implementations iterating
        over the samples. For large sets it is recommended to implement
-       something faster f.e. by caching the bounding rect.
+       something faster f.e. by caching the bounding rectangle.
+
+       \return Bounding rectangle
      */
     virtual QRectF boundingRect() const = 0;
 
-    virtual void setRectOfInterest( const QRectF & );
+    /*!
+       Set a the "rect of interest"
 
+       QwtPlotSeriesItem defines the current area of the plot canvas
+       as "rectangle of interest" ( QwtPlotSeriesItem::updateScaleDiv() ).
+       It can be used to implement different levels of details.
+
+       The default implementation does nothing.
+   
+       \param rect Rectangle of interest
+    */
+    virtual void setRectOfInterest( const QRectF &rect );
+
 protected:
     //! Can be used to cache a calculated bounding rectangle
     mutable QRectF d_boundingRect;
@@ -82,28 +98,17 @@
     QwtSeriesData<T> &operator=( const QwtSeriesData<T> & );
 };
 
-//! Constructor
 template <typename T>
 QwtSeriesData<T>::QwtSeriesData():
     d_boundingRect( 0.0, 0.0, -1.0, -1.0 )
 {
 }
 
-//! Destructor
 template <typename T>
 QwtSeriesData<T>::~QwtSeriesData()
 {
 }
 
-/*!
-   Set a the "rect of interest"
-
-   QwtPlotSeriesItem defines the current area of the plot canvas
-   as "rect of interest" ( QwtPlotSeriesItem::updateScaleDiv() ).
-   It can be used to implement different levels of details.
-
-   The default implementation does nothing.
-*/
 template <typename T>
 void QwtSeriesData<T>::setRectOfInterest( const QRectF & )
 {
@@ -119,40 +124,51 @@
 class QwtArraySeriesData: public QwtSeriesData<T>
 {
 public:
+    //! Constructor
     QwtArraySeriesData();
-    QwtArraySeriesData( const QVector<T> & );
 
-    void setSamples( const QVector<T> & );
+    /*!
+       Constructor
+       \param samples Array of samples
+    */
+    QwtArraySeriesData( const QVector<T> &samples );
+
+    /*!
+      Assign an array of samples
+      \param samples Array of samples
+    */
+    void setSamples( const QVector<T> &samples );
+
+    //! \return Array of samples
     const QVector<T> samples() const;
 
+    //! \return Number of samples
     virtual size_t size() const;
-    virtual T sample( size_t ) const;
 
+    /*!
+      \return Sample at a specific position
+
+      \param index Index
+      \return Sample at position index
+    */
+    virtual T sample( size_t index ) const;
+
 protected:
     //! Vector of samples
     QVector<T> d_samples;
 };
 
-//! Constructor
 template <typename T>
 QwtArraySeriesData<T>::QwtArraySeriesData()
 {
 }
 
-/*!
-   Constructor
-   \param samples Array of samples
-*/
 template <typename T>
 QwtArraySeriesData<T>::QwtArraySeriesData( const QVector<T> &samples ):
     d_samples( samples )
 {
 }
 
-/*!
-  Assign an array of samples
-  \param samples Array of samples
-*/
 template <typename T>
 void QwtArraySeriesData<T>::setSamples( const QVector<T> &samples )
 {
@@ -160,29 +176,22 @@
     d_samples = samples;
 }
 
-//! \return Array of samples
 template <typename T>
 const QVector<T> QwtArraySeriesData<T>::samples() const
 {
     return d_samples;
 }
 
-//! \return Number of samples
 template <typename T>
 size_t QwtArraySeriesData<T>::size() const
 {
     return d_samples.size();
 }
 
-/*!
-  Return a sample
-  \param i Index
-  \return Sample at position i
-*/
 template <typename T>
 T QwtArraySeriesData<T>::sample( size_t i ) const
 {
-    return d_samples[i];
+    return d_samples[ static_cast<int>( i ) ];
 }
 
 //! Interface for iterating over an array of points
@@ -254,4 +263,93 @@
 QWT_EXPORT QRectF qwtBoundingRect(
     const QwtSeriesData<QwtOHLCSample> &, int from = 0, int to = -1 );
 
+/*!
+    Binary search for a sorted series of samples
+
+    qwtUpperSampleIndex returns the index of sample that is the upper bound
+    of value. Is the the value smaller than the smallest value the return
+    value will be 0. Is the value greater or equal than the largest
+    value the return value will be -1.
+
+  \par Example
+    The following example shows finds a point of curve from an x
+    coordinate
+
+  \verbatim
+#include <qwt_series_data.h>
+#include <qwt_plot_curve.h>
+
+struct compareX
+{
+    inline bool operator()( const double x, const QPointF &pos ) const
+    {
+        return ( x < pos.x() );
+    }
+};
+
+QLineF curveLineAt( const QwtPlotCurve *curve, double x )
+{
+    int index = qwtUpperSampleIndex<QPointF>( 
+        *curve->data(), x, compareX() );
+            
+    if ( index == -1 && 
+        x == curve->sample( curve->dataSize() - 1 ).x() )
+    {   
+        // the last sample is excluded from qwtUpperSampleIndex
+        index = curve->dataSize() - 1;
+    }
+
+    QLineF line; // invalid
+    if ( index > 0 )
+    {
+        line.setP1( curve->sample( index - 1 ) );
+        line.setP2( curve->sample( index ) );
+    }
+
+    return line;
+}
+
+\endverbatim
+
+
+    \param series Series of samples
+    \param value Value
+    \param lessThan Compare operation
+
+    \note The samples must be sorted according to the order specified 
+          by the lessThan object
+
+of the range [begin, end) and returns the position of the one-past-the-last occurrence of value. If no such item is found, returns the position where the item should be inserted.
+ */
+template <typename T, typename LessThan>
+inline int qwtUpperSampleIndex( const QwtSeriesData<T> &series,
+    double value, LessThan lessThan  ) 
+{
+    const int indexMax = series.size() - 1;
+
+    if ( indexMax < 0 || !lessThan( value, series.sample( indexMax ) )  )
+        return -1;
+
+    int indexMin = 0;
+    int n = indexMax;
+
+    while ( n > 0 )
+    {
+        const int half = n >> 1;
+        const int indexMid = indexMin + half;
+
+        if ( lessThan( value, series.sample( indexMid ) ) )
+        {
+            n = half;
+        }
+        else
+        {
+            indexMin = indexMid + 1;
+            n -= half + 1;
+        }
+    }
+
+    return indexMin;
+}
+
 #endif
Index: qwt_knob.cpp
===================================================================
--- qwt_knob.cpp	(revision 382)
+++ qwt_knob.cpp	(working copy)
@@ -11,6 +11,7 @@
 #include "qwt_round_scale_draw.h"
 #include "qwt_math.h"
 #include "qwt_painter.h"
+#include "qwt_scale_map.h"
 #include <qpainter.h>
 #include <qpalette.h>
 #include <qstyle.h>
@@ -26,22 +27,57 @@
 #define qFastSin(x) qSin(x)
 #endif
 
+static QSize qwtKnobSizeHint( const QwtKnob *knob, int min )
+{
+    int knobWidth = knob->knobWidth();
+    if ( knobWidth <= 0 )
+        knobWidth = qMax( 3 * knob->markerSize(), min );
+
+    // Add the scale radial thickness to the knobWidth
+    const int extent = qCeil( knob->scaleDraw()->extent( knob->font() ) );
+    const int d = 2 * ( extent + 4 ) + knobWidth;
+
+    int left, right, top, bottom;
+    knob->getContentsMargins( &left, &top, &right, &bottom );
+
+    return QSize( d + left + right, d + top + bottom );
+}
+
+static inline double qwtToScaleAngle( double angle )
+{
+    // the map is counter clockwise with the origin
+    // at 90 using angles from -180 -> 180
+
+    double a = 90.0 - angle;
+    if ( a <= -180.0 )
+        a += 360.0;
+    else if ( a >= 180.0 )
+        a -= 360.0;
+
+    return a;
+}
+
+static double qwtToDegrees( double value )
+{
+    return qwtNormalizeDegrees( 90.0 - value );
+}
+
 class QwtKnob::PrivateData
 {
 public:
-    PrivateData()
+    PrivateData():
+        knobStyle( QwtKnob::Raised ),
+        markerStyle( QwtKnob::Notch ),
+        borderWidth( 2 ),
+        borderDist( 4 ),
+        scaleDist( 4 ),
+        maxScaleTicks( 11 ),
+        knobWidth( 0 ),
+        alignment( Qt::AlignCenter ),
+        markerSize( 8 ),
+        totalAngle( 270.0 ),
+        mouseOffset( 0.0 )
     {
-        angle = 0.0;
-        nTurns = 0.0;
-        borderWidth = 2;
-        borderDist = 4;
-        totalAngle = 270.0;
-        scaleDist = 4;
-        markerStyle = QwtKnob::Notch;
-        maxScaleTicks = 11;
-        knobStyle = QwtKnob::Raised;
-        knobWidth = 50;
-        markerSize = 8;
     }
 
     QwtKnob::KnobStyle knobStyle;
@@ -52,38 +88,39 @@
     int scaleDist;
     int maxScaleTicks;
     int knobWidth;
+    Qt::Alignment alignment;
     int markerSize;
 
-    double angle;
     double totalAngle;
-    double nTurns;
 
-    mutable QRectF knobRect; // bounding rect of the knob without scale
+    double mouseOffset;
 };
 
 /*!
-  Constructor
+  \brief Constructor
+
+  Construct a knob with an angle of 270. The style is
+  QwtKnob::Raised and the marker style is QwtKnob::Notch.
+  The width of the knob is set to 50 pixels.
+
   \param parent Parent widget
+
+  \sa setTotalAngle()
 */
 QwtKnob::QwtKnob( QWidget* parent ):
-    QwtAbstractSlider( Qt::Horizontal, parent )
+    QwtAbstractSlider( parent )
 {
-    initKnob();
-}
-
-void QwtKnob::initKnob()
-{
     d_data = new PrivateData;
 
     setScaleDraw( new QwtRoundScaleDraw() );
 
-    setUpdateTime( 50 );
     setTotalAngle( 270.0 );
-    recalcAngle();
-    setSizePolicy( QSizePolicy( QSizePolicy::Minimum, QSizePolicy::Minimum ) );
 
-    setRange( 0.0, 10.0, 1.0 );
+    setScale( 0.0, 10.0 );
     setValue( 0.0 );
+
+    setSizePolicy( QSizePolicy::MinimumExpanding, 
+        QSizePolicy::MinimumExpanding );
 }
 
 //! Destructor
@@ -132,8 +169,8 @@
 }
 
 /*!
-    \return Marker type of the knob
-    \sa setMarkerStyle(), setMarkerSize()
+  \return Marker type of the knob
+  \sa setMarkerStyle(), setMarkerSize()
 */
 QwtKnob::MarkerStyle QwtKnob::markerStyle() const
 {
@@ -144,29 +181,80 @@
   \brief Set the total angle by which the knob can be turned
   \param angle Angle in degrees.
 
-  The default angle is 270 degrees. It is possible to specify
-  an angle of more than 360 degrees so that the knob can be
-  turned several times around its axis.
+  The angle has to be between [10, 360] degrees. Angles above
+  360 ( so that the knob can be turned several times around its axis )
+  have to be set using setNumTurns().
+
+  The default angle is 270 degrees. 
+
+  \sa totalAngle(), setNumTurns()
 */
 void QwtKnob::setTotalAngle ( double angle )
 {
-    if ( angle < 10.0 )
-        d_data->totalAngle = 10.0;
-    else
+    angle = qBound( 10.0, angle, 360.0 );
+
+    if ( angle != d_data->totalAngle )
+    {
         d_data->totalAngle = angle;
 
-    scaleDraw()->setAngleRange( -0.5 * d_data->totalAngle,
-        0.5 * d_data->totalAngle );
-    layoutKnob( true );
+        scaleDraw()->setAngleRange( -0.5 * d_data->totalAngle,
+            0.5 * d_data->totalAngle );
+
+        updateGeometry();
+        update();
+    }
 }
 
-//! Return the total angle
+/*! 
+  \return the total angle
+  \sa setTotalAngle(), setNumTurns(), numTurns()
+ */
 double QwtKnob::totalAngle() const
 {
     return d_data->totalAngle;
 }
 
 /*!
+  \brief Set the number of turns
+
+  When numTurns > 1 the knob can be turned several times around its axis
+  - otherwise the total angle is floored to 360.
+
+  \sa numTurns(), totalAngle(), setTotalAngle()
+*/
+  
+void QwtKnob::setNumTurns( int numTurns )
+{
+    numTurns = qMax( numTurns, 1 );
+
+    if ( numTurns == 1 && d_data->totalAngle <= 360.0 )
+        return;
+
+    const double angle = numTurns * 360.0;
+    if ( angle != d_data->totalAngle )
+    {
+        d_data->totalAngle = angle;
+
+        scaleDraw()->setAngleRange( -0.5 * d_data->totalAngle,
+            0.5 * d_data->totalAngle );
+
+        updateGeometry();
+        update();
+    }
+}
+
+/*!
+  \return Number of turns. 
+
+  When the total angle is below 360 numTurns() is ceiled to 1.
+  \sa setNumTurns(), setTotalAngle(), totalAngle()
+ */
+int QwtKnob::numTurns() const
+{
+    return qCeil( d_data->totalAngle / 360.0 );
+}
+
+/*!
    Change the scale draw of the knob
 
    For changing the labels of the scales, it
@@ -200,107 +288,136 @@
 }
 
 /*!
-  \brief Notify change of value
+  Calculate the bounding rectangle of the knob without the scale
 
-  Sets the knob's value to the nearest multiple
-  of the step size.
-*/
-void QwtKnob::valueChange()
+  \return Bounding rectangle of the knob
+  \sa knobWidth(), alignment(), QWidget::contentsRect()
+ */
+QRect QwtKnob::knobRect() const
 {
-    recalcAngle();
-    update();
-    QwtAbstractSlider::valueChange();
-}
+    const QRect cr = contentsRect();
 
-/*!
-  \brief Determine the value corresponding to a specified position
+    const int extent = qCeil( scaleDraw()->extent( font() ) );
+    const int d = extent + d_data->scaleDist;
 
-  Called by QwtAbstractSlider
-  \param pos point
-*/
-double QwtKnob::getValue( const QPoint &pos )
-{
-    const double dx = rect().center().x() - pos.x();
-    const double dy = rect().center().y() - pos.y();
+    int w = d_data->knobWidth;
+    if ( w <= 0 )
+    {
+        const int dim = qMin( cr.width(), cr.height() );
 
-    const double arc = qAtan2( -dx, dy ) * 180.0 / M_PI;
+        w = dim - 2 * ( d );
+        w = qMax( 0, w );
+    }
 
-    double newValue =  0.5 * ( minValue() + maxValue() )
-        + ( arc + d_data->nTurns * 360.0 ) * ( maxValue() - minValue() )
-        / d_data->totalAngle;
+    QRect r( 0, 0, w, w );
 
-    const double oneTurn = qFabs( maxValue() - minValue() ) * 360.0 / d_data->totalAngle;
-    const double eqValue = value() + mouseOffset();
+    if ( d_data->alignment & Qt::AlignLeft )
+    {
+        r.moveLeft( cr.left() + d );
+    }
+    else if ( d_data->alignment & Qt::AlignRight )
+    {
+        r.moveRight( cr.right() - d );
+    }
+    else
+    {
+        r.moveCenter( QPoint( cr.center().x(), r.center().y() ) );
+    }
 
-    if ( qFabs( newValue - eqValue ) > 0.5 * oneTurn )
+    if ( d_data->alignment & Qt::AlignTop )
     {
-        if ( newValue < eqValue )
-            newValue += oneTurn;
-        else
-            newValue -= oneTurn;
+        r.moveTop( cr.top() + d );
     }
+    else if ( d_data->alignment & Qt::AlignBottom )
+    {
+        r.moveBottom( cr.bottom() - d );
+    }
+    else 
+    {
+        r.moveCenter( QPoint( r.center().x(), cr.center().y() ) );
+    }
 
-    return newValue;
+    return r;
 }
 
 /*!
-  \brief Set the scrolling mode and direction
+  \brief Determine what to do when the user presses a mouse button.
 
-  Called by QwtAbstractSlider
-  \param pos Point in question
-  \param scrollMode Scrolling mode
-  \param direction Direction
+  \param pos Mouse position
+
+  \retval True, when pos is inside the circle of the knob.
+  \sa scrolledTo()
 */
-void QwtKnob::getScrollMode( const QPoint &pos, 
-    QwtAbstractSlider::ScrollMode &scrollMode, int &direction ) const
+bool QwtKnob::isScrollPosition( const QPoint &pos ) const
 {
-    const double r = 0.5 * d_data->knobRect.width();
-    const double dx = d_data->knobRect.x() + r - pos.x();
-    const double dy = d_data->knobRect.y() + r - pos.y();
+    const QRect kr = knobRect();
 
-    if ( qwtSqr( dx ) + qwtSqr( dy ) <= qwtSqr( r ) ) 
+    const QRegion region( kr, QRegion::Ellipse );
+    if ( region.contains( pos ) && ( pos != kr.center() ) )
     {
-        // point is inside the knob
+        const double angle = QLineF( kr.center(), pos ).angle();
+        const double valueAngle = qwtToDegrees( transform( value() ) );
 
-        scrollMode = QwtAbstractSlider::ScrMouse;
-        direction = 0;
+        d_data->mouseOffset = qwtNormalizeDegrees( angle - valueAngle );
+
+        return true;
     }
-    else                                // point lies outside
-    {
-        scrollMode = QwtAbstractSlider::ScrTimer;
 
-        double arc = qAtan2( double( -dx ), double( dy ) ) * 180.0 / M_PI;
-        if ( arc < d_data->angle )
-            direction = -1;
-        else if ( arc > d_data->angle )
-            direction = 1;
-        else
-            direction = 0;
-    }
+    return false;
 }
 
 /*!
-  \brief Notify a change of the range
+  \brief Determine the value for a new position of the mouse
 
-  Called by QwtAbstractSlider
+  \param pos Mouse position
+
+  \return Value for the mouse position
+  \sa isScrollPosition()
 */
-void QwtKnob::rangeChange()
+double QwtKnob::scrolledTo( const QPoint &pos ) const
 {
-    if ( autoScale() )
-        rescale( minValue(), maxValue() );
+    double angle = QLineF( rect().center(), pos ).angle();
+    angle = qwtNormalizeDegrees( angle - d_data->mouseOffset );
 
-    layoutKnob( true );
-    recalcAngle();
-}
+    if ( scaleMap().pDist() > 360.0 )
+    {
+        angle = qwtToDegrees( angle );
 
-/*!
-  Qt Resize Event
-  \param event Resize event
-*/
-void QwtKnob::resizeEvent( QResizeEvent *event )
-{
-    Q_UNUSED( event );
-    layoutKnob( false );
+        const double v = transform( value() );
+
+        int numTurns = qFloor( ( v - scaleMap().p1() ) / 360.0 );
+
+        double valueAngle = qwtNormalizeDegrees( v );
+        if ( qAbs( valueAngle - angle ) > 180.0 )
+        {
+            numTurns += ( angle > valueAngle ) ? -1 : 1;
+        }
+
+        angle += scaleMap().p1() + numTurns * 360.0;
+
+        if ( !wrapping() )
+        {
+            const double boundedAngle = 
+                qBound( scaleMap().p1(), angle, scaleMap().p2() );
+
+            d_data->mouseOffset += ( boundedAngle - angle );
+            angle = boundedAngle;
+        }
+    }
+    else
+    {
+        angle = qwtToScaleAngle( angle );
+
+        const double boundedAngle = 
+            qBound( scaleMap().p1(), angle, scaleMap().p2() );
+
+        if ( !wrapping() )
+            d_data->mouseOffset += ( boundedAngle - angle );
+
+        angle = boundedAngle;
+    }
+
+    return invTransform( angle );
 }
 
 /*! 
@@ -313,44 +430,24 @@
     {
         case QEvent::StyleChange:
         case QEvent::FontChange:
-            layoutKnob( true );
+        {
+            updateGeometry();
+            update();
             break;
+        }
         default:
             break;
     }
 }
 
 /*!
-   Recalculate the knob's geometry and layout based on
-   the current rect and fonts.
-
-   \param update_geometry notify the layout system and call update
-                          to redraw the scale
-*/
-void QwtKnob::layoutKnob( bool update_geometry )
-{
-    const double d = d_data->knobWidth;
-
-    d_data->knobRect.setWidth( d );
-    d_data->knobRect.setHeight( d );
-    d_data->knobRect.moveCenter( rect().center() );
-
-    scaleDraw()->setRadius( 0.5 * d + d_data->scaleDist );
-    scaleDraw()->moveCenter( rect().center() );
-
-    if ( update_geometry )
-    {
-        updateGeometry();
-        update();
-    }
-}
-
-/*!
   Repaint the knob
   \param event Paint event
 */
 void QwtKnob::paintEvent( QPaintEvent *event )
 {
+    const QRectF knobRect = this->knobRect();
+
     QPainter painter( this );
     painter.setClipRegion( event->region() );
 
@@ -360,20 +457,28 @@
 
     painter.setRenderHint( QPainter::Antialiasing, true );
 
-    if ( !d_data->knobRect.contains( event->region().boundingRect() ) )
+    if ( !knobRect.contains( event->region().boundingRect() ) )
+    {
+        scaleDraw()->setRadius( 0.5 * knobRect.width() + d_data->scaleDist );
+        scaleDraw()->moveCenter( knobRect.center() );
+
         scaleDraw()->draw( &painter, palette() );
+    }
 
-    drawKnob( &painter, d_data->knobRect );
-    drawMarker( &painter, d_data->knobRect, d_data->angle );
+    drawKnob( &painter, knobRect );
 
+    drawMarker( &painter, knobRect, 
+        qwtNormalizeDegrees( transform( value() ) ) );
+
     painter.setRenderHint( QPainter::Antialiasing, false );
 
     if ( hasFocus() )
-        QwtPainter::drawFocusRect( &painter, this );
+        drawFocusIndicator( &painter );
 }
 
 /*!
   \brief Draw the knob
+
   \param painter painter
   \param knobRect Bounding rectangle of the knob (without scale)
 */
@@ -416,6 +521,24 @@
 
             break;
         }
+        case QwtKnob::Styled:
+        {
+            QRadialGradient gradient(knobRect.center().x() - knobRect.width() / 3,
+                knobRect.center().y() - knobRect.height() / 2,
+                knobRect.width() * 1.3,
+                knobRect.center().x(),
+                knobRect.center().y() - knobRect.height() / 2);
+
+            const QColor c = palette().color( QPalette::Button );
+            gradient.setColorAt(0, c.lighter(110));
+            gradient.setColorAt(qreal(0.5), c);
+            gradient.setColorAt(qreal(0.501), c.darker(102));
+            gradient.setColorAt(1, c.darker(115));
+
+            brush = QBrush( gradient );
+
+            break;
+        }
         case QwtKnob::Sunken:
         {
             QLinearGradient gradient( 
@@ -427,6 +550,7 @@
 
             break;
         }
+        case QwtKnob::Flat:
         default:
             brush = palette().brush( QPalette::Button );
     }
@@ -439,9 +563,11 @@
 
 /*!
   \brief Draw the marker at the knob's front
+
   \param painter Painter
   \param rect Bounding rectangle of the knob without scale
-  \param angle Angle of the marker in degrees
+  \param angle Angle of the marker in degrees 
+               ( clockwise, 0 at the 12 o'clock position )
 */
 void QwtKnob::drawMarker( QPainter *painter, 
     const QRectF &rect, double angle ) const
@@ -449,7 +575,7 @@
     if ( d_data->markerStyle == NoMarker || !isValid() )
         return;
 
-    const double radians = angle * M_PI / 180.0;
+    const double radians = qwtRadians( angle );
     const double sinA = -qFastSin( radians );
     const double cosA = qFastCos( radians );
 
@@ -461,13 +587,17 @@
     if ( radius < 1.0 )
         radius = 1.0;
 
+    int markerSize = d_data->markerSize;
+    if ( markerSize <= 0 )
+        markerSize = qRound( 0.4 * radius );
+
     switch ( d_data->markerStyle )
     {
         case Notch:
         case Nub:
         {
             const double dotWidth = 
-                qMin( double( d_data->markerSize ), radius);
+                qMin( double( markerSize ), radius);
 
             const double dotCenterDist = radius - 0.5 * dotWidth;
             if ( dotCenterDist > 0.0 )
@@ -499,7 +629,7 @@
         case Dot:
         {
             const double dotWidth = 
-                qMin( double( d_data->markerSize ), radius);
+                qMin( double( markerSize ), radius);
 
             const double dotCenterDist = radius - 0.5 * dotWidth;
             if ( dotCenterDist > 0.0 )
@@ -519,7 +649,7 @@
         }
         case Tick:
         {
-            const double rb = qMax( radius - d_data->markerSize, 1.0 );
+            const double rb = qMax( radius - markerSize, 1.0 );
             const double re = radius;
 
             const QLineF line( xm - sinA * rb, ym - cosA * rb,
@@ -532,10 +662,9 @@
 
             break;
         }
-#if 0
         case Triangle:
         {
-            const double rb = qMax( radius - d_data->markerSize, 1.0 );
+            const double rb = qMax( radius - markerSize, 1.0 );
             const double re = radius;
 
             painter->translate( rect.center() );
@@ -547,26 +676,103 @@
             polygon += QPointF( rb, -0.5 * ( re - rb ) );
 
             painter->setPen( Qt::NoPen );
-            painter->setBrush( palette().color( QPalette::Text ) );
+            painter->setBrush( palette().color( QPalette::ButtonText ) );
             painter->drawPolygon( polygon );
+
+            painter->resetTransform();
+
             break;
         }
-#endif
         default:
             break;
     }
 }
 
 /*!
+  Draw the focus indicator
+  \param painter Painter
+*/
+void QwtKnob::drawFocusIndicator( QPainter *painter ) const
+{       
+    const QRect cr = contentsRect();
+
+    int w = d_data->knobWidth;
+    if ( w <= 0 )
+    {
+        w = qMin( cr.width(), cr.height() );
+    }
+    else
+    {
+        const int extent = qCeil( scaleDraw()->extent( font() ) );
+        w += 2 * ( extent + d_data->scaleDist );
+    }
+
+    QRect focusRect( 0, 0, w, w );
+    focusRect.moveCenter( cr.center() );
+
+    QwtPainter::drawFocusRect( painter, this, focusRect );
+}  
+
+/*!
+  \brief Set the alignment of the knob
+
+  Similar to a QLabel::alignment() the flags decide how
+  to align the knob inside of contentsRect(). 
+
+  The default setting is Qt::AlignCenter
+
+  \param alignment Or'd alignment flags
+
+  \sa alignment(), setKnobWidth(), knobRect()
+ */
+void QwtKnob::setAlignment( Qt::Alignment alignment )
+{
+    if ( d_data->alignment != alignment )
+    {
+        d_data->alignment = alignment;
+        update();
+    }
+}
+
+/*!
+  \return Alignment of the knob inside of contentsRect()
+  \sa setAlignment(), knobWidth(), knobRect()
+ */
+Qt::Alignment QwtKnob::alignment() const
+{
+    return d_data->alignment;
+}
+
+/*!
   \brief Change the knob's width.
 
-  The specified width must be >= 5, or it will be clipped.
+  Setting a fixed value for the diameter of the knob 
+  is helpful for aligning several knobs in a row.
+
   \param width New width
+
+  \sa knobWidth(), setAlignment()
+  \note Modifies the sizePolicy() 
 */
 void QwtKnob::setKnobWidth( int width )
 {
-    d_data->knobWidth = qMax( width, 5 );
-    layoutKnob( true );
+    width = qMax( width, 0 );
+
+    if ( width != d_data->knobWidth )
+    {
+        QSizePolicy::Policy policy;
+        if ( width > 0 )
+            policy = QSizePolicy::Minimum;
+        else
+            policy = QSizePolicy::MinimumExpanding;
+
+        setSizePolicy( policy, policy );
+
+        d_data->knobWidth = width;
+
+        updateGeometry();
+        update();
+    }
 }
 
 //! Return the width of the knob
@@ -582,7 +788,10 @@
 void QwtKnob::setBorderWidth( int borderWidth )
 {
     d_data->borderWidth = qMax( borderWidth, 0 );
-    layoutKnob( true );
+
+    updateGeometry();
+    update();
+
 }
 
 //! Return the border width
@@ -593,6 +802,10 @@
 
 /*!
   \brief Set the size of the marker
+
+  When setting a size <= 0 the marker will
+  automatically scaled to 40% of the radius of the knob.
+
   \sa markerSize(), markerStyle()
 */
 void QwtKnob::setMarkerSize( int size )
@@ -604,62 +817,29 @@
     }
 }
 
-//! Return the marker size
+/*! 
+  \return Marker size
+  \sa setMarkerSize()
+ */
 int QwtKnob::markerSize() const
 {
     return d_data->markerSize;
 }
 
 /*!
-  \brief Recalculate the marker angle corresponding to the
-    current value
+  \return sizeHint()
 */
-void QwtKnob::recalcAngle()
-{
-    // calculate the angle corresponding to the value
-    if ( qFuzzyCompare( maxValue(), minValue() ) )
-    {
-        d_data->angle = 0;
-        d_data->nTurns = 0;
-    }
-    else
-    {
-        d_data->angle = ( value() - 0.5 * ( minValue() + maxValue() ) )
-            / ( maxValue() - minValue() ) * d_data->totalAngle;
-        d_data->nTurns = qFloor( ( d_data->angle + 180.0 ) / 360.0 );
-        d_data->angle = d_data->angle - d_data->nTurns * 360.0;
-    }
-}
-
-
-/*!
-    Recalculates the layout
-    \sa layoutKnob()
-*/
-void QwtKnob::scaleChange()
-{
-    layoutKnob( true );
-}
-
-/*!
-  \return minimumSizeHint()
-*/
 QSize QwtKnob::sizeHint() const
 {
-    const QSize hint = minimumSizeHint();
+    const QSize hint = qwtKnobSizeHint( this, 50 );
     return hint.expandedTo( QApplication::globalStrut() );
 }
 
 /*!
-  \brief Return a minimum size hint
-  \warning The return value of QwtKnob::minimumSizeHint() depends on the
-           font and the scale.
+  \return Minimum size hint
+  \sa sizeHint()
 */
 QSize QwtKnob::minimumSizeHint() const
 {
-    // Add the scale radial thickness to the knobWidth
-    const int sh = qCeil( scaleDraw()->extent( font() ) );
-    const int d = 2 * sh + 2 * d_data->scaleDist + d_data->knobWidth;
-
-    return QSize( d, d );
+    return qwtKnobSizeHint( this, 20 );
 }
Index: qwt_legend_data.h
===================================================================
--- qwt_legend_data.h	(revision 382)
+++ qwt_legend_data.h	(working copy)
@@ -18,11 +18,24 @@
 #include <qmap.h>
 
 /*!
-    \brief Attributes of an entry on a legend
+  \brief Attributes of an entry on a legend
+
+  QwtLegendData is an abstract container ( like QAbstractModel )
+  to exchange attributes, that are only known between to 
+  the plot item and the legend. 
+  
+  By overloading QwtPlotItem::legendData() any other set of attributes
+  could be used, that can be handled by a modified ( or completely 
+  different ) implementation of a legend.
+
+  \sa QwtLegend, QwtPlotLegendItem
+  \note The stockchart example implements a legend as a tree
+        with checkable items
  */
 class QWT_EXPORT QwtLegendData
 {
 public:
+    //! Mode defining how a legend entry interacts
     enum Mode
     {
         //! The legend item is not interactive, like a label
@@ -35,13 +48,19 @@
         Checkable
     };
 
+    //! Identifier how to interprete a QVariant
     enum Role
     {
+        // The value is a Mode
         ModeRole, 
 
+        // The value is a title
         TitleRole, 
+
+        // The value is an icon
         IconRole, 
 
+        // Values < UserRole are reserved for internal use
         UserRole  = 32
     };
 
Index: qwt_plot_item.cpp
===================================================================
--- qwt_plot_item.cpp	(revision 382)
+++ qwt_plot_item.cpp	(working copy)
@@ -24,6 +24,7 @@
         attributes( 0 ),
         interests( 0 ),
         renderHints( 0 ),
+        renderThreadCount( 1 ),
         z( 0.0 ),
         xAxis( QwtPlot::xBottom ),
         yAxis( QwtPlot::yLeft ),
@@ -34,9 +35,13 @@
     mutable QwtPlot *plot;
 
     bool isVisible;
+
     QwtPlotItem::ItemAttributes attributes;
     QwtPlotItem::ItemInterests interests;
+
     QwtPlotItem::RenderHints renderHints;
+    uint renderThreadCount;
+
     double z;
 
     int xAxis;
@@ -181,7 +186,9 @@
         d_data->title = title;
 
         legendChanged();
+#if 0
         itemChanged();
+#endif
     }
 }
 
@@ -297,6 +304,34 @@
 }
 
 /*!
+   On multi core systems rendering of certain plot item 
+   ( f.e QwtPlotRasterItem ) can be done in parallel in 
+   several threads.
+
+   The default setting is set to 1.
+
+   \param numThreads Number of threads to be used for rendering.
+                     If numThreads is set to 0, the system specific
+                     ideal thread count is used.
+
+   The default thread count is 1 ( = no additional threads )
+*/
+void QwtPlotItem::setRenderThreadCount( uint numThreads )
+{
+    d_data->renderThreadCount = numThreads;
+}
+
+/*!
+   \return Number of threads to be used for rendering.
+           If numThreads() is set to 0, the system specific
+           ideal thread count is used.
+*/
+uint QwtPlotItem::renderThreadCount() const
+{
+    return d_data->renderThreadCount;
+}
+
+/*!
    Set the size of the legend icon
 
    The default setting is 8x8 pixels
@@ -306,7 +341,11 @@
 */
 void QwtPlotItem::setLegendIconSize( const QSize &size )
 {
-    d_data->legendIconSize = size;
+    if ( d_data->legendIconSize != size )
+    {
+        d_data->legendIconSize = size;
+        legendChanged();
+    }
 }
 
 /*!
@@ -338,6 +377,17 @@
     return QwtGraphic();
 }
 
+/*!
+   \brief Return a default icon from a brush
+
+   The default icon is a filled rectangle used
+   in several derived classes as legendIcon().
+
+   \param brush Fill brush
+   \param size Icon size
+
+   \return A filled rectangle
+ */
 QwtGraphic QwtPlotItem::defaultIcon( 
     const QBrush &brush, const QSizeF &size ) const
 {   
@@ -392,7 +442,7 @@
 }
 
 /*!
-   Update the legend and call QwtPlot::autoRefresh for the
+   Update the legend and call QwtPlot::autoRefresh() for the
    parent plot.
 
    \sa QwtPlot::legendChanged(), QwtPlot::autoRefresh()
@@ -416,12 +466,12 @@
 /*!
    Set X and Y axis
 
-   The item will painted according to the coordinates its Axes.
+   The item will painted according to the coordinates of its Axes.
 
-   \param xAxis X Axis
-   \param yAxis Y Axis
+   \param xAxis X Axis ( QwtPlot::xBottom or QwtPlot::xTop )
+   \param yAxis Y Axis ( QwtPlot::yLeft or QwtPlot::yRight )
 
-   \sa setXAxis(), setYAxis(), xAxis(), yAxis()
+   \sa setXAxis(), setYAxis(), xAxis(), yAxis(), QwtPlot::Axis
 */
 void QwtPlotItem::setAxes( int xAxis, int yAxis )
 {
@@ -439,8 +489,8 @@
 
    The item will painted according to the coordinates its Axes.
 
-   \param axis X Axis
-   \sa setAxes(), setYAxis(), xAxis()
+   \param axis X Axis ( QwtPlot::xBottom or QwtPlot::xTop )
+   \sa setAxes(), setYAxis(), xAxis(), QwtPlot::Axis
 */
 void QwtPlotItem::setXAxis( int axis )
 {
@@ -456,8 +506,8 @@
 
    The item will painted according to the coordinates its Axes.
 
-   \param axis Y Axis
-   \sa setAxes(), setXAxis(), yAxis()
+   \param axis Y Axis ( QwtPlot::yLeft or QwtPlot::yRight )
+   \sa setAxes(), setXAxis(), yAxis(), QwtPlot::Axis
 */
 void QwtPlotItem::setYAxis( int axis )
 {
@@ -482,12 +532,35 @@
 
 /*!
    \return An invalid bounding rect: QRectF(1.0, 1.0, -2.0, -2.0)
+   \note A width or height < 0.0 is ignored by the autoscaler
 */
 QRectF QwtPlotItem::boundingRect() const
 {
     return QRectF( 1.0, 1.0, -2.0, -2.0 ); // invalid
 }
 
+/*!
+   \brief Calculate a hint for the canvas margin
+
+   When the QwtPlotItem::Margins flag is enabled the plot item
+   indicates, that it needs some margins at the borders of the canvas.
+   This is f.e. used by bar charts to reserve space for displaying
+   the bars.
+
+   The margins are in target device coordinates ( pixels on screen )
+
+   \param xMap Maps x-values into pixel coordinates.
+   \param yMap Maps y-values into pixel coordinates.
+   \param canvasRect Contents rectangle of the canvas in painter coordinates
+   \param left Returns the left margin
+   \param top Returns the top margin
+   \param right Returns the right margin
+   \param bottom Returns the bottom margin
+
+   \return The default implementation returns 0 for all margins
+
+   \sa QwtPlot::getCanvasMarginsHint(), QwtPlot::updateCanvasMargins()
+ */
 void QwtPlotItem::getCanvasMarginHint( const QwtScaleMap &xMap, 
     const QwtScaleMap &yMap, const QRectF &canvasRect,
     double &left, double &top, double &right, double &bottom ) const
@@ -500,12 +573,34 @@
     left = top = right = bottom = 0.0;
 }
 
+/*!
+   \brief Return all information, that is needed to represent
+          the item on the legend
+
+   Most items are represented by one entry on the legend
+   showing an icon and a text, but f.e. QwtPlotMultiBarChart
+   displays one entry for each bar.
+
+   QwtLegendData is basically a list of QVariants that makes it
+   possible to overload and reimplement legendData() to 
+   return almost any type of information, that is understood
+   by the receiver that acts as the legend.
+
+   The default implementation returns one entry with 
+   the title() of the item and the legendIcon().
+
+   \return Data, that is needed to represent the item on the legend
+   \sa title(), legendIcon(), QwtLegend, QwtPlotLegendItem
+ */
 QList<QwtLegendData> QwtPlotItem::legendData() const
 {
     QwtLegendData data;
+
+    QwtText label = title();
+    label.setRenderFlags( label.renderFlags() & Qt::AlignLeft );
             
     QVariant titleValue;
-    qVariantSetValue( titleValue, title() );
+    qVariantSetValue( titleValue, label );
     data.setValue( QwtLegendData::TitleRole, titleValue );
         
     const QwtGraphic graphic = legendIcon( 0, legendIconSize() );
@@ -531,7 +626,7 @@
    updateScaleDiv()
 
    updateScaleDiv() is only called when the ScaleInterest interest
-   is enabled. The default implemention does nothing.
+   is enabled. The default implementation does nothing.
 
    \param xScaleDiv Scale division of the x-axis
    \param yScaleDiv Scale division of the y-axis
@@ -552,11 +647,13 @@
    be displayed on a legend ! ) will have to implement updateLegend().
 
    updateLegend() is only called when the LegendInterest interest
-   is enabled. The default implemention does nothing.
+   is enabled. The default implementation does nothing.
 
    \param item Plot item to be displayed on a legend
    \param data Attributes how to display item on the legend
 
+   \sa QwtPlotLegendItem
+
    \note Plot items, that want to be displayed on a legend
          need to enable the QwtPlotItem::Legend flag and to implement
          legendData() and legendIcon()
@@ -569,12 +666,12 @@
 }
 
 /*!
-   \brief Calculate the bounding scale rect of 2 maps
+   \brief Calculate the bounding scale rectangle of 2 maps
 
-   \param xMap X map
-   \param yMap X map
+   \param xMap Maps x-values into pixel coordinates.
+   \param yMap Maps y-values into pixel coordinates.
 
-   \return Bounding scale rect of the scale maps, normalized
+   \return Bounding scale rect of the scale maps, not normalized
 */
 QRectF QwtPlotItem::scaleRect( const QwtScaleMap &xMap,
     const QwtScaleMap &yMap ) const
@@ -584,12 +681,12 @@
 }
 
 /*!
-   \brief Calculate the bounding paint rect of 2 maps
+   \brief Calculate the bounding paint rectangle of 2 maps
 
-   \param xMap X map
-   \param yMap X map
+   \param xMap Maps x-values into pixel coordinates.
+   \param yMap Maps y-values into pixel coordinates.
 
-   \return Bounding paint rect of the scale maps, normalized
+   \return Bounding paint rectangle of the scale maps, not normalized
 */
 QRectF QwtPlotItem::paintRect( const QwtScaleMap &xMap,
     const QwtScaleMap &yMap ) const
Index: qwt_clipper.cpp
===================================================================
--- qwt_clipper.cpp	(revision 382)
+++ qwt_clipper.cpp	(working copy)
@@ -10,6 +10,8 @@
 #include "qwt_clipper.h"
 #include "qwt_point_polar.h"
 #include <qrect.h>
+#include <string.h>
+#include <stdlib.h>
 
 #if QT_VERSION < 0x040601
 #define qAtan(x) ::atan(x)
@@ -137,7 +139,7 @@
     ~PointBuffer()
     {
         if ( m_buffer )
-            qFree( m_buffer );
+            ::free( m_buffer );
     }
 
     inline void setPoints( int numPoints, const Point *points )
@@ -145,7 +147,7 @@
         reserve( numPoints );
 
         m_size = numPoints;
-        qMemCopy( m_buffer, points, m_size * sizeof( Point ) );
+        ::memcpy( m_buffer, points, m_size * sizeof( Point ) );
     }
 
     inline void reset() 
@@ -191,7 +193,7 @@
             m_capacity *= 2;
 
         m_buffer = static_cast<Point *>( 
-            qRealloc( m_buffer, m_capacity * sizeof( Point ) ) );
+            ::realloc( m_buffer, m_capacity * sizeof( Point ) ) );
     }
 
     int m_capacity;
@@ -229,7 +231,7 @@
 
         Polygon p;
         p.resize( points1.size() );
-        qMemCopy( p.data(), points1.data(), points1.size() * sizeof( Point ) );
+        ::memcpy( p.data(), points1.data(), points1.size() * sizeof( Point ) );
 
         return p;
     }
@@ -490,7 +492,7 @@
 /*!
    Circle clipping
 
-   clipCircle() devides a circle into intervals of angles representing arcs
+   clipCircle() divides a circle into intervals of angles representing arcs
    of the circle. When the circle is completely inside the clip rectangle
    an interval [0.0, 2 * M_PI] is returned.
 
Index: qwt_plot_rescaler.cpp
===================================================================
--- qwt_plot_rescaler.cpp	(revision 382)
+++ qwt_plot_rescaler.cpp	(working copy)
@@ -9,9 +9,9 @@
 
 #include "qwt_plot_rescaler.h"
 #include "qwt_plot.h"
-#include "qwt_plot_canvas.h"
 #include "qwt_scale_div.h"
 #include "qwt_interval.h"
+#include "qwt_plot_canvas.h"
 #include <qevent.h>
 #include <qalgorithms.h>
 
@@ -58,7 +58,7 @@
 
    \sa setRescalePolicy(), setReferenceAxis()
 */
-QwtPlotRescaler::QwtPlotRescaler( QwtPlotCanvas *canvas,
+QwtPlotRescaler::QwtPlotRescaler( QWidget *canvas,
         int referenceAxis, RescalePolicy policy ):
     QObject( canvas )
 {
@@ -178,7 +178,7 @@
 }
 
 /*!
-  Return direction in which an axis should be expanded
+  \return Direction in which an axis should be expanded
 
   \param axis Axis index ( see QwtPlot::AxisId )
   \sa setExpandingDirection()
@@ -223,7 +223,7 @@
 }
 
 /*!
-  Return aspect ratio between an axis and the reference axis.
+  \return Aspect ratio between an axis and the reference axis.
 
   \param axis Axis index ( see QwtPlot::AxisId )
   \sa setAspectRatio()
@@ -240,7 +240,7 @@
   Set an interval hint for an axis
 
   In Fitting mode, the hint is used as minimal interval
-  taht always needs to be displayed.
+  that always needs to be displayed.
 
   \param axis Axis, see QwtPlot::Axis
   \param interval Axis
@@ -267,35 +267,35 @@
 }
 
 //! \return plot canvas
-QwtPlotCanvas *QwtPlotRescaler::canvas()
+QWidget *QwtPlotRescaler::canvas()
 {
-    return qobject_cast<QwtPlotCanvas *>( parent() );
+    return qobject_cast<QWidget *>( parent() );
 }
 
 //! \return plot canvas
-const QwtPlotCanvas *QwtPlotRescaler::canvas() const
+const QWidget *QwtPlotRescaler::canvas() const
 {
-    return qobject_cast<const QwtPlotCanvas *>( parent() );
+    return qobject_cast<const QWidget *>( parent() );
 }
 
 //! \return plot widget
 QwtPlot *QwtPlotRescaler::plot()
 {
-    QwtPlotCanvas *w = canvas();
+    QWidget *w = canvas();
     if ( w )
-        return w->plot();
+        w = w->parentWidget();
 
-    return NULL;
+    return qobject_cast<QwtPlot *>( w );
 }
 
 //! \return plot widget
 const QwtPlot *QwtPlotRescaler::plot() const
 {
-    const QwtPlotCanvas *w = canvas();
+    const QWidget *w = canvas();
     if ( w )
-        return w->plot();
+        w = w->parentWidget();
 
-    return NULL;
+    return qobject_cast<const QwtPlot *>( w );
 }
 
 //!  Event filter for the plot canvas
@@ -330,10 +330,14 @@
 */
 void QwtPlotRescaler::canvasResizeEvent( QResizeEvent* event )
 {
-    const int fw = 2 * canvas()->frameWidth();
-    const QSize newSize = event->size() - QSize( fw, fw );
-    const QSize oldSize = event->oldSize() - QSize( fw, fw );
+    int left, top, right, bottom;
+    canvas()->getContentsMargins( &left, &top, &right, &bottom );
 
+    const QSize marginSize( left + right, top + bottom );
+
+    const QSize newSize = event->size() - marginSize;
+    const QSize oldSize = event->oldSize() - marginSize;
+
     rescale( oldSize, newSize );
 }
 
@@ -436,11 +440,13 @@
 }
 
 /*!
-   Synchronize an axis scale according to the scale of the reference axis
+  Synchronize an axis scale according to the scale of the reference axis
 
   \param axis Axis index ( see QwtPlot::AxisId )
   \param reference Interval of the reference axis
   \param size Size of the canvas
+
+  \return New interval for axis
 */
 QwtInterval QwtPlotRescaler::syncScale( int axis,
     const QwtInterval& reference, const QSize &size ) const
@@ -470,7 +476,7 @@
 }
 
 /*!
-  Return orientation of an axis
+  \return Orientation of an axis
   \param axis Axis index ( see QwtPlot::AxisId )
 */
 Qt::Orientation QwtPlotRescaler::orientation( int axis ) const
@@ -603,16 +609,23 @@
         }
     }
 
-    const bool immediatePaint = 
-        plt->canvas()->testPaintAttribute( QwtPlotCanvas::ImmediatePaint );
-    plt->canvas()->setPaintAttribute( QwtPlotCanvas::ImmediatePaint, false );
+    QwtPlotCanvas *canvas = qobject_cast<QwtPlotCanvas *>( plt->canvas() );
 
+    bool immediatePaint = false;
+    if ( canvas )
+    {
+        immediatePaint = canvas->testPaintAttribute( QwtPlotCanvas::ImmediatePaint );
+        canvas->setPaintAttribute( QwtPlotCanvas::ImmediatePaint, false );
+    }
+
     plt->setAutoReplot( doReplot );
 
     d_data->inReplot++;
     plt->replot();
     d_data->inReplot--;
 
-    plt->canvas()->setPaintAttribute( 
-        QwtPlotCanvas::ImmediatePaint, immediatePaint );
+    if ( canvas && immediatePaint )
+    {
+        canvas->setPaintAttribute( QwtPlotCanvas::ImmediatePaint, true );
+    }
 }
Index: qwt_plot_tradingcurve.h
===================================================================
--- qwt_plot_tradingcurve.h	(revision 382)
+++ qwt_plot_tradingcurve.h	(working copy)
@@ -20,6 +20,20 @@
 
   QwtPlotTradingCurve supports candlestick or bar ( OHLC ) charts
   that are used in the domain of technical analysis.
+
+  While the length ( height or width depending on orientation() ) 
+  of each symbol depends on the corresponding OHLC sample the size
+  of the other dimension can be controlled using:
+
+  - setSymbolExtent()
+  - setSymbolMinWidth()
+  - setSymbolMaxWidth()
+
+  The extent is a size in scale coordinates, so that the symbol width
+  is increasing when the plot is zoomed in. Minimum/Maximum width
+  is in widget coordinates independent from the zoom level. 
+  When setting the minimum and maximum to the same value, the width of 
+  the symbol is fixed. 
 */
 class QWT_EXPORT QwtPlotTradingCurve: 
     public QwtPlotSeriesItem, QwtSeriesStore<QwtOHLCSample>
@@ -45,7 +59,7 @@
         Bar,
 
         /*!
-          The range between openeing/closing price are displayed as
+          The range between opening/closing price are displayed as
           a filled box. The fill brush depends on the direction of the
           price movement. The box is connected to the highest/lowest
           values by lines.
@@ -67,10 +81,10 @@
      */
     enum Direction
     {
-        //! The closing price is higher than the openening price
+        //! The closing price is higher than the opening price
         Increasing,
 
-        //! The closing price is lower than the openening price
+        //! The closing price is lower than the opening price
         Decreasing
     };
 
@@ -98,19 +112,28 @@
     bool testPaintAttribute( PaintAttribute ) const;
 
     void setSamples( const QVector<QwtOHLCSample> & );
+    void setSamples( QwtSeriesData<QwtOHLCSample> * );
 
     void setSymbolStyle( SymbolStyle style );
     SymbolStyle symbolStyle() const;
 
+    void setSymbolPen( const QColor &, 
+        qreal width = 0.0, Qt::PenStyle = Qt::SolidLine );
     void setSymbolPen( const QPen & );
     QPen symbolPen() const;
 
     void setSymbolBrush( Direction, const QBrush & );
     QBrush symbolBrush( Direction ) const;
 
-    void setSymbolWidth( double width );
-    double symbolWidth() const;
+    void setSymbolExtent( double width );
+    double symbolExtent() const;
 
+    void setMinSymbolWidth( double );
+    double minSymbolWidth() const;
+
+    void setMaxSymbolWidth( double );
+    double maxSymbolWidth() const;
+
     virtual void drawSeries( QPainter *painter,
         const QwtScaleMap &xMap, const QwtScaleMap &yMap,
         const QRectF &canvasRect, int from, int to ) const;
@@ -127,9 +150,16 @@
         const QwtScaleMap &xMap, const QwtScaleMap &yMap,
         const QRectF &canvasRect, int from, int to ) const;
 
-    virtual void drawUserSymbol( QPainter *,
-        SymbolStyle, double symbolWidth, const QwtOHLCSample & ) const;
+    virtual void drawUserSymbol( QPainter *, 
+        SymbolStyle, const QwtOHLCSample &,
+        Qt::Orientation, bool inverted, double width ) const;
 
+    void drawBar( QPainter *painter, const QwtOHLCSample &, 
+        Qt::Orientation, bool inverted, double width ) const;
+
+    void drawCandleStick( QPainter *, const QwtOHLCSample &, 
+        Qt::Orientation, double width ) const;
+
     virtual double scaledSymbolWidth(
         const QwtScaleMap &xMap, const QwtScaleMap &yMap,
         const QRectF &canvasRect ) const;
Index: qwt_global.h
===================================================================
--- qwt_global.h	(revision 382)
+++ qwt_global.h	(working copy)
@@ -20,6 +20,8 @@
 #if defined(_MSC_VER) /* MSVC Compiler */
 /* template-class specialization 'identifier' is already instantiated */
 #pragma warning(disable: 4660)
+/* inherits via dominance */
+#pragma warning(disable: 4250)
 #endif // _MSC_VER
 
 #ifdef QWT_DLL
Index: qwt_painter.h
===================================================================
--- qwt_painter.h	(revision 382)
+++ qwt_painter.h	(working copy)
@@ -16,6 +16,7 @@
 #include <qrect.h>
 #include <qpen.h>
 #include <qline.h>
+#include <qpalette.h>
 
 class QPainter;
 class QBrush;
@@ -29,7 +30,6 @@
 class QwtColorMap;
 class QwtInterval;
 
-class QPalette;
 class QTextDocument;
 class QPainterPath;
 
@@ -77,7 +77,6 @@
     static void drawPolyline( QPainter *, const QPolygon & );
     static void drawPolyline( QPainter *, const QPoint *, int pointCount );
 
-    static void drawPoint( QPainter *, int x, int y );
     static void drawPoint( QPainter *, const QPoint & );
     static void drawPoints( QPainter *, const QPolygon & );
     static void drawPoints( QPainter *, const QPoint *, int pointCount );
@@ -91,13 +90,20 @@
     static void drawImage( QPainter *, const QRectF &, const QImage & );
     static void drawPixmap( QPainter *, const QRectF &, const QPixmap & );
 
+    static void drawRoundFrame( QPainter *,
+        const QRectF &, const QPalette &, int lineWidth, int frameStyle );
+
     static void drawRoundedFrame( QPainter *, 
         const QRectF &, double xRadius, double yRadius,
         const QPalette &, int lineWidth, int frameStyle );
 
-    static void drawFocusRect( QPainter *, QWidget * );
-    static void drawFocusRect( QPainter *, QWidget *, const QRect & );
+    static void drawFrame( QPainter *, const QRectF &rect,
+        const QPalette &palette, QPalette::ColorRole foregroundRole,
+        int lineWidth, int midLineWidth, int frameStyle ); 
 
+    static void drawFocusRect( QPainter *, const QWidget * );
+    static void drawFocusRect( QPainter *, const QWidget *, const QRect & );
+
     static void drawColorBar( QPainter *painter,
         const QwtColorMap &, const QwtInterval &,
         const QwtScaleMap &, Qt::Orientation, const QRectF & );
@@ -105,6 +111,14 @@
     static bool isAligning( QPainter *painter );
     static bool isX11GraphicsSystem();
 
+    static void fillPixmap( const QWidget *, 
+        QPixmap &, const QPoint &offset = QPoint() );
+
+    static void drawBackgound( QPainter *painter,
+        const QRectF &rect, const QWidget *widget );
+
+    static QPixmap backingStore( QWidget *, const QSize & );
+
 private:
     static bool d_polylineSplitting;
     static bool d_roundingAlignment;
@@ -142,7 +156,7 @@
 }
 
 /*!
-  Returns whether line splitting for the raster paint engine is enabled.
+  \return True, when line splitting for the raster paint engine is enabled.
   \sa setPolylineSplitting()
 */
 inline bool QwtPainter::polylineSplitting()
@@ -151,10 +165,11 @@
 }
 
 /*!
-  Returns whether coordinates should be rounded, before they are painted
-  to a paint engine that floors to integer values.  For other paint engines
-  this ( Pdf, SVG ), this flag has no effect.
+  Check whether coordinates should be rounded, before they are painted
+  to a paint engine that rounds to integer values. For other paint engines
+  ( PDF, SVG ), this flag has no effect.
 
+  \return True, when rounding is enabled
   \sa setRoundingAlignment(), isAligning()
 */
 inline bool QwtPainter::roundingAlignment()
Index: qwt_interval_symbol.cpp
===================================================================
--- qwt_interval_symbol.cpp	(revision 382)
+++ qwt_interval_symbol.cpp	(working copy)
@@ -152,6 +152,25 @@
     return d_data->brush;
 }
 
+/*! 
+  Build and assign a pen
+    
+  In Qt5 the default pen width is 1.0 ( 0.0 in Qt4 ) what makes it
+  non cosmetic ( see QPen::isCosmetic() ). This method has been introduced
+  to hide this incompatibility.
+
+  \param color Pen color
+  \param width Pen width
+  \param style Pen style
+    
+  \sa pen(), brush()
+ */ 
+void QwtIntervalSymbol::setPen( const QColor &color, 
+    qreal width, Qt::PenStyle style )
+{   
+    setPen( QPen( color, width, style ) );
+}
+
 /*!
   Assign a pen
 
Index: patches/003-legend-item-testattribute.patch
===================================================================
--- patches/003-legend-item-testattribute.patch	(revision 382)
+++ patches/003-legend-item-testattribute.patch	(working copy)
@@ -1,66 +1,3 @@
-Index: ChangeLog
-===================================================================
---- ChangeLog	(revision 234)
-+++ ChangeLog	(working copy)
-@@ -1,5 +1,11 @@
- 2012-03-12  Daniel Franke  <dfranke@users.sourceforge.net>
- 
-+	* patches/003-legend-item-testattribute.patch: Also update the
-+	legend's layout.
-+	* qwt_plot_legenditem.cpp: Applied updated patch.
-+
-+2012-03-12  Daniel Franke  <dfranke@users.sourceforge.net>
-+
- 	* patches/003-legend-item-testattribute.patch: New.
- 	* patches/004-set-colorbar-interval.patch: New.
- 	* README: Updated.
-Index: patches/003-legend-item-testattribute.patch
-===================================================================
---- patches/003-legend-item-testattribute.patch	(revision 234)
-+++ patches/003-legend-item-testattribute.patch	(working copy)
-@@ -1,14 +1,16 @@
--Index: qwt_plot_legenditem.cpp
-+Index: ChangeLog
- ===================================================================
----- qwt_plot_legenditem.cpp	(revision 233)
--+++ qwt_plot_legenditem.cpp	(working copy)
--@@ -547,7 +547,8 @@
--     const QwtPlotItem *plotItem, const QwtLegendData &data, 
--     const QRectF &rect ) const
-- {
---    Q_UNUSED( plotItem );
--+    if ( !plotItem->testItemAttribute(QwtPlotItem::Legend) )
--+      return;
-+--- ChangeLog	(revision 234)
-++++ ChangeLog	(working copy)
-+@@ -1,5 +1,11 @@
-+ 2012-03-12  Daniel Franke  <dfranke@users.sourceforge.net>
-  
--     const int m = d_data->itemMargin;
--     const QRectF r = rect.toRect().adjusted( m, m, -m, -m );
-++	* patches/003-legend-item-testattribute.patch: Also update the
-++	legend's layout.
-++	* qwt_plot_legenditem.cpp: Applied updated patch.
-++
-++2012-03-12  Daniel Franke  <dfranke@users.sourceforge.net>
-++
-+ 	* patches/003-legend-item-testattribute.patch: New.
-+ 	* patches/004-set-colorbar-interval.patch: New.
-+ 	* README: Updated.
-Index: patches/README
-===================================================================
---- patches/README	(revision 234)
-+++ patches/README	(working copy)
-@@ -24,6 +24,9 @@
- The QwtPlotLegendItem does not check if an item requested not to be 
- included in the legend via "setItemAttribute(QwtPlotItem::Legend, false)".
- 
-+Also the layout doesn't hide layout items that are empty. Second change
-+updates the definition of isEmpty(), minimumSize() and related.
-+
- This patch breaks compability with the QwtLegend, but as we are not
- interested in that any more, so what. It simplifies the client code
- significantly.
 Index: qwt_plot_legenditem.cpp
 ===================================================================
 --- qwt_plot_legenditem.cpp	(revision 234)
Index: qwt_plot_picker.cpp
===================================================================
--- qwt_plot_picker.cpp	(revision 382)
+++ qwt_plot_picker.cpp	(working copy)
@@ -9,7 +9,6 @@
 
 #include "qwt_plot_picker.h"
 #include "qwt_plot.h"
-#include "qwt_plot_canvas.h"
 #include "qwt_scale_div.h"
 #include "qwt_painter.h"
 #include "qwt_scale_map.h"
@@ -28,7 +27,7 @@
   \sa QwtPlot::autoReplot(), QwtPlot::replot(), scaleRect()
 */
 
-QwtPlotPicker::QwtPlotPicker( QwtPlotCanvas *canvas ):
+QwtPlotPicker::QwtPlotPicker( QWidget *canvas ):
     QwtPicker( canvas ),
     d_xAxis( -1 ),
     d_yAxis( -1 )
@@ -66,7 +65,7 @@
 
   \sa QwtPlot::autoReplot(), QwtPlot::replot(), scaleRect()
 */
-QwtPlotPicker::QwtPlotPicker( int xAxis, int yAxis, QwtPlotCanvas *canvas ):
+QwtPlotPicker::QwtPlotPicker( int xAxis, int yAxis, QWidget *canvas ):
     QwtPicker( canvas ),
     d_xAxis( xAxis ),
     d_yAxis( yAxis )
@@ -78,7 +77,7 @@
 
   \param xAxis X axis of the picker
   \param yAxis Y axis of the picker
-  \param rubberBand Rubberband style
+  \param rubberBand Rubber band style
   \param trackerMode Tracker mode
   \param canvas Plot canvas to observe, also the parent object
 
@@ -89,7 +88,7 @@
 */
 QwtPlotPicker::QwtPlotPicker( int xAxis, int yAxis,
         RubberBand rubberBand, DisplayMode trackerMode,
-        QwtPlotCanvas *canvas ):
+        QWidget *canvas ):
     QwtPicker( rubberBand, trackerMode, canvas ),
     d_xAxis( xAxis ),
     d_yAxis( yAxis )
@@ -101,41 +100,40 @@
 {
 }
 
-//! Return observed plot canvas
-QwtPlotCanvas *QwtPlotPicker::canvas()
+//! \return Observed plot canvas
+QWidget *QwtPlotPicker::canvas()
 {
-    return qobject_cast<QwtPlotCanvas *>( parentWidget() );
+    return parentWidget();
 }
 
-//! Return Observed plot canvas
-const QwtPlotCanvas *QwtPlotPicker::canvas() const
+//! \return Observed plot canvas
+const QWidget *QwtPlotPicker::canvas() const
 {
-    return qobject_cast<const QwtPlotCanvas *>( parentWidget() );
+    return parentWidget();
 }
 
-//! Return plot widget, containing the observed plot canvas
+//! \return Plot widget, containing the observed plot canvas
 QwtPlot *QwtPlotPicker::plot()
 {
-    QwtPlotCanvas *w = canvas();
+    QWidget *w = canvas();
     if ( w )
-        return w->plot();
+        w = w->parentWidget();
 
-    return NULL;
+    return qobject_cast<QwtPlot *>( w );
 }
 
-//! Return plot widget, containing the observed plot canvas
+//! \return Plot widget, containing the observed plot canvas
 const QwtPlot *QwtPlotPicker::plot() const
 {
-    const QwtPlotCanvas *w = canvas();
+    const QWidget *w = canvas();
     if ( w )
-        return w->plot();
+        w = w->parentWidget();
 
-    return NULL;
+    return qobject_cast<const QwtPlot *>( w );
 }
 
 /*!
-  Return normalized bounding rect of the axes
-
+  \return Normalized bounding rectangle of the axes
   \sa QwtPlot::autoReplot(), QwtPlot::replot().
 */
 QRectF QwtPlotPicker::scaleRect() const
@@ -228,7 +226,7 @@
 }
 
 /*!
-  Append a point to the selection and update rubberband and tracker.
+  Append a point to the selection and update rubber band and tracker.
 
   \param pos Additional point
   \sa isActive, begin(), end(), move(), appended()
@@ -262,7 +260,7 @@
 
   \param ok If true, complete the selection and emit selected signals
             otherwise discard the selection.
-  \return true if the selection is accepted, false otherwise
+  \return True if the selection has been accepted, false otherwise
 */
 
 bool QwtPlotPicker::end( bool ok )
Index: qwt_analog_clock.cpp
===================================================================
--- qwt_analog_clock.cpp	(revision 382)
+++ qwt_analog_clock.cpp	(working copy)
@@ -8,8 +8,35 @@
  *****************************************************************************/
 
 #include "qwt_analog_clock.h"
+#include "qwt_round_scale_draw.h"
 #include <qmath.h>
+#include <qlocale.h>
 
+class QwtAnalogClockScaleDraw: public QwtRoundScaleDraw
+{
+public:
+    QwtAnalogClockScaleDraw()
+    {
+        setSpacing( 8 );
+
+        enableComponent( QwtAbstractScaleDraw::Backbone, false );
+
+        setTickLength( QwtScaleDiv::MinorTick, 2 );
+        setTickLength( QwtScaleDiv::MediumTick, 4 );
+        setTickLength( QwtScaleDiv::MajorTick, 8 );
+
+        setPenWidth( 1 );
+    }
+
+    virtual QwtText label( double value ) const
+    {
+        if ( qFuzzyCompare( value + 1.0, 1.0 ) )
+            value = 60.0 * 60.0 * 12.0;
+
+        return QLocale().toString( qRound( value / ( 60.0 * 60.0 ) ) );
+    }
+};
+
 /*!
   Constructor
   \param parent Parent widget
@@ -17,23 +44,33 @@
 QwtAnalogClock::QwtAnalogClock( QWidget *parent ):
     QwtDial( parent )
 {
-    initClock();
-}
-
-void QwtAnalogClock::initClock()
-{
     setWrapping( true );
     setReadOnly( true );
 
     setOrigin( 270.0 );
-    setRange( 0.0, 60.0 * 60.0 * 12.0 ); // seconds
-    setScale( -1, 5, 60.0 * 60.0 );
+    setScaleDraw( new QwtAnalogClockScaleDraw() );
 
-    setScaleComponents( 
-        QwtAbstractScaleDraw::Ticks | QwtAbstractScaleDraw::Labels );
-    setScaleTicks( 1, 0, 8 );
-    scaleDraw()->setSpacing( 8 );
+    setTotalSteps( 60 );
 
+    const int secondsPerHour = 60.0 * 60.0; 
+
+    QList<double> majorTicks;
+    QList<double> minorTicks;
+
+    for ( int i = 0; i < 12; i++ )
+    {
+        majorTicks += i * secondsPerHour;
+
+        for ( int j = 1; j < 5; j++ )
+            minorTicks += i * secondsPerHour + j * secondsPerHour / 5.0;
+    }
+
+    QwtScaleDiv scaleDiv;
+    scaleDiv.setInterval( 0.0, 12.0 * secondsPerHour );
+    scaleDiv.setTicks( QwtScaleDiv::MajorTick, majorTicks );
+    scaleDiv.setTicks( QwtScaleDiv::MinorTick, minorTicks );
+    setScale( scaleDiv );
+
     QColor knobColor = palette().color( QPalette::Active, QPalette::Text );
     knobColor = knobColor.dark( 120 );
 
@@ -70,7 +107,7 @@
 }
 
 /*!
-  Nop method, use setHand instead
+  Nop method, use setHand() instead
   \sa setHand()
 */
 void QwtAnalogClock::setNeedle( QwtDialNeedle * )
@@ -80,14 +117,14 @@
 }
 
 /*!
-   Set a clockhand
+   Set a clock hand
    \param hand Specifies the type of hand
    \param needle Hand
    \sa hand()
 */
 void QwtAnalogClock::setHand( Hand hand, QwtDialNeedle *needle )
 {
-    if ( hand >= 0 || hand < NHands )
+    if ( hand >= 0 && hand < NHands )
     {
         delete d_hand[hand];
         d_hand[hand] = needle;
@@ -119,9 +156,6 @@
 
 /*!
   \brief Set the current time
-
-  This is the same as QwtAnalogClock::setTime(), but Qt < 3.0
-  can't handle default parameters for slots.
 */
 void QwtAnalogClock::setCurrentTime()
 {
@@ -144,23 +178,9 @@
 }
 
 /*!
-  Find the scale label for a given value
-
-  \param value Value
-  \return Label
-*/
-QwtText QwtAnalogClock::scaleLabel( double value ) const
-{
-    if ( qFuzzyCompare( value, 0.0 ) )
-        value = 60.0 * 60.0 * 12.0;
-
-    return QString::number( qRound( value / ( 60.0 * 60.0 ) ) );
-}
-
-/*!
   \brief Draw the needle
 
-  A clock has no single needle but three hands instead. drawNeedle
+  A clock has no single needle but three hands instead. drawNeedle()
   translates value() into directions for the hands and calls
   drawHand().
 
@@ -192,12 +212,7 @@
 
         for ( int hand = 0; hand < NHands; hand++ )
         {
-            double d = angle[hand];
-            if ( direction() == Clockwise )
-                d = 360.0 - d;
-
-            d -= origin();
-
+            const double d = 360.0 - angle[hand] - origin();
             drawHand( painter, static_cast<Hand>( hand ), 
                 center, radius, d, colorGroup );
         }
Index: qwt_text_engine.h
===================================================================
--- qwt_text_engine.h	(revision 382)
+++ qwt_text_engine.h	(working copy)
@@ -57,7 +57,7 @@
       \param flags Bitwise OR of the flags like in for QPainter::drawText
       \param text Text to be rendered
 
-      \return Caluclated size
+      \return Calculated size
      */
     virtual QSizeF textSize( const QFont &font, int flags,
         const QString &text ) const = 0;
@@ -74,8 +74,8 @@
       Return margins around the texts
 
       The textSize might include margins around the
-      text, like QFontMetrics::descent. In situations
-      where texts need to be aligend in detail, knowing
+      text, like QFontMetrics::descent(). In situations
+      where texts need to be aligned in detail, knowing
       these margins might improve the layout calculations.
 
       \param font Font of the text
@@ -93,7 +93,7 @@
 
       \param painter Painter
       \param rect Clipping rectangle
-      \param flags Bitwise OR of the flags like in for QPainter::drawText
+      \param flags Bitwise OR of the flags like in for QPainter::drawText()
       \param text Text to be rendered
      */
     virtual void draw( QPainter *painter, const QRectF &rect,
Index: qwt_text_label.cpp
===================================================================
--- qwt_text_label.cpp	(revision 382)
+++ qwt_text_label.cpp	(working copy)
@@ -63,13 +63,34 @@
 }
 
 /*!
+   Interface for the designer plugin - does the same as setText()
+   \sa plainText()
+ */
+void QwtTextLabel::setPlainText( const QString &text )
+{
+    setText( QwtText( text ) );
+}
+
+/*!
+   Interface for the designer plugin
+
+   \return Text as plain text
+   \sa setPlainText(), text()
+ */
+QString QwtTextLabel::plainText() const
+{
+    return d_data->text.text();
+}
+
+/*!
    Change the label's text, keeping all other QwtText attributes
    \param text New text
    \param textFormat Format of text
 
   \sa QwtText
 */
-void QwtTextLabel::setText( const QString &text, QwtText::TextFormat textFormat )
+void QwtTextLabel::setText( const QString &text, 
+    QwtText::TextFormat textFormat )
 {
     d_data->text.setText( text, textFormat );
 
@@ -231,7 +252,7 @@
     painter->setFont( font() );
     painter->setPen( palette().color( QPalette::Active, QPalette::Text ) );
 
-    drawText( painter, r );
+    drawText( painter, QRectF( r ) );
 
     if ( hasFocus() )
     {
@@ -244,14 +265,14 @@
 }
 
 //! Redraw the text
-void QwtTextLabel::drawText( QPainter *painter, const QRect &textRect )
+void QwtTextLabel::drawText( QPainter *painter, const QRectF &textRect )
 {
     d_data->text.draw( painter, textRect );
 }
 
 /*!
-  Calculate the rect for the text in widget coordinates
-  \return Text rect
+  Calculate geometry for the text in widget coordinates
+  \return Geometry for the text
 */
 QRect QwtTextLabel::textRect() const
 {
Index: qwt_dial_needle.cpp
===================================================================
--- qwt_dial_needle.cpp	(revision 382)
+++ qwt_dial_needle.cpp	(working copy)
@@ -353,7 +353,6 @@
 }
 
 //! Constructor
-
 QwtCompassMagnetNeedle::QwtCompassMagnetNeedle( Style style,
         const QColor &light, const QColor &dark ):
     d_style( style )
Index: qwt_plot_panner.h
===================================================================
--- qwt_plot_panner.h	(revision 382)
+++ qwt_plot_panner.h	(working copy)
@@ -13,13 +13,12 @@
 #include "qwt_global.h"
 #include "qwt_panner.h"
 
-class QwtPlotCanvas;
 class QwtPlot;
 
 /*!
   \brief QwtPlotPanner provides panning of a plot canvas
 
-  QwtPlotPanner is a panner for a QwtPlotCanvas, that
+  QwtPlotPanner is a panner for a plot canvas, that
   adjusts the scales of the axes after dropping
   the canvas on its new position.
 
@@ -34,11 +33,11 @@
     Q_OBJECT
 
 public:
-    explicit QwtPlotPanner( QwtPlotCanvas * );
+    explicit QwtPlotPanner( QWidget * );
     virtual ~QwtPlotPanner();
 
-    QwtPlotCanvas *canvas();
-    const QwtPlotCanvas *canvas() const;
+    QWidget *canvas();
+    const QWidget *canvas() const;
 
     QwtPlot *plot();
     const QwtPlot *plot() const;
@@ -51,6 +50,7 @@
 
 protected:
     virtual QBitmap contentsMask() const;
+    virtual QPixmap grab() const;
 
 private:
     class PrivateData;
Index: qwt_plot_baritem.h
===================================================================
--- qwt_plot_baritem.h	(revision 382)
+++ qwt_plot_baritem.h	(working copy)
@@ -1,103 +0,0 @@
-/* -*- mode: C++ ; c-file-style: "stroustrup" -*- *****************************
- * Qwt Widget Library
- * Copyright (C) 1997   Josef Wilgen
- * Copyright (C) 2002   Uwe Rathmann
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the Qwt License, Version 1.0
- *****************************************************************************/
-
-#ifndef QWT_PLOT_BAR_ITEM_H
-#define QWT_PLOT_BAR_ITEM_H
-
-#include "qwt_global.h"
-#include "qwt_plot_seriesitem.h"
-#include "qwt_series_data.h"
-
-class QwtColumnRect;
-class QwtColumnSymbol;
-
-class QWT_EXPORT QwtPlotBarItem: public QwtPlotSeriesItem
-{
-public:
-    enum ChartAttribute
-    {
-        ShowLabels = 0x01
-    };
-
-    typedef QFlags<ChartAttribute> ChartAttributes;
-
-    /*!
-        \brief Mode how to calculate the bar width
-
-        setLayoutPolicy(), setLayoutHint()
-     */
-    enum LayoutPolicy
-    {
-        /*!
-          The sample width is calculated by deviding the bounding rectangle
-          by the number of samples.
-
-          \sa boundingRectangle()
-          \note The layoutHint() is ignored
-         */
-        AutoAdjustSamples,
-
-        /*!
-          The barWidthHint() defines an interval in axis coordinates
-         */
-        ScaleSamplesToAxes,
-
-        /*!
-          The bar width is calculated by multiplying the barWidthHint()
-          with the height or width of the canvas.
-
-          \sa boundingRectangle()
-         */
-        ScaleSampleToCanvas,
-
-        /*!
-          The barWidthHint() defines a fixed width in paint device coordinates.
-         */
-        FixedSampleSize
-    };
-
-    explicit QwtPlotBarItem( const QwtText &title );
-    virtual ~QwtPlotBarItem();
-
-    void setChartAttribute( ChartAttribute, bool on = true );
-    bool testChartAttribute( ChartAttribute ) const;
-
-    void setLayoutPolicy( LayoutPolicy );
-    LayoutPolicy layoutPolicy() const;
-
-    void setLayoutHint( double );
-    double layoutHint() const;
-
-    void setSpacing( int );
-    int spacing() const;
-
-    void setMargin( int );
-    int margin() const;
-
-    void setBaseline( double );
-    double baseline() const;
-
-    virtual void getCanvasMarginHint( 
-        const QwtScaleMap &xMap, const QwtScaleMap &yMap,
-        const QRectF &canvasRect,
-        double &left, double &top, double &right, double &bottom) const;
-
-protected:
-    double sampleWidth( const QwtScaleMap &map,
-        double canvasSize, double dataSize,
-        double value ) const;
-
-private:
-    class PrivateData;
-    PrivateData *d_data;
-};
-
-Q_DECLARE_OPERATORS_FOR_FLAGS( QwtPlotBarItem::ChartAttributes )
-
-#endif
Index: qwt_plot_spectrocurve.h
===================================================================
--- qwt_plot_spectrocurve.h	(revision 382)
+++ qwt_plot_spectrocurve.h	(working copy)
@@ -46,7 +46,9 @@
     bool testPaintAttribute( PaintAttribute ) const;
 
     void setSamples( const QVector<QwtPoint3D> & );
+    void setSamples( QwtSeriesData<QwtPoint3D> * );
 
+
     void setColorMap( QwtColorMap * );
     const QwtColorMap *colorMap() const;
 
Index: qwt_panner.h
===================================================================
--- qwt_panner.h	(revision 382)
+++ qwt_panner.h	(working copy)
@@ -43,11 +43,14 @@
     void setEnabled( bool );
     bool isEnabled() const;
 
-    void setMouseButton( int button, int buttonState = Qt::NoButton );
-    void getMouseButton( int &button, int &buttonState ) const;
-    void setAbortKey( int key, int state = Qt::NoButton );
-    void getAbortKey( int &key, int &state ) const;
+    void setMouseButton( Qt::MouseButton, 
+        Qt::KeyboardModifiers = Qt::NoModifier );
+    void getMouseButton( Qt::MouseButton &button, 
+        Qt::KeyboardModifiers & ) const;
 
+    void setAbortKey( int key, Qt::KeyboardModifiers = Qt::NoModifier );
+    void getAbortKey( int &key, Qt::KeyboardModifiers & ) const;
+
     void setCursor( const QCursor & );
     const QCursor cursor() const;
 
Index: qwt_math.cpp
===================================================================
--- qwt_math.cpp	(revision 382)
+++ qwt_math.cpp	(working copy)
@@ -43,3 +43,32 @@
 
     return rv;
 }
+
+/*!
+  \brief Normalize an angle to be int the range [0.0, 2 * PI[
+  \param radians Angle in radians
+  \return Normalized angle in radians
+*/
+double qwtNormalizeRadians( double radians )
+{
+    double a = ::fmod( radians, 2.0 * M_PI );
+    if ( a < 0.0 )
+        a += 2.0 * M_PI;
+
+    return a;
+
+}
+
+/*!
+  \brief Normalize an angle to be int the range [0.0, 360.0[
+  \param radians Angle in degrees
+  \return Normalized angle in degrees
+*/
+double qwtNormalizeDegrees( double degrees )
+{
+    double a = ::fmod( degrees, 360.0 );
+    if ( a < 0.0 )
+        a += 360.0;
+
+    return a;
+}
Index: qwt_knob.h
===================================================================
--- qwt_knob.h	(revision 382)
+++ qwt_knob.h	(working copy)
@@ -12,37 +12,45 @@
 
 #include "qwt_global.h"
 #include "qwt_abstract_slider.h"
-#include "qwt_abstract_scale.h"
 
 class QwtRoundScaleDraw;
 
 /*!
   \brief The Knob Widget
 
-  The QwtKnob widget imitates look and behaviour of a volume knob on a radio.
-  It contains a scale around the knob which is set up automatically or can
-  be configured manually (see QwtAbstractScale).
-  Automatic scrolling is enabled when the user presses a mouse
-  button on the scale. For a description of signals, slots and other
-  members, see QwtAbstractSlider.
+  The QwtKnob widget imitates look and behavior of a volume knob on a radio.
+  It looks similar to QDial - not to QwtDial.
 
+  The value range of a knob might be divided into several turns.
+
+  The layout of the knob depends on the knobWidth().
+
+  - width > 0 
+    The diameter of the knob is fixed and the knob is aligned
+    according to the alignment() flags inside of the contentsRect(). 
+
+  - width <= 0
+    The knob is extended to the minimum of width/height of the contentsRect()
+    and aligned in the other direction according to alignment().
+
+  Setting a fixed knobWidth() is helpful to align several knobs with different
+  scale labels.
+  
   \image html knob.png
-  \sa   QwtAbstractSlider and QwtAbstractScale for the descriptions
-    of the inherited members.
 */
 
-class QWT_EXPORT QwtKnob : public QwtAbstractSlider, public QwtAbstractScale
+class QWT_EXPORT QwtKnob: public QwtAbstractSlider
 {
     Q_OBJECT
 
-    Q_ENUMS ( KnobStyle )
-    Q_ENUMS ( MarkerStyle )
+    Q_ENUMS ( KnobStyle MarkerStyle )
 
     Q_PROPERTY( KnobStyle knobStyle READ knobStyle WRITE setKnobStyle )
-    Q_PROPERTY( MarkerStyle markerStyle READ markerStyle WRITE setMarkerStyle )
     Q_PROPERTY( int knobWidth READ knobWidth WRITE setKnobWidth )
-    Q_PROPERTY( int borderWidth READ borderWidth WRITE setBorderWidth )
+    Q_PROPERTY( Qt::Alignment alignment READ alignment WRITE setAlignment )
     Q_PROPERTY( double totalAngle READ totalAngle WRITE setTotalAngle )
+    Q_PROPERTY( int numTurns READ numTurns WRITE setNumTurns )
+    Q_PROPERTY( MarkerStyle markerStyle READ markerStyle WRITE setMarkerStyle )
     Q_PROPERTY( int markerSize READ markerSize WRITE setMarkerSize )
     Q_PROPERTY( int borderWidth READ borderWidth WRITE setBorderWidth )
 
@@ -58,7 +66,7 @@
     enum KnobStyle
     {
         //! Fill the knob with a brush from QPalette::Button.
-        NoStyle = -1,
+        Flat,
 
         //! Build a gradient from QPalette::Midlight and QPalette::Button
         Raised,
@@ -67,7 +75,13 @@
           Build a gradient from QPalette::Midlight, QPalette::Button
           and QPalette::Midlight
          */
-        Sunken
+        Sunken,
+
+        /*! 
+          Build a radial gradient from QPalette::Button
+          like it is used for QDial in various Qt styles.
+         */
+        Styled
     };
 
     /*!
@@ -86,6 +100,9 @@
         //! Paint a single tick in QPalette::ButtonText color
         Tick, 
 
+        //! Paint a triangle in QPalette::ButtonText color
+        Triangle, 
+
         //! Paint a circle in QPalette::ButtonText color
         Dot, 
 
@@ -105,9 +122,15 @@
     explicit QwtKnob( QWidget* parent = NULL );
     virtual ~QwtKnob();
 
-    void setKnobWidth( int w );
+    void setAlignment( Qt::Alignment );
+    Qt::Alignment alignment() const;
+
+    void setKnobWidth( int );
     int knobWidth() const;
 
+    void setNumTurns( int );
+    int numTurns() const;
+
     void setTotalAngle ( double angle );
     double totalAngle() const;
 
@@ -127,31 +150,27 @@
     virtual QSize minimumSizeHint() const;
 
     void setScaleDraw( QwtRoundScaleDraw * );
+
     const QwtRoundScaleDraw *scaleDraw() const;
     QwtRoundScaleDraw *scaleDraw();
 
+    QRect knobRect() const;
+
 protected:
     virtual void paintEvent( QPaintEvent * );
-    virtual void resizeEvent( QResizeEvent * );
     virtual void changeEvent( QEvent * );
 
     virtual void drawKnob( QPainter *, const QRectF & ) const;
+
+    virtual void drawFocusIndicator( QPainter * ) const;
+
     virtual void drawMarker( QPainter *, 
         const QRectF &, double arc ) const;
 
-    virtual double getValue( const QPoint &p );
-    virtual void getScrollMode( const QPoint &, 
-        QwtAbstractSlider::ScrollMode &, int &direction ) const;
+    virtual double scrolledTo( const QPoint & ) const;
+    virtual bool isScrollPosition( const QPoint & ) const;
 
 private:
-    void initKnob();
-    void layoutKnob( bool update );
-    void recalcAngle();
-
-    virtual void valueChange();
-    virtual void rangeChange();
-    virtual void scaleChange();
-
     class PrivateData;
     PrivateData *d_data;
 };
Index: qwt_magnifier.cpp
===================================================================
--- qwt_magnifier.cpp	(revision 382)
+++ qwt_magnifier.cpp	(working copy)
@@ -18,14 +18,14 @@
     PrivateData():
         isEnabled( false ),
         wheelFactor( 0.9 ),
-        wheelButtonState( Qt::NoButton ),
+        wheelModifiers( Qt::NoModifier ),
         mouseFactor( 0.95 ),
         mouseButton( Qt::RightButton ),
-        mouseButtonState( Qt::NoButton ),
+        mouseButtonModifiers( Qt::NoModifier ),
         keyFactor( 0.9 ),
         zoomInKey( Qt::Key_Plus ),
+        zoomInKeyModifiers( Qt::NoModifier ),
         zoomOutKey( Qt::Key_Minus ),
-        zoomInKeyModifiers( Qt::NoModifier ),
         zoomOutKeyModifiers( Qt::NoModifier ),
         mousePressed( false )
     {
@@ -34,17 +34,20 @@
     bool isEnabled;
 
     double wheelFactor;
-    int wheelButtonState;
+    Qt::KeyboardModifiers wheelModifiers;
 
     double mouseFactor;
-    int mouseButton;
-    int mouseButtonState;
 
+    Qt::MouseButton mouseButton;
+    Qt::KeyboardModifiers mouseButtonModifiers;
+
     double keyFactor;
+
     int zoomInKey;
+    Qt::KeyboardModifiers zoomInKeyModifiers;
+
     int zoomOutKey;
-    int zoomInKeyModifiers;
-    int zoomOutKeyModifiers;
+    Qt::KeyboardModifiers  zoomOutKeyModifiers;
 
     bool mousePressed;
     bool hasMouseTracking;
@@ -108,6 +111,11 @@
 
    The wheel factor defines the ratio between the current range
    on the parent widget and the zoomed range for each step of the wheel.
+
+   Use values > 1 for magnification (i.e. 2.0) and values < 1 for
+   scaling down (i.e. 1/2.0 = 0.5). You can use this feature for
+   inverting the direction of the wheel.
+
    The default value is 0.9.
 
    \param factor Wheel factor
@@ -129,24 +137,24 @@
 }
 
 /*!
-   Assign a mandatory button state for zooming in/out using the wheel.
-   The default button state is Qt::NoButton.
+   Assign keyboard modifiers for zooming in/out using the wheel.
+   The default modifiers are Qt::NoModifiers.
 
-   \param buttonState Button state
-   \sa wheelButtonState()
+   \param modifiers Keyboard modifiers
+   \sa wheelModifiers()
 */
-void QwtMagnifier::setWheelButtonState( int buttonState )
+void QwtMagnifier::setWheelModifiers( Qt::KeyboardModifiers modifiers )
 {
-    d_data->wheelButtonState = buttonState;
+    d_data->wheelModifiers = modifiers;
 }
 
 /*!
-   \return Wheel button state
-   \sa setWheelButtonState()
+   \return Wheel modifiers
+   \sa setWheelModifiers()
 */
-int QwtMagnifier::wheelButtonState() const
+Qt::KeyboardModifiers QwtMagnifier::wheelModifiers() const
 {
-    return d_data->wheelButtonState;
+    return d_data->wheelModifiers;
 }
 
 /*!
@@ -178,21 +186,23 @@
    The default value is Qt::RightButton.
 
    \param button Button
-   \param buttonState Button state
+   \param modifiers Keyboard modifiers
+
    \sa getMouseButton()
 */
-void QwtMagnifier::setMouseButton( int button, int buttonState )
+void QwtMagnifier::setMouseButton( 
+    Qt::MouseButton button, Qt::KeyboardModifiers modifiers )
 {
     d_data->mouseButton = button;
-    d_data->mouseButtonState = buttonState;
+    d_data->mouseButtonModifiers = modifiers;
 }
 
 //! \sa setMouseButton()
 void QwtMagnifier::getMouseButton(
-    int &button, int &buttonState ) const
+    Qt::MouseButton &button, Qt::KeyboardModifiers &modifiers ) const
 {
     button = d_data->mouseButton;
-    buttonState = d_data->mouseButtonState;
+    modifiers = d_data->mouseButtonModifiers;
 }
 
 /*!
@@ -228,14 +238,23 @@
    \param modifiers
    \sa getZoomInKey(), setZoomOutKey()
 */
-void QwtMagnifier::setZoomInKey( int key, int modifiers )
+void QwtMagnifier::setZoomInKey( int key, 
+    Qt::KeyboardModifiers modifiers )
 {
     d_data->zoomInKey = key;
     d_data->zoomInKeyModifiers = modifiers;
 }
 
-//! \sa setZoomInKey()
-void QwtMagnifier::getZoomInKey( int &key, int &modifiers ) const
+/*! 
+   \brief Retrieve the settings of the zoom in key
+
+   \param key Key code, see Qt::Key
+   \param modifiers Keyboard modifiers
+
+   \sa setZoomInKey()
+*/
+void QwtMagnifier::getZoomInKey( int &key, 
+    Qt::KeyboardModifiers &modifiers ) const
 {
     key = d_data->zoomInKey;
     modifiers = d_data->zoomInKeyModifiers;
@@ -249,14 +268,23 @@
    \param modifiers
    \sa getZoomOutKey(), setZoomOutKey()
 */
-void QwtMagnifier::setZoomOutKey( int key, int modifiers )
+void QwtMagnifier::setZoomOutKey( int key, 
+    Qt::KeyboardModifiers modifiers )
 {
     d_data->zoomOutKey = key;
     d_data->zoomOutKeyModifiers = modifiers;
 }
 
-//! \sa setZoomOutKey()
-void QwtMagnifier::getZoomOutKey( int &key, int &modifiers ) const
+/*! 
+   \brief Retrieve the settings of the zoom out key
+
+   \param key Key code, see Qt::Key
+   \param modifiers Keyboard modifiers
+
+   \sa setZoomOutKey()
+*/
+void QwtMagnifier::getZoomOutKey( int &key, 
+    Qt::KeyboardModifiers &modifiers ) const
 {
     key = d_data->zoomOutKey;
     modifiers = d_data->zoomOutKeyModifiers;
@@ -265,11 +293,14 @@
 /*!
   \brief Event filter
 
-  When isEnabled() the mouse events of the observed widget are filtered.
+  When isEnabled() is true, the mouse events of the
+  observed widget are filtered.
 
   \param object Object to be filtered
   \param event Event
 
+  \return Forwarded to QObject::eventFilter()
+
   \sa widgetMousePressEvent(), widgetMouseReleaseEvent(),
       widgetMouseMoveEvent(), widgetWheelEvent(), widgetKeyPressEvent()
       widgetKeyReleaseEvent()
@@ -324,19 +355,17 @@
 */
 void QwtMagnifier::widgetMousePressEvent( QMouseEvent *mouseEvent )
 {
-    if ( ( mouseEvent->button() != d_data->mouseButton) 
-        || parentWidget() == NULL )
-    {
+    if ( parentWidget() == NULL )
         return;
-    }
 
-    if ( ( mouseEvent->modifiers() & Qt::KeyboardModifierMask ) !=
-        ( int )( d_data->mouseButtonState & Qt::KeyboardModifierMask ) )
+    if ( ( mouseEvent->button() != d_data->mouseButton ) ||
+        ( mouseEvent->modifiers() != d_data->mouseButtonModifiers ) )
     {
         return;
     }
 
     d_data->hasMouseTracking = parentWidget()->hasMouseTracking();
+
     parentWidget()->setMouseTracking( true );
     d_data->mousePos = mouseEvent->pos();
     d_data->mousePressed = true;
@@ -392,8 +421,7 @@
 */
 void QwtMagnifier::widgetWheelEvent( QWheelEvent *wheelEvent )
 {
-    if ( ( wheelEvent->modifiers() & Qt::KeyboardModifierMask ) !=
-        ( int )( d_data->wheelButtonState & Qt::KeyboardModifierMask ) )
+    if ( wheelEvent->modifiers() != d_data->wheelModifiers )
     {
         return;
     }
@@ -410,7 +438,7 @@
             of 120 (== 15 * 8).
          */
         double f = qPow( d_data->wheelFactor, 
-            qAbs( wheelEvent->delta() / 120 ) );
+            qAbs( wheelEvent->delta() / 120.0 ) );
 
         if ( wheelEvent->delta() > 0 )
             f = 1 / f;
@@ -427,16 +455,13 @@
 */
 void QwtMagnifier::widgetKeyPressEvent( QKeyEvent *keyEvent )
 {
-    const int key = keyEvent->key();
-    const int state = keyEvent->modifiers();
-
-    if ( key == d_data->zoomInKey &&
-        state == d_data->zoomInKeyModifiers )
+    if ( keyEvent->key() == d_data->zoomInKey &&
+        keyEvent->modifiers() == d_data->zoomInKeyModifiers )
     {
         rescale( d_data->keyFactor );
     }
-    else if ( key == d_data->zoomOutKey &&
-        state == d_data->zoomOutKeyModifiers )
+    else if ( keyEvent->key() == d_data->zoomOutKey &&
+        keyEvent->modifiers() == d_data->zoomOutKeyModifiers )
     {
         rescale( 1.0 / d_data->keyFactor );
     }
Index: qwt_painter.cpp
===================================================================
--- qwt_painter.cpp	(revision 382)
+++ qwt_painter.cpp	(working copy)
@@ -28,6 +28,16 @@
 #include <qapplication.h>
 #include <qdesktopwidget.h>
 
+#if QT_VERSION >= 0x050000
+#include <qwindow.h>
+#endif
+
+#if 0
+#ifdef Q_WS_X11
+#include <qx11info_x11.h>
+#endif
+#endif
+
 bool QwtPainter::d_polylineSplitting = true;
 bool QwtPainter::d_roundingAlignment = true;
 
@@ -115,11 +125,10 @@
   that has some special capabilities that can be used for incremental
   painting to a widget.
 
-  \return True, when the graphicssystem is X11
+  \return True, when the graphics system is X11
 */
 bool QwtPainter::isX11GraphicsSystem()
 {
-#if defined(Q_WS_X11)
     static int onX11 = -1;
     if ( onX11 < 0 )
     {
@@ -130,9 +139,6 @@
     }
 
     return onX11 == 1;
-#else
-    return false;
-#endif
 }
 
 /*!
@@ -176,8 +182,8 @@
 /*!
   Enable whether coordinates should be rounded, before they are painted
   to a paint engine that floors to integer values. For other paint engines
-  this ( Pdf, SVG ), this flag has no effect.
-  QwtPainter stores this flag only, the rounding itsself is done in 
+  this ( PDF, SVG ), this flag has no effect.
+  QwtPainter stores this flag only, the rounding itself is done in 
   the painting code ( f.e the plot items ).
 
   The default setting is true. 
@@ -192,9 +198,12 @@
 /*!
   \brief En/Disable line splitting for the raster paint engine
 
-  The raster paint engine paints polylines of many points
-  much faster when they are splitted in smaller chunks.
+  In some Qt versions the raster paint engine paints polylines of many points
+  much faster when they are split in smaller chunks: f.e all supported Qt versions
+  >= Qt 5.0 when drawing an antialiased polyline with a pen width >=2.
 
+  The default setting is true.
+
   \sa polylineSplitting()
 */
 void QwtPainter::setPolylineSplitting( bool enable )
@@ -254,8 +263,8 @@
     const bool deviceClipping = qwtIsClippingNeeded( painter, clipRect );
 
     /*
-      Performance of Qt4 is horrible for non trivial brushs. Without
-      clipping expect minutes or hours for repainting large rects
+      Performance of Qt4 is horrible for a non trivial brush. Without
+      clipping expect minutes or hours for repainting large rectangles
       (might result from zooming)
     */
 
@@ -269,7 +278,7 @@
 
     QRectF r = rect;
     if ( deviceClipping )
-        r = r.intersect( clipRect );
+        r = r.intersected( clipRect );
 
     if ( r.isValid() )
         painter->fillRect( r, brush );
@@ -443,7 +452,7 @@
     if ( deviceClipping )
     {
         QPolygonF polygon( pointCount );
-        qMemCopy( polygon.data(), points, pointCount * sizeof( QPointF ) );
+        ::memcpy( polygon.data(), points, pointCount * sizeof( QPointF ) );
 
         polygon = QwtClipper::clipPolygonF( clipRect, polygon );
         qwtDrawPolyline<QPointF>( painter,
@@ -492,7 +501,7 @@
     if ( deviceClipping )
     {
         QPolygon polygon( pointCount );
-        qMemCopy( polygon.data(), points, pointCount * sizeof( QPoint ) );
+        ::memcpy( polygon.data(), points, pointCount * sizeof( QPoint ) );
 
         polygon = QwtClipper::clipPolygon( clipRect, polygon );
         qwtDrawPolyline<QPoint>( painter,
@@ -639,13 +648,13 @@
 }
 
 //! Draw a focus rectangle on a widget using its style.
-void QwtPainter::drawFocusRect( QPainter *painter, QWidget *widget )
+void QwtPainter::drawFocusRect( QPainter *painter, const QWidget *widget )
 {
     drawFocusRect( painter, widget, widget->rect() );
 }
 
 //! Draw a focus rectangle on a widget using its style.
-void QwtPainter::drawFocusRect( QPainter *painter, QWidget *widget,
+void QwtPainter::drawFocusRect( QPainter *painter, const QWidget *widget,
     const QRect &rect )
 {
     QStyleOptionFocusRect opt;
@@ -658,10 +667,242 @@
 }
 
 /*!
-  Draw a frame with rounded borders
+  Draw a round frame 
 
   \param painter Painter
   \param rect Frame rectangle
+  \param palette QPalette::WindowText is used for plain borders
+                 QPalette::Dark and QPalette::Light for raised
+                 or sunken borders
+  \param lineWidth Line width
+  \param frameStyle bitwise ORed value of QFrame::Shape and QFrame::Shadow
+*/
+void QwtPainter::drawRoundFrame( QPainter *painter,
+    const QRectF &rect, const QPalette &palette, 
+    int lineWidth, int frameStyle )
+{
+    enum Style
+    {
+        Plain,
+        Sunken,
+        Raised
+    };
+
+    Style style = Plain;
+    if ( (frameStyle & QFrame::Sunken) == QFrame::Sunken )
+        style = Sunken;
+    else if ( (frameStyle & QFrame::Raised) == QFrame::Raised )
+        style = Raised;
+
+    const double lw2 = 0.5 * lineWidth;
+    QRectF r = rect.adjusted( lw2, lw2, -lw2, -lw2 );
+
+    QBrush brush;
+
+    if ( style != Plain )
+    {
+        QColor c1 = palette.color( QPalette::Light );
+        QColor c2 = palette.color( QPalette::Dark );
+
+        if ( style == Sunken )
+            qSwap( c1, c2 );
+
+        QLinearGradient gradient( r.topLeft(), r.bottomRight() );
+        gradient.setColorAt( 0.0, c1 );
+#if 0
+        gradient.setColorAt( 0.3, c1 );
+        gradient.setColorAt( 0.7, c2 );
+#endif
+        gradient.setColorAt( 1.0, c2 );
+
+        brush = QBrush( gradient );
+    }
+    else // Plain
+    {
+        brush = palette.brush( QPalette::WindowText );
+    }
+
+    painter->save();
+
+    painter->setPen( QPen( brush, lineWidth ) );
+    painter->setBrush( Qt::NoBrush );
+
+    painter->drawEllipse( r );
+
+    painter->restore();
+}
+
+/*!
+  Draw a rectangular frame
+
+  \param painter Painter
+  \param rect Frame rectangle
+  \param palette Palette
+  \param foregroundRole Foreground role used for QFrame::Plain
+  \param frameWidth Frame width
+  \param midLineWidth Used for QFrame::Box
+  \param frameStyle bitwise ORed value of QFrame::Shape and QFrame::Shadow
+*/
+void QwtPainter::drawFrame( QPainter *painter, const QRectF &rect,
+    const QPalette &palette, QPalette::ColorRole foregroundRole,
+    int frameWidth, int midLineWidth, int frameStyle )
+{
+    if ( frameWidth <= 0 || rect.isEmpty() )
+        return;
+
+    const int shadow = frameStyle & QFrame::Shadow_Mask;
+
+    painter->save();
+
+    if ( shadow == QFrame::Plain )
+    {
+        const QRectF outerRect = rect.adjusted( 0.0, 0.0, -1.0, -1.0 );
+        const QRectF innerRect = outerRect.adjusted( 
+            frameWidth, frameWidth, -frameWidth, -frameWidth );
+
+        QPainterPath path;
+        path.addRect( outerRect );
+        path.addRect( innerRect );
+
+        painter->setPen( Qt::NoPen );
+        painter->setBrush( palette.color( foregroundRole ) );
+
+        painter->drawPath( path );
+    }
+    else
+    {
+        const int shape = frameStyle & QFrame::Shape_Mask;
+
+        if ( shape == QFrame::Box )
+        {
+            const QRectF outerRect = rect.adjusted( 0.0, 0.0, -1.0, -1.0 );
+            const QRectF midRect1 = outerRect.adjusted( 
+                frameWidth, frameWidth, -frameWidth, -frameWidth );
+            const QRectF midRect2 = midRect1.adjusted( 
+                midLineWidth, midLineWidth, -midLineWidth, -midLineWidth );
+
+            const QRectF innerRect = midRect2.adjusted( 
+                frameWidth, frameWidth, -frameWidth, -frameWidth );
+
+            QPainterPath path1;
+            path1.moveTo( outerRect.bottomLeft() );
+            path1.lineTo( outerRect.topLeft() );
+            path1.lineTo( outerRect.topRight() );
+            path1.lineTo( midRect1.topRight() );
+            path1.lineTo( midRect1.topLeft() );
+            path1.lineTo( midRect1.bottomLeft() );
+
+            QPainterPath path2;
+            path2.moveTo( outerRect.bottomLeft() );
+            path2.lineTo( outerRect.bottomRight() );
+            path2.lineTo( outerRect.topRight() );
+            path2.lineTo( midRect1.topRight() );
+            path2.lineTo( midRect1.bottomRight() );
+            path2.lineTo( midRect1.bottomLeft() );
+
+            QPainterPath path3;
+            path3.moveTo( midRect2.bottomLeft() );
+            path3.lineTo( midRect2.topLeft() );
+            path3.lineTo( midRect2.topRight() );
+            path3.lineTo( innerRect.topRight() );
+            path3.lineTo( innerRect.topLeft() );
+            path3.lineTo( innerRect.bottomLeft() );
+
+            QPainterPath path4;
+            path4.moveTo( midRect2.bottomLeft() );
+            path4.lineTo( midRect2.bottomRight() );
+            path4.lineTo( midRect2.topRight() );
+            path4.lineTo( innerRect.topRight() );
+            path4.lineTo( innerRect.bottomRight() );
+            path4.lineTo( innerRect.bottomLeft() );
+
+            QPainterPath path5;
+            path5.addRect( midRect1 );
+            path5.addRect( midRect2 );
+
+            painter->setPen( Qt::NoPen );
+
+            QBrush brush1 = palette.dark().color();
+            QBrush brush2 = palette.light().color();
+
+            if ( shadow == QFrame::Raised )
+                qSwap( brush1, brush2 );
+
+            painter->setBrush( brush1 );
+            painter->drawPath( path1 );
+            painter->drawPath( path4 );
+
+            painter->setBrush( brush2 );
+            painter->drawPath( path2 );
+            painter->drawPath( path3 );
+
+            painter->setBrush( palette.mid() );
+            painter->drawPath( path5 );
+        }
+#if 0
+        // qDrawWinPanel doesn't result in something nice
+        // on a scalable document like PDF. Better draw a
+        // Panel.
+
+        else if ( shape == QFrame::WinPanel )
+        {
+            painter->setRenderHint( QPainter::NonCosmeticDefaultPen, true );
+            qDrawWinPanel ( painter, rect.toRect(), palette,
+                frameStyle & QFrame::Sunken );
+        }
+        else if ( shape == QFrame::StyledPanel )
+        {
+        }
+#endif
+        else
+        {
+            const QRectF outerRect = rect.adjusted( 0.0, 0.0, -1.0, -1.0 );
+            const QRectF innerRect = outerRect.adjusted( 
+                frameWidth - 1.0, frameWidth - 1.0, 
+                -( frameWidth - 1.0 ), -( frameWidth - 1.0 ) );
+
+            QPainterPath path1;
+            path1.moveTo( outerRect.bottomLeft() );
+            path1.lineTo( outerRect.topLeft() );
+            path1.lineTo( outerRect.topRight() );
+            path1.lineTo( innerRect.topRight() );
+            path1.lineTo( innerRect.topLeft() );
+            path1.lineTo( innerRect.bottomLeft() );
+
+
+            QPainterPath path2;
+            path2.moveTo( outerRect.bottomLeft() );
+            path2.lineTo( outerRect.bottomRight() );
+            path2.lineTo( outerRect.topRight() );
+            path2.lineTo( innerRect.topRight() );
+            path2.lineTo( innerRect.bottomRight() );
+            path2.lineTo( innerRect.bottomLeft() );
+
+            painter->setPen( Qt::NoPen );
+
+            QBrush brush1 = palette.dark().color();
+            QBrush brush2 = palette.light().color();
+
+            if ( shadow == QFrame::Raised )
+                qSwap( brush1, brush2 );
+
+            painter->setBrush( brush1 );
+            painter->drawPath( path1 );
+
+            painter->setBrush( brush2 );
+            painter->drawPath( path2 );
+        }
+
+    }
+
+    painter->restore();
+}
+
+/*!
+  Draw a rectangular frame with rounded borders
+
+  \param painter Painter
+  \param rect Frame rectangle
   \param xRadius x-radius of the ellipses defining the corners
   \param yRadius y-radius of the ellipses defining the corners
   \param palette QPalette::WindowText is used for plain borders
@@ -735,9 +976,11 @@
             QRectF r = pathList[2 * i].controlPointRect();
 
             QPen arcPen;
+            arcPen.setCapStyle( Qt::FlatCap );
             arcPen.setWidth( lineWidth );
 
             QPen linePen;
+            linePen.setCapStyle( Qt::FlatCap );
             linePen.setWidth( lineWidth );
 
             switch( i )
@@ -871,3 +1114,148 @@
 
     drawPixmap( painter, rect, pixmap );
 }
+
+static inline void qwtFillRect( const QWidget *widget, QPainter *painter, 
+    const QRect &rect, const QBrush &brush)
+{
+    if ( brush.style() == Qt::TexturePattern ) 
+    {
+        painter->save();
+
+        painter->setClipRect( rect );
+        painter->drawTiledPixmap(rect, brush.texture(), rect.topLeft());
+
+        painter->restore();
+    } 
+    else if ( brush.gradient() )
+    {
+        painter->save();
+
+        painter->setClipRect( rect );
+        painter->fillRect(0, 0, widget->width(), 
+            widget->height(), brush);
+
+        painter->restore();
+    } 
+    else 
+    {
+        painter->fillRect(rect, brush);
+    }
+}
+
+/*!
+  Fill a pixmap with the content of a widget
+
+  In Qt >= 5.0 QPixmap::fill() is a nop, in Qt 4.x it is buggy
+  for backgrounds with gradients. Thus fillPixmap() offers 
+  an alternative implementation.
+
+  \param widget Widget
+  \param pixmap Pixmap to be filled
+  \param offset Offset 
+
+  \sa QPixmap::fill()
+ */
+void QwtPainter::fillPixmap( const QWidget *widget, 
+    QPixmap &pixmap, const QPoint &offset )
+{
+    const QRect rect( offset, pixmap.size() );
+
+    QPainter painter( &pixmap );
+    painter.translate( -offset );
+
+    const QBrush autoFillBrush = 
+        widget->palette().brush( widget->backgroundRole() );
+
+    if ( !( widget->autoFillBackground() && autoFillBrush.isOpaque() ) ) 
+    {
+        const QBrush bg = widget->palette().brush( QPalette::Window );
+        qwtFillRect( widget, &painter, rect, bg);
+    }
+
+    if ( widget->autoFillBackground() )
+        qwtFillRect( widget, &painter, rect, autoFillBrush);
+
+    if ( widget->testAttribute(Qt::WA_StyledBackground) ) 
+    {
+        painter.setClipRegion( rect );
+
+        QStyleOption opt;
+        opt.initFrom( widget );
+        widget->style()->drawPrimitive( QStyle::PE_Widget, 
+            &opt, &painter, widget );
+    }
+}
+
+/*!
+  Fill rect with the background of a widget
+
+  \param painter Painter
+  \param rect Rectangle to be filled
+  \param widget Widget
+
+  \sa QStyle::PE_Widget, QWidget::backgroundRole()
+ */
+void QwtPainter::drawBackgound( QPainter *painter,
+    const QRectF &rect, const QWidget *widget )
+{
+    if ( widget->testAttribute( Qt::WA_StyledBackground ) )
+    {
+        QStyleOption opt;
+        opt.initFrom( widget );
+        opt.rect = rect.toAlignedRect();
+
+        widget->style()->drawPrimitive(
+            QStyle::PE_Widget, &opt, painter, widget);
+    }
+    else
+    {
+        const QBrush brush =
+            widget->palette().brush( widget->backgroundRole() );
+
+        painter->fillRect( rect, brush );
+    }
+}
+
+/*!
+  \return A pixmap that can be used as backing store
+
+  \param widget Widget, for which the backinstore is intended
+  \param size Size of the pixmap
+ */
+QPixmap QwtPainter::backingStore( QWidget *widget, const QSize &size )
+{
+    QPixmap pm;
+
+#define QWT_HIGH_DPI 1
+
+#if QT_VERSION >= 0x050000 && QWT_HIGH_DPI
+    qreal pixelRatio = 1.0;
+
+    if ( widget && widget->windowHandle() )
+    {
+        pixelRatio = widget->windowHandle()->devicePixelRatio();
+    }
+    else
+    {
+        if ( qApp )
+            pixelRatio = qApp->devicePixelRatio();
+    }
+
+    pm = QPixmap( size * pixelRatio );
+    pm.setDevicePixelRatio( pixelRatio );
+#else
+    Q_UNUSED( widget )
+    pm = QPixmap( size );
+#endif
+
+#if 0
+#ifdef Q_WS_X11
+    if ( pm.x11Info().screen() != x11Info().screen() )
+         pm.x11SetScreen( x11Info().screen() );
+#endif
+#endif
+
+    return pm;
+}
+
Index: qwt_scale_draw.cpp
===================================================================
--- qwt_scale_draw.cpp	(revision 382)
+++ qwt_scale_draw.cpp	(working copy)
@@ -63,6 +63,7 @@
 /*!
    Return alignment of the scale
    \sa setAlignment()
+   \return Alignment of the scale
 */
 QwtScaleDraw::Alignment QwtScaleDraw::alignment() const
 {
@@ -72,6 +73,8 @@
 /*!
    Set the alignment of the scale
 
+   \param align Alignment of the scale
+
    The default alignment is QwtScaleDraw::BottomScale
    \sa alignment()
 */
@@ -86,6 +89,8 @@
   TopScale, BottomScale are horizontal (Qt::Horizontal) scales,
   LeftScale, RightScale are vertical (Qt::Vertical) scales.
 
+  \return Orientation of the scale
+
   \sa alignment()
 */
 Qt::Orientation QwtScaleDraw::orientation() const
@@ -112,8 +117,8 @@
   \param start Start border distance
   \param end End border distance
 */
-void QwtScaleDraw::getBorderDistHint( const QFont &font,
-                                      int &start, int &end ) const
+void QwtScaleDraw::getBorderDistHint( 
+    const QFont &font, int &start, int &end ) const
 {
     start = 0;
     end = 0;
@@ -229,19 +234,19 @@
             maxDist = dist;
     }
 
-    double angle = labelRotation() / 180.0 * M_PI;
+    double angle = qwtRadians( labelRotation() ); 
     if ( vertical )
         angle += M_PI / 2;
 
     const double sinA = qFastSin( angle ); // qreal -> double
-    if ( qFuzzyCompare( sinA, 0.0 ) )
+    if ( qFuzzyCompare( sinA + 1.0, 1.0 ) )
         return qCeil( maxDist );
 
     const int fmHeight = fm.ascent() - 2;
 
     // The distance we need until there is
     // the height of the label font. This height is needed
-    // for the neighbour labal.
+    // for the neighbored label.
 
     double labelDist = fmHeight / qFastSin( angle ) * qFastCos( angle );
     if ( labelDist < 0 )
@@ -270,6 +275,7 @@
    of the labels.
 
    \param font Font used for painting the labels
+   \return Extent
 
    \sa minLength()
 */
@@ -295,7 +301,7 @@
 
     if ( hasComponent( QwtAbstractScaleDraw::Backbone ) )
     {
-        const double pw = qMax( 1, penWidth() );  // penwidth can be zero
+        const double pw = qMax( 1, penWidth() );  // pen width can be zero
         d += pw;
     }
 
@@ -307,6 +313,7 @@
    Calculate the minimum length that is needed to draw the scale
 
    \param font Font used for painting the labels
+   \return Minimum length that is needed to draw the scale
 
    \sa extent()
 */
@@ -340,10 +347,11 @@
 /*!
    Find the position, where to paint a label
 
-   The position has a distance of majTickLength() + spacing() + 1
-   from the backbone. The direction depends on the alignment()
+   The position has a distance that depends on the length of the ticks 
+   in direction of the alignment().
 
    \param value Value
+   \return Position, where to paint a label
 */
 QPointF QwtScaleDraw::labelPosition( double value ) const
 {
@@ -394,7 +402,7 @@
 
    \param painter Painter
    \param value Value of the tick
-   \param len Lenght of the tick
+   \param len Length of the tick
 
    \sa drawBackbone(), drawLabel()
 */
@@ -600,14 +608,22 @@
   The length doesn't include the space needed for
   overlapping labels.
 
+  \param length Length of the backbone
+
   \sa move(), minLabelDist()
 */
 void QwtScaleDraw::setLength( double length )
 {
+#if 1
     if ( length >= 0 && length < 10 )
         length = 10;
+
+    // why should we accept negative lengths ???
     if ( length < 0 && length > -10 )
         length = -10;
+#else
+    length = qMax( length, 10 );
+#endif
 
     d_data->len = length;
     updateMap();
@@ -651,13 +667,15 @@
 }
 
 /*!
-  Find the bounding rect for the label. The coordinates of
-  the rect are absolute coordinates ( calculated from pos() ).
+  \brief Find the bounding rectangle for the label.
+
+  The coordinates of the rectangle are absolute ( calculated from pos() ).
   in direction of the tick.
 
   \param font Font used for painting
   \param value Value
 
+  \return Bounding rectangle
   \sa labelRect()
 */
 QRect QwtScaleDraw::boundingLabelRect( const QFont &font, double value ) const
@@ -680,6 +698,7 @@
    \param pos Position where to paint the label
    \param size Size of the label
 
+   \return Transformation matrix
    \sa setLabelAlignment(), setLabelRotation()
 */
 QTransform QwtScaleDraw::labelTransformation(
@@ -743,12 +762,14 @@
 }
 
 /*!
-  Find the bounding rect for the label. The coordinates of
-  the rect are relative to spacing + ticklength from the backbone
+  Find the bounding rectangle for the label. The coordinates of
+  the rectangle are relative to spacing + tick length from the backbone
   in direction of the tick.
 
   \param font Font used for painting
   \param value Value
+
+   \return Bounding rectangle that is needed to draw a label
 */
 QRectF QwtScaleDraw::labelRect( const QFont &font, double value ) const
 {
@@ -772,6 +793,8 @@
 
    \param font Label font
    \param value Value
+
+   \return Size that is needed to draw a label
 */
 QSizeF QwtScaleDraw::labelSize( const QFont &font, double value ) const
 {
@@ -808,7 +831,7 @@
 /*!
   \brief Change the label flags
 
-  Labels are aligned to the point ticklength + spacing away from the backbone.
+  Labels are aligned to the point tick length + spacing away from the backbone.
 
   The alignment is relative to the orientation of the label text.
   In case of an flags of 0 the label will be aligned
@@ -827,7 +850,7 @@
   \warning The various alignments might be confusing.
            The alignment of the label is not the alignment
            of the scale and is not the alignment of the flags
-           (QwtText::flags()) returned from QwtAbstractScaleDraw::label().
+           ( QwtText::flags() ) returned from QwtAbstractScaleDraw::label().
 */
 
 void QwtScaleDraw::setLabelAlignment( Qt::Alignment alignment )
Index: qwt_abstract_slider.cpp
===================================================================
--- qwt_abstract_slider.cpp	(revision 382)
+++ qwt_abstract_slider.cpp	(working copy)
@@ -8,82 +8,148 @@
  *****************************************************************************/
 
 #include "qwt_abstract_slider.h"
+#include "qwt_abstract_scale_draw.h"
 #include "qwt_math.h"
+#include "qwt_scale_map.h"
 #include <qevent.h>
-#include <qdatetime.h>
 
 #if QT_VERSION < 0x040601
 #define qFabs(x) ::fabs(x)
-#define qExp(x) ::exp(x)
 #endif
 
+static double qwtAlignToScaleDiv( 
+    const QwtAbstractSlider *slider, double value )
+{
+    const QwtScaleDiv &sd = slider->scaleDiv();
+
+    const int tValue = slider->transform( value );
+
+    if ( tValue == slider->transform( sd.lowerBound() ) )
+        return sd.lowerBound();
+
+    if ( tValue == slider->transform( sd.lowerBound() ) )
+        return sd.upperBound();
+
+    for ( int i = 0; i < QwtScaleDiv::NTickTypes; i++ )
+    {
+        const QList<double> ticks = sd.ticks( i );
+        for ( int j = 0; j < ticks.size(); j++ )
+        {
+            if ( slider->transform( ticks[ j ] ) == tValue )
+                return ticks[ j ];
+        }
+    }
+
+    return value;
+}
+
 class QwtAbstractSlider::PrivateData
 {
 public:
     PrivateData():
-        scrollMode( QwtAbstractSlider::ScrNone ),
-        mouseOffset( 0.0 ),
-        tracking( true ),
-        tmrID( 0 ),
-        updTime( 150 ),
-        mass( 0.0 ),
-        readOnly( false )
+        isScrolling( false ),
+        isTracking( true ),
+        pendingValueChanged( false ),
+        readOnly( false ),
+        totalSteps( 100 ),
+        singleSteps( 1 ),
+        pageSteps( 10 ),
+        stepAlignment( true ),
+        isValid( false ),
+        value( 0.0 ),
+        wrapping( false ),
+        invertedControls( false )
     {
     }
 
-    QwtAbstractSlider::ScrollMode scrollMode;
-    double mouseOffset;
-    int direction;
-    int tracking;
+    bool isScrolling;
+    bool isTracking;
+    bool pendingValueChanged;
 
-    int tmrID;
-    int updTime;
-    int timerTick;
-    QTime time;
-    double speed;
-    double mass;
-    Qt::Orientation orientation;
     bool readOnly;
+
+    uint totalSteps;
+    uint singleSteps;
+    uint pageSteps;
+    bool stepAlignment;
+
+    bool isValid;
+    double value;
+
+    bool wrapping;
+    bool invertedControls;
 };
 
 /*!
-   \brief Constructor
+  \brief Constructor
 
-   \param orientation Orientation
-   \param parent Parent widget
+  The scale is initialized to [0.0, 100.0], the
+  number of steps is set to 100 with 1 and 10 and single
+  an page step sizes. Step alignment is enabled.
+
+  The initial value is invalid.
+
+  \param parent Parent widget
 */
-QwtAbstractSlider::QwtAbstractSlider(
-        Qt::Orientation orientation, QWidget *parent ):
-    QWidget( parent, NULL )
+QwtAbstractSlider::QwtAbstractSlider( QWidget *parent ):
+    QwtAbstractScale( parent )
 {
     d_data = new QwtAbstractSlider::PrivateData;
-    d_data->orientation = orientation;
 
-    setFocusPolicy( Qt::TabFocus );
+    setScale( 0.0, 100.0 );
+    setFocusPolicy( Qt::StrongFocus );
 }
 
 //! Destructor
 QwtAbstractSlider::~QwtAbstractSlider()
 {
-    if ( d_data->tmrID )
-        killTimer( d_data->tmrID );
-
     delete d_data;
 }
 
+/*! 
+  Set the value to be valid/invalid
+
+  \param on When true, the value is invalidated
+
+  \sa setValue()
+*/
+void QwtAbstractSlider::setValid( bool on )
+{
+    if ( on != d_data->isValid )
+    {
+        d_data->isValid = on;
+        sliderChange();
+
+        Q_EMIT valueChanged( d_data->value );
+    }   
+}   
+
+//! \return True, when the value is invalid
+bool QwtAbstractSlider::isValid() const
+{
+    return d_data->isValid;
+}   
+
 /*!
   En/Disable read only mode
 
   In read only mode the slider can't be controlled by mouse
   or keyboard.
 
-  \param readOnly Enables in case of true
+  \param on Enables in case of true
   \sa isReadOnly()
+
+  \warning The focus policy is set to Qt::StrongFocus or Qt::NoFocus
 */
-void QwtAbstractSlider::setReadOnly( bool readOnly )
+void QwtAbstractSlider::setReadOnly( bool on )
 {
-    d_data->readOnly = readOnly;
-    update();
+    if ( d_data->readOnly != on )
+    {
+        d_data->readOnly = on;
+        setFocusPolicy( on ? Qt::StrongFocus : Qt::NoFocus );
+
+        update();
+    }
 }
 
 /*!
@@ -99,499 +165,656 @@
 }
 
 /*!
-  \brief Set the orientation.
-  \param o Orientation. Allowed values are
-           Qt::Horizontal and Qt::Vertical.
-*/
-void QwtAbstractSlider::setOrientation( Qt::Orientation o )
-{
-    d_data->orientation = o;
-}
+  \brief Enables or disables tracking.
 
-/*!
-  \return Orientation
-  \sa setOrientation()
-*/
-Qt::Orientation QwtAbstractSlider::orientation() const
-{
-    return d_data->orientation;
-}
+  If tracking is enabled, the slider emits the valueChanged() 
+  signal while the movable part of the slider is being dragged. 
+  If tracking is disabled, the slider emits the valueChanged() signal 
+  only when the user releases the slider.
 
-//! Stop updating if automatic scrolling is active
+  Tracking is enabled by default.
+  \param on \c true (enable) or \c false (disable) tracking.
 
-void QwtAbstractSlider::stopMoving()
+  \sa isTracking(), sliderMoved()
+*/
+void QwtAbstractSlider::setTracking( bool on )
 {
-    if ( d_data->tmrID )
-    {
-        killTimer( d_data->tmrID );
-        d_data->tmrID = 0;
-    }
+    d_data->isTracking = on;
 }
 
 /*!
-  \brief Specify the update interval for automatic scrolling
-  \param t update interval in milliseconds
-  \sa getScrollMode()
+  \return True, when tracking has been enabled
+  \sa setTracking()
 */
-void QwtAbstractSlider::setUpdateTime( int t )
+bool QwtAbstractSlider::isTracking() const
 {
-    if ( t < 50 )
-        t = 50;
-    d_data->updTime = t;
+    return d_data->isTracking;
 }
 
-
 /*!
    Mouse press event handler
-   \param e Mouse event
+   \param event Mouse event
 */
-void QwtAbstractSlider::mousePressEvent( QMouseEvent *e )
+void QwtAbstractSlider::mousePressEvent( QMouseEvent *event )
 {
     if ( isReadOnly() )
     {
-        e->ignore();
+        event->ignore();
         return;
     }
-    if ( !isValid() )
+
+    if ( !d_data->isValid || lowerBound() == upperBound() )
         return;
 
-    const QPoint &p = e->pos();
+    d_data->isScrolling = isScrollPosition( event->pos() );
 
-    d_data->timerTick = 0;
-
-    getScrollMode( p, d_data->scrollMode, d_data->direction );
-    stopMoving();
-
-    switch ( d_data->scrollMode )
+    if ( d_data->isScrolling )
     {
-        case ScrPage:
-        case ScrTimer:
-            d_data->mouseOffset = 0;
-            d_data->tmrID = startTimer( qMax( 250, 2 * d_data->updTime ) );
-            break;
+        d_data->pendingValueChanged = false;
 
-        case ScrMouse:
-            d_data->time.start();
-            d_data->speed = 0;
-            d_data->mouseOffset = getValue( p ) - value();
-            Q_EMIT sliderPressed();
-            break;
-
-        default:
-            d_data->mouseOffset = 0;
-            d_data->direction = 0;
-            break;
+        Q_EMIT sliderPressed();
     }
 }
 
-
-//! Emits a valueChanged() signal if necessary
-void QwtAbstractSlider::buttonReleased()
-{
-    if ( ( !d_data->tracking ) || ( value() != prevValue() ) )
-        Q_EMIT valueChanged( value() );
-}
-
-
 /*!
-   Mouse Release Event handler
-   \param e Mouse event
+   Mouse Move Event handler
+   \param event Mouse event
 */
-void QwtAbstractSlider::mouseReleaseEvent( QMouseEvent *e )
+void QwtAbstractSlider::mouseMoveEvent( QMouseEvent *event )
 {
     if ( isReadOnly() )
     {
-        e->ignore();
+        event->ignore();
         return;
     }
-    if ( !isValid() )
-        return;
 
-    const double inc = step();
-
-    switch ( d_data->scrollMode )
+    if ( d_data->isValid && d_data->isScrolling )
     {
-        case ScrMouse:
+        double value = scrolledTo( event->pos() );
+        if ( value != d_data->value )
         {
-            setPosition( e->pos() );
-            d_data->direction = 0;
-            d_data->mouseOffset = 0;
-            if ( d_data->mass > 0.0 )
+            value = boundedValue( value );
+
+            if ( d_data->stepAlignment )
             {
-                const int ms = d_data->time.elapsed();
-                if ( ( qFabs( d_data->speed ) >  0.0 ) && ( ms < 50 ) )
-                    d_data->tmrID = startTimer( d_data->updTime );
+                value = alignedValue( value );
             }
             else
             {
-                d_data->scrollMode = ScrNone;
-                buttonReleased();
+                value = qwtAlignToScaleDiv( this, value );
             }
-            Q_EMIT sliderReleased();
 
-            break;
-        }
+            if ( value != d_data->value )
+            {
+                d_data->value = value;
 
-        case ScrDirect:
-        {
-            setPosition( e->pos() );
-            d_data->direction = 0;
-            d_data->mouseOffset = 0;
-            d_data->scrollMode = ScrNone;
-            buttonReleased();
-            break;
-        }
+                sliderChange();
 
-        case ScrPage:
-        {
-            stopMoving();
-            if ( !d_data->timerTick )
-                QwtDoubleRange::incPages( d_data->direction );
-            d_data->timerTick = 0;
-            buttonReleased();
-            d_data->scrollMode = ScrNone;
-            break;
-        }
+                Q_EMIT sliderMoved( d_data->value );
 
-        case ScrTimer:
-        {
-            stopMoving();
-            if ( !d_data->timerTick )
-                QwtDoubleRange::fitValue( value() + double( d_data->direction ) * inc );
-            d_data->timerTick = 0;
-            buttonReleased();
-            d_data->scrollMode = ScrNone;
-            break;
+                if ( d_data->isTracking )
+                    Q_EMIT valueChanged( d_data->value );
+                else
+                    d_data->pendingValueChanged = true;
+            }
         }
-
-        default:
-        {
-            d_data->scrollMode = ScrNone;
-            buttonReleased();
-        }
     }
 }
 
-
 /*!
-  Move the slider to a specified point, adjust the value
-  and emit signals if necessary.
+   Mouse Release Event handler
+   \param event Mouse event
 */
-void QwtAbstractSlider::setPosition( const QPoint &p )
+void QwtAbstractSlider::mouseReleaseEvent( QMouseEvent *event )
 {
-    QwtDoubleRange::fitValue( getValue( p ) - d_data->mouseOffset );
-}
-
-
-/*!
-  \brief Enables or disables tracking.
-
-  If tracking is enabled, the slider emits a
-  valueChanged() signal whenever its value
-  changes (the default behaviour). If tracking
-  is disabled, the value changed() signal will only
-  be emitted if:<ul>
-  <li>the user releases the mouse
-      button and the value has changed or
-  <li>at the end of automatic scrolling.</ul>
-  Tracking is enabled by default.
-  \param enable \c true (enable) or \c false (disable) tracking.
-*/
-void QwtAbstractSlider::setTracking( bool enable )
-{
-    d_data->tracking = enable;
-}
-
-/*!
-   Mouse Move Event handler
-   \param e Mouse event
-*/
-void QwtAbstractSlider::mouseMoveEvent( QMouseEvent *e )
-{
     if ( isReadOnly() )
     {
-        e->ignore();
+        event->ignore();
         return;
     }
 
-    if ( !isValid() )
-        return;
+    if ( d_data->isScrolling && d_data->isValid )
+    {
+        d_data->isScrolling = false;
 
-    if ( d_data->scrollMode == ScrMouse )
-    {
-        setPosition( e->pos() );
-        if ( d_data->mass > 0.0 )
-        {
-            double ms = double( d_data->time.elapsed() );
-            if ( ms < 1.0 )
-                ms = 1.0;
-            d_data->speed = ( exactValue() - exactPrevValue() ) / ms;
-            d_data->time.start();
-        }
-        if ( value() != prevValue() )
-            Q_EMIT sliderMoved( value() );
+        if ( d_data->pendingValueChanged )
+            Q_EMIT valueChanged( d_data->value );
+
+        Q_EMIT sliderReleased();
     }
 }
 
 /*!
    Wheel Event handler
-   \param e Whell event
+
+   In/decreases the value by s number of steps. The direction 
+   depends on the invertedControls() property.
+
+   When the control or shift modifier is pressed the wheel delta
+   ( divided by 120 ) is mapped to an increment according to
+   pageSteps(). Otherwise it is mapped to singleSteps().
+
+   \param event Wheel event
 */
-void QwtAbstractSlider::wheelEvent( QWheelEvent *e )
+void QwtAbstractSlider::wheelEvent( QWheelEvent *event )
 {
     if ( isReadOnly() )
     {
-        e->ignore();
+        event->ignore();
         return;
     }
 
-    if ( !isValid() )
+    if ( !d_data->isValid || d_data->isScrolling )
         return;
 
-    QwtAbstractSlider::ScrollMode mode = ScrNone; 
-    int direction = 0;
+    int numSteps = 0;
 
-    // Give derived classes a chance to say ScrNone
-    getScrollMode( e->pos(), mode, direction );
-    if ( mode != QwtAbstractSlider::ScrNone )
+    if ( ( event->modifiers() & Qt::ControlModifier) ||
+        ( event->modifiers() & Qt::ShiftModifier ) )
     {
-        // Most mouse types work in steps of 15 degrees, in which case
-        // the delta value is a multiple of 120
+        // one page regardless of delta
+        numSteps = d_data->pageSteps;
+        if ( event->delta() < 0 )
+            numSteps = -numSteps;
+    }
+    else
+    {
+        const int numTurns = ( event->delta() / 120 );
+        numSteps = numTurns * d_data->singleSteps;
+    }
 
-        const int inc = e->delta() / 120;
-        QwtDoubleRange::incPages( inc );
-        if ( value() != prevValue() )
-            Q_EMIT sliderMoved( value() );
+    if ( d_data->invertedControls )
+        numSteps = -numSteps;
+
+    const double value = incrementedValue( d_data->value, numSteps );
+    if ( value != d_data->value )
+    {
+        d_data->value = value;
+        sliderChange();
+
+        Q_EMIT sliderMoved( d_data->value );
+        Q_EMIT valueChanged( d_data->value );
     }
 }
 
 /*!
   Handles key events
 
-  - Key_Down, KeyLeft\n
-    Decrement by 1
-  - Key_Up, Key_Right\n
-    Increment by 1
+  QwtAbstractSlider handles the following keys:
 
-  \param e Key event
+  - Qt::Key_Left\n
+    Add/Subtract singleSteps() in direction to lowerBound();
+  - Qt::Key_Right\n
+    Add/Subtract singleSteps() in direction to upperBound();
+  - Qt::Key_Down\n
+    Subtract singleSteps(), when invertedControls() is false
+  - Qt::Key_Up\n
+    Add singleSteps(), when invertedControls() is false
+  - Qt::Key_PageDown\n
+    Subtract pageSteps(), when invertedControls() is false
+  - Qt::Key_PageUp\n
+    Add pageSteps(), when invertedControls() is false
+  - Qt::Key_Home\n
+    Set the value to the minimum()
+  - Qt::Key_End\n
+    Set the value to the maximum()
+
+  \param event Key event
   \sa isReadOnly()
 */
-void QwtAbstractSlider::keyPressEvent( QKeyEvent *e )
+void QwtAbstractSlider::keyPressEvent( QKeyEvent *event )
 {
     if ( isReadOnly() )
     {
-        e->ignore();
+        event->ignore();
         return;
     }
 
-    if ( !isValid() )
+    if ( !d_data->isValid || d_data->isScrolling )
         return;
 
-    int increment = 0;
-    switch ( e->key() )
+    int numSteps = 0;
+    double value = d_data->value;
+
+    switch ( event->key() )
     {
-        case Qt::Key_Down:
-            if ( orientation() == Qt::Vertical )
-                increment = -1;
-            break;
-        case Qt::Key_Up:
-            if ( orientation() == Qt::Vertical )
-                increment = 1;
-            break;
         case Qt::Key_Left:
-            if ( orientation() == Qt::Horizontal )
-                increment = -1;
+        {
+            numSteps = -static_cast<int>( d_data->singleSteps );
+            if ( isInverted() )
+                numSteps = -numSteps;
+
             break;
+        }
         case Qt::Key_Right:
-            if ( orientation() == Qt::Horizontal )
-                increment = 1;
+        {
+            numSteps = d_data->singleSteps;
+            if ( isInverted() )
+                numSteps = -numSteps;
+
             break;
-        default:;
-            e->ignore();
-    }
-
-    if ( increment != 0 )
-    {
-        QwtDoubleRange::incValue( increment );
-        if ( value() != prevValue() )
-            Q_EMIT sliderMoved( value() );
-    }
-}
-
-/*!
-   Qt timer event
-   \param e Timer event
-*/
-void QwtAbstractSlider::timerEvent( QTimerEvent * )
-{
-    const double inc = step();
-
-    switch ( d_data->scrollMode )
-    {
-        case ScrMouse:
+        }
+        case Qt::Key_Down:
         {
-            if ( d_data->mass > 0.0 )
-            {
-                d_data->speed *= qExp( - double( d_data->updTime ) * 0.001 / d_data->mass );
-                const double newval =
-                    exactValue() + d_data->speed * double( d_data->updTime );
-                QwtDoubleRange::fitValue( newval );
-                // stop if d_data->speed < one step per second
-                if ( qFabs( d_data->speed ) < 0.001 * qFabs( step() ) )
-                {
-                    d_data->speed = 0;
-                    stopMoving();
-                    buttonReleased();
-                }
+            numSteps = -static_cast<int>( d_data->singleSteps );
+            if ( d_data->invertedControls )
+                numSteps = -numSteps;
+            break;
+        }
+        case Qt::Key_Up:
+        {
+            numSteps = d_data->singleSteps;
+            if ( d_data->invertedControls )
+                numSteps = -numSteps;
 
-            }
-            else
-                stopMoving();
             break;
         }
-
-        case ScrPage:
+        case Qt::Key_PageUp:
         {
-            QwtDoubleRange::incPages( d_data->direction );
-            if ( !d_data->timerTick )
-            {
-                killTimer( d_data->tmrID );
-                d_data->tmrID = startTimer( d_data->updTime );
-            }
+            numSteps = d_data->pageSteps;
+            if ( d_data->invertedControls )
+                numSteps = -numSteps;
             break;
         }
-        case ScrTimer:
+        case Qt::Key_PageDown:
         {
-            QwtDoubleRange::fitValue( value() +  double( d_data->direction ) * inc );
-            if ( !d_data->timerTick )
-            {
-                killTimer( d_data->tmrID );
-                d_data->tmrID = startTimer( d_data->updTime );
-            }
+            numSteps = -static_cast<int>( d_data->pageSteps );
+            if ( d_data->invertedControls )
+                numSteps = -numSteps;
             break;
         }
-        default:
+        case Qt::Key_Home:
         {
-            stopMoving();
+            value = minimum();
             break;
         }
+        case Qt::Key_End:
+        {
+            value = maximum();
+            break;
+        }
+        default:;
+        {
+            event->ignore();
+        }
     }
 
-    d_data->timerTick = 1;
+    if ( numSteps != 0 )
+    {
+        value = incrementedValue( d_data->value, numSteps );
+    }
+
+    if ( value != d_data->value )
+    {
+        d_data->value = value;
+        sliderChange();
+
+        Q_EMIT sliderMoved( d_data->value );
+        Q_EMIT valueChanged( d_data->value );
+    }
 }
 
-
 /*!
-  Notify change of value
+  \brief Set the number of steps
 
-  This function can be reimplemented by derived classes
-  in order to keep track of changes, i.e. repaint the widget.
-  The default implementation emits a valueChanged() signal
-  if tracking is enabled.
-*/
-void QwtAbstractSlider::valueChange()
+  The range of the slider is divided into a number of steps from
+  which the value increments according to user inputs depend. 
+
+  The default setting is 100.
+
+  \param stepCount Number of steps
+
+  \sa totalSteps(), setSingleSteps(), setPageSteps()
+ */
+void QwtAbstractSlider::setTotalSteps( uint stepCount )
 {
-    if ( d_data->tracking )
-        Q_EMIT valueChanged( value() );
+    d_data->totalSteps = stepCount;
 }
 
 /*!
-  \brief Set the slider's mass for flywheel effect.
+  \return Number of steps
+  \sa setTotalSteps(), singleSteps(), pageSteps()
+ */
+uint QwtAbstractSlider::totalSteps() const
+{
+    return d_data->totalSteps;
+}
 
-  If the slider's mass is greater then 0, it will continue
-  to move after the mouse button has been released. Its speed
-  decreases with time at a rate depending on the slider's mass.
-  A large mass means that it will continue to move for a
-  long time.
+/*!
+  \brief Set the number of steps for a single increment
 
-  Derived widgets may overload this function to make it public.
+  The range of the slider is divided into a number of steps from
+  which the value increments according to user inputs depend. 
 
-  \param val New mass in kg
+  \param stepCount Number of steps
 
-  \bug If the mass is smaller than 1g, it is set to zero.
-       The maximal mass is limited to 100kg.
-  \sa mass()
-*/
-void QwtAbstractSlider::setMass( double val )
+  \sa singleSteps(), setTotalSteps(), setPageSteps()
+ */
+
+void QwtAbstractSlider::setSingleSteps( uint stepCount )
 {
-    if ( val < 0.001 )
-        d_data->mass = 0.0;
-    else if ( val > 100.0 )
-        d_data->mass = 100.0;
-    else
-        d_data->mass = val;
+    d_data->singleSteps = stepCount;
+}   
+
+/*!
+  \return Number of steps
+  \sa setSingleSteps(), totalSteps(), pageSteps()
+ */
+uint QwtAbstractSlider::singleSteps() const
+{
+    return d_data->singleSteps;
+}   
+
+/*! 
+  \brief Set the number of steps for a page increment
+    
+  The range of the slider is divided into a number of steps from
+  which the value increments according to user inputs depend. 
+
+  \param stepCount Number of steps
+
+  \sa pageSteps(), setTotalSteps(), setSingleSteps()
+ */
+
+void QwtAbstractSlider::setPageSteps( uint stepCount )
+{
+    d_data->pageSteps = stepCount;
 }
 
 /*!
-    \return mass
-    \sa setMass()
-*/
-double QwtAbstractSlider::mass() const
+  \return Number of steps
+  \sa setPageSteps(), totalSteps(), singleSteps()
+ */
+uint QwtAbstractSlider::pageSteps() const
 {
-    return d_data->mass;
+    return d_data->pageSteps;
 }
 
+/*!
+  \brief Enable step alignment
 
+  When step alignment is enabled values resulting from slider
+  movements are aligned to the step size.
+
+  \param on Enable step alignment when true
+  \sa stepAlignment()
+*/
+void QwtAbstractSlider::setStepAlignment( bool on )
+{   
+    if ( on != d_data->stepAlignment )
+    {
+        d_data->stepAlignment = on;
+    }
+}   
+    
 /*!
-  \brief Move the slider to a specified value
+  \return True, when step alignment is enabled
+  \sa setStepAlignment()
+ */
+bool QwtAbstractSlider::stepAlignment() const
+{
+    return d_data->stepAlignment;
+}
 
-  This function can be used to move the slider to a value
-  which is not an integer multiple of the step size.
-  \param val new value
-  \sa fitValue()
+/*!
+  Set the slider to the specified value
+
+  \param value New value
+  \sa setValid(), sliderChange(), valueChanged()
 */
-void QwtAbstractSlider::setValue( double val )
+void QwtAbstractSlider::setValue( double value )
 {
-    if ( d_data->scrollMode == ScrMouse )
-        stopMoving();
-    QwtDoubleRange::setValue( val );
+    value = qBound( minimum(), value, maximum() );
+
+    const bool changed = ( d_data->value != value ) || !d_data->isValid;
+
+    d_data->value = value;
+    d_data->isValid = true;
+
+    if ( changed )
+    {
+        sliderChange();
+        Q_EMIT valueChanged( d_data->value );
+    }
 }
 
+//! Returns the current value.
+double QwtAbstractSlider::value() const
+{
+    return d_data->value;
+}
 
 /*!
-  \brief Set the slider's value to the nearest integer multiple
-         of the step size.
+  If wrapping is true stepping up from upperBound() value will 
+  take you to the minimum() value and vice versa. 
 
-   \param value Value
-   \sa setValue(), incValue()
+  \param on En/Disable wrapping
+  \sa wrapping()
 */
-void QwtAbstractSlider::fitValue( double value )
+void QwtAbstractSlider::setWrapping( bool on )
 {
-    if ( d_data->scrollMode == ScrMouse )
-        stopMoving();
-    QwtDoubleRange::fitValue( value );
+    d_data->wrapping = on;
+}   
+
+/*!
+  \return True, when wrapping is set
+  \sa setWrapping()
+ */ 
+bool QwtAbstractSlider::wrapping() const
+{
+    return d_data->wrapping;
 }
 
 /*!
-  \brief Increment the value by a specified number of steps
-  \param steps number of steps
-  \sa setValue()
-*/
-void QwtAbstractSlider::incValue( int steps )
+  Invert wheel and key events
+
+  Usually scrolling the mouse wheel "up" and using keys like page 
+  up will increase the slider's value towards its maximum. 
+  When invertedControls() is enabled the value is scrolled
+  towards its minimum.
+
+  Inverting the controls might be f.e. useful for a vertical slider
+  with an inverted scale ( decreasing from top to bottom ).
+
+  \param on Invert controls, when true
+
+  \sa invertedControls(), keyEvent(), wheelEvent()
+ */
+void QwtAbstractSlider::setInvertedControls( bool on )
 {
-    if ( d_data->scrollMode == ScrMouse )
-        stopMoving();
-    QwtDoubleRange::incValue( steps );
+    d_data->invertedControls = on;
 }
 
 /*!
-  \sa mouseOffset()
-*/
-void QwtAbstractSlider::setMouseOffset( double offset )
+ \return True, when the controls are inverted
+ \sa setInvertedControls()
+ */
+bool QwtAbstractSlider::invertedControls() const
 {
-    d_data->mouseOffset = offset;
+    return d_data->invertedControls;
 }
 
 /*!
-  \sa setMouseOffset()
-*/
-double QwtAbstractSlider::mouseOffset() const
+  Increment the slider
+
+  The step size depends on the number of totalSteps()
+
+  \param stepCount Number of steps
+  \sa setTotalSteps(), incrementedValue()
+ */
+void QwtAbstractSlider::incrementValue( int stepCount )
 {
-    return d_data->mouseOffset;
+    const double value = incrementedValue( 
+        d_data->value, stepCount );
+
+    if ( value != d_data->value )
+    {
+        d_data->value = value;
+        sliderChange();
+    }
 }
 
-//! sa ScrollMode
-int QwtAbstractSlider::scrollMode() const
+/*!
+  Increment a value 
+
+  \param value Value 
+  \param stepCount Number of steps
+
+  \return Incremented value
+ */
+double QwtAbstractSlider::incrementedValue( 
+    double value, int stepCount ) const
 {
-    return d_data->scrollMode;
+    if ( d_data->totalSteps == 0 )
+        return value;
+
+    const QwtTransform *transformation =
+        scaleMap().transformation();
+
+    if ( transformation == NULL )
+    {
+        const double range = maximum() - minimum();
+        value += stepCount * range / d_data->totalSteps;
+    }
+    else
+    {
+        QwtScaleMap map = scaleMap();
+        map.setPaintInterval( 0, d_data->totalSteps );
+
+        // we need equidant steps according to
+        // paint device coordinates
+        const double range = transformation->transform( maximum() ) 
+            - transformation->transform( minimum() );
+
+        const double stepSize = range / d_data->totalSteps;
+
+        double v = transformation->transform( value );
+
+        v = qRound( v / stepSize ) * stepSize; 
+        v += stepCount * range / d_data->totalSteps;
+
+        value = transformation->invTransform( v );
+    }
+
+    value = boundedValue( value );
+
+    if ( d_data->stepAlignment )
+        value = alignedValue( value );
+
+    return value;
 }
+
+double QwtAbstractSlider::boundedValue( double value ) const
+{
+    const double vmin = minimum();
+    const double vmax = maximum();
+
+    if ( d_data->wrapping && vmin != vmax )
+    {
+        const int fullCircle = 360 * 16;
+
+        const double pd = scaleMap().pDist();
+        if ( int( pd / fullCircle ) * fullCircle == pd )
+        {
+            // full circle scales: min and max are the same
+            const double range = vmax - vmin;
+
+            if ( value < vmin )
+            {
+                value += ::ceil( ( vmin - value ) / range ) * range;
+            }
+            else if ( value > vmax )
+            {
+                value -= ::ceil( ( value - vmax ) / range ) * range;
+            }
+        }
+        else
+        {
+            if ( value < vmin )
+                value = vmax;
+            else if ( value > vmax )
+                value = vmin;
+        }
+    }
+    else
+    {
+        value = qBound( vmin, value, vmax );
+    }
+
+    return value;
+}
+
+double QwtAbstractSlider::alignedValue( double value ) const
+{
+    if ( d_data->totalSteps == 0 )
+        return value;
+
+    if ( scaleMap().transformation() == NULL )
+    {
+        const double stepSize = 
+            ( maximum() - minimum() ) / d_data->totalSteps;
+
+        if ( stepSize > 0.0 )
+        {
+            value = lowerBound() + 
+                qRound( ( value - lowerBound() ) / stepSize ) * stepSize;
+        }
+    }
+    else
+    {
+        const double stepSize = 
+            ( scaleMap().p2() - scaleMap().p1() ) / d_data->totalSteps;
+
+        if ( stepSize > 0.0 )
+        {
+            double v = scaleMap().transform( value );
+
+            v = scaleMap().p1() +
+                qRound( ( v - scaleMap().p1() ) / stepSize ) * stepSize;
+
+            value = scaleMap().invTransform( v );
+        }
+    }
+
+    // correct rounding error if value = 0
+    if ( qFuzzyCompare( value + 1.0, 1.0 ) )
+    {
+        value = 0.0;
+    }
+    else
+    {
+        // correct rounding error at the border
+        if ( qFuzzyCompare( value, upperBound() ) )
+            value = upperBound();
+        else if ( qFuzzyCompare( value, lowerBound() ) )
+            value = lowerBound();
+    }
+
+    return value;
+}
+
+/*!
+  Update the slider according to modifications of the scale
+ */
+void QwtAbstractSlider::scaleChange()
+{
+    const double value = qBound( minimum(), d_data->value, maximum() );
+
+    const bool changed = ( value != d_data->value );
+    if ( changed )
+    {
+        d_data->value = value;
+    }
+
+    if ( d_data->isValid || changed )
+        Q_EMIT valueChanged( d_data->value );
+
+    updateGeometry();
+    update();
+}
+
+//! Calling update()
+void QwtAbstractSlider::sliderChange()
+{
+    update();
+}
Index: qwt_color_map.cpp
===================================================================
--- qwt_color_map.cpp	(revision 382)
+++ qwt_color_map.cpp	(working copy)
@@ -204,7 +204,7 @@
 
    \param color1 Color used for the minimum value of the value interval
    \param color2 Color used for the maximum value of the value interval
-   \param format Preferred format of the coor map
+   \param format Preferred format for the color map
 */
 QwtLinearColorMap::QwtLinearColorMap( const QColor &color1,
         const QColor &color2, QwtColorMap::Format format ):
@@ -279,7 +279,7 @@
 }
 
 /*!
-   Return all positions of color stops in increasing order
+   \return Positions of color stops in increasing order
 */
 QVector<double> QwtLinearColorMap::colorStops() const
 {
@@ -305,10 +305,12 @@
 }
 
 /*!
-  Map a value of a given interval into a rgb value
+  Map a value of a given interval into a RGB value
 
   \param interval Range for all values
-  \param value Value to map into a rgb value
+  \param value Value to map into a RGB value
+
+  \return RGB value for value
 */
 QRgb QwtLinearColorMap::rgb(
     const QwtInterval &interval, double value ) const
@@ -326,10 +328,12 @@
 }
 
 /*!
-  Map a value of a given interval into a color index, between 0 and 255
+  \brief Map a value of a given interval into a color index
 
   \param interval Range for all values
   \param value Value to map into a color index
+
+  \return Index, between 0 and 255
 */
 unsigned char QwtLinearColorMap::colorIndex(
     const QwtInterval &interval, double value ) const
@@ -406,8 +410,8 @@
   alpha := (value - interval.minValue()) / interval.width();
 
   \param interval Range for all values
-  \param value Value to map into a rgb value
-  \return rgb value, with an alpha value
+  \param value Value to map into a RGB value
+  \return RGB value, with an alpha value
 */
 QRgb QwtAlphaColorMap::rgb( const QwtInterval &interval, double value ) const
 {
Index: qwt_interval_symbol.h
===================================================================
--- qwt_interval_symbol.h	(revision 382)
+++ qwt_interval_symbol.h	(working copy)
@@ -68,6 +68,7 @@
     void setBrush( const QBrush& b );
     const QBrush& brush() const;
 
+    void setPen( const QColor &, qreal width = 0.0, Qt::PenStyle = Qt::SolidLine );
     void setPen( const QPen & );
     const QPen& pen() const;
 
Index: qwt_plot_spectrocurve.cpp
===================================================================
--- qwt_plot_spectrocurve.cpp	(revision 382)
+++ qwt_plot_spectrocurve.cpp	(working copy)
@@ -98,7 +98,7 @@
 }
 
 /*!
-    \brief Return the current paint attributes
+    \return True, when attribute is enabled
     \sa PaintAttribute, setPaintAttribute()
 */
 bool QwtPlotSpectroCurve::testPaintAttribute( PaintAttribute attribute ) const
@@ -116,6 +116,22 @@
 }
 
 /*!
+  Assign a series of samples
+    
+  setSamples() is just a wrapper for setData() without any additional
+  value - beside that it is easier to find for the developer.
+    
+  \param data Data
+  \warning The item takes ownership of the data object, deleting
+           it when its not used anymore. 
+*/
+void QwtPlotSpectroCurve::setSamples(
+    QwtSeriesData<QwtPoint3D> *data )
+{
+    setData( data );
+}  
+
+/*!
   Change the color map
 
   Often it is useful to display the mapping between intensities and
@@ -210,7 +226,7 @@
   \param painter Painter
   \param xMap Maps x-values into pixel coordinates.
   \param yMap Maps y-values into pixel coordinates.
-  \param canvasRect Contents rect of the canvas
+  \param canvasRect Contents rectangle of the canvas
   \param from Index of the first sample to be painted
   \param to Index of the last sample to be painted. If to < 0 the
          series will be painted to its last sample.
@@ -242,7 +258,7 @@
   \param painter Painter
   \param xMap Maps x-values into pixel coordinates.
   \param yMap Maps y-values into pixel coordinates.
-  \param canvasRect Contents rect of the canvas
+  \param canvasRect Contents rectangle of the canvas
   \param from Index of the first sample to be painted
   \param to Index of the last sample to be painted. If to < 0 the
          series will be painted to its last sample.
Index: qwt_plot_intervalcurve.cpp
===================================================================
--- qwt_plot_intervalcurve.cpp	(revision 382)
+++ qwt_plot_intervalcurve.cpp	(working copy)
@@ -12,6 +12,7 @@
 #include "qwt_scale_map.h"
 #include "qwt_clipper.h"
 #include "qwt_painter.h"
+#include <string.h>
 
 #include <qpainter.h>
 
@@ -23,7 +24,7 @@
     const double x2 = sample.interval.maxValue();
 
     const bool isOffScreen = ( y < yMin ) || ( y > yMax )
-        || ( x1 < xMin && x2 < xMin ) || ( x1 > yMax && x2 > xMax );
+        || ( x1 < xMin && x2 < xMin ) || ( x1 > xMax && x2 > xMax );
 
     return !isOffScreen;
 }
@@ -131,7 +132,7 @@
 }
 
 /*!
-    \brief Return the current paint attributes
+    \return True, when attribute is enabled
     \sa PaintAttribute, setPaintAttribute()
 */
 bool QwtPlotIntervalCurve::testPaintAttribute(
@@ -151,6 +152,22 @@
 }
 
 /*!
+  Assign a series of samples
+    
+  setSamples() is just a wrapper for setData() without any additional
+  value - beside that it is easier to find for the developer.
+    
+  \param data Data
+  \warning The item takes ownership of the data object, deleting
+           it when its not used anymore.
+*/
+void QwtPlotIntervalCurve::setSamples( 
+    QwtSeriesData<QwtIntervalSample> *data )
+{
+    setData( data );
+}
+
+/*!
   Set the curve's drawing style
 
   \param style Curve style
@@ -168,7 +185,7 @@
 }
 
 /*!
-    \brief Return the current style
+    \return Style of the curve
     \sa setStyle()
 */
 QwtPlotIntervalCurve::CurveStyle QwtPlotIntervalCurve::style() const
@@ -204,6 +221,24 @@
 }
 
 /*!
+  Build and assign a pen
+    
+  In Qt5 the default pen width is 1.0 ( 0.0 in Qt4 ) what makes it
+  non cosmetic ( see QPen::isCosmetic() ). This method has been introduced
+  to hide this incompatibility.
+    
+  \param color Pen color
+  \param width Pen width
+  \param style Pen style
+    
+  \sa pen(), brush()
+ */
+void QwtPlotIntervalCurve::setPen( const QColor &color, qreal width, Qt::PenStyle style )
+{   
+    setPen( QPen( color, width, style ) );
+}   
+
+/*!
   \brief Assign a pen
   \param pen New pen
   \sa pen(), brush()
@@ -220,7 +255,7 @@
 }
 
 /*!
-    \brief Return the pen used to draw the lines
+    \return Pen used to draw the lines
     \sa setPen(), brush()
 */
 const QPen& QwtPlotIntervalCurve::pen() const
@@ -275,7 +310,7 @@
   \param painter Painter
   \param xMap Maps x-values into pixel coordinates.
   \param yMap Maps y-values into pixel coordinates.
-  \param canvasRect Contents rect of the canvas
+  \param canvasRect Contents rectangle of the canvas
   \param from Index of the first sample to be painted
   \param to Index of the last sample to be painted. If to < 0 the
          series will be painted to its last sample.
@@ -324,7 +359,7 @@
   \param painter Painter
   \param xMap Maps x-values into pixel coordinates.
   \param yMap Maps y-values into pixel coordinates.
-  \param canvasRect Contents rect of the canvas
+  \param canvasRect Contents rectangle of the canvas
   \param from Index of the first sample to be painted
   \param to Index of the last sample to be painted. If to < 0 the
          series will be painted to its last sample.
@@ -417,13 +452,13 @@
             QPolygonF p;
 
             p.resize( size );
-            qMemCopy( p.data(), points, size * sizeof( QPointF ) );
-            p = QwtClipper::clipPolygonF( canvasRect, p );
+            ::memcpy( p.data(), points, size * sizeof( QPointF ) );
+            p = QwtClipper::clipPolygonF( clipRect, p );
             QwtPainter::drawPolyline( painter, p );
 
             p.resize( size );
-            qMemCopy( p.data(), points + size, size * sizeof( QPointF ) );
-            p = QwtClipper::clipPolygonF( canvasRect, p );
+            ::memcpy( p.data(), points + size, size * sizeof( QPointF ) );
+            p = QwtClipper::clipPolygonF( clipRect, p );
             QwtPainter::drawPolyline( painter, p );
         }
         else
@@ -443,7 +478,7 @@
   \param symbol Interval symbol
   \param xMap x map
   \param yMap y map
-  \param canvasRect Contents rect of the canvas
+  \param canvasRect Contents rectangle of the canvas
   \param from Index of the first sample to be painted
   \param to Index of the last sample to be painted
 
Index: qwt_column_symbol.h
===================================================================
--- qwt_column_symbol.h	(revision 382)
+++ qwt_column_symbol.h	(working copy)
@@ -22,7 +22,7 @@
 class QwtText;
 
 /*!
-    \brief Directed rectangle representing bounding rectangle und orientation
+    \brief Directed rectangle representing bounding rectangle and orientation
     of a column.
 */
 class QWT_EXPORT QwtColumnRect
Index: qwt_text.h
===================================================================
--- qwt_text.h	(revision 382)
+++ qwt_text.h	(working copy)
@@ -32,17 +32,18 @@
     A text might include control sequences (f.e tags) describing
     how to render it. Each format (f.e MathML, TeX, Qt Rich Text)
     has its own set of control sequences, that can be handles by
-    a QwtTextEngine for this format.
+    a special QwtTextEngine for this format.
   - Background\n
     A text might have a background, defined by a QPen and QBrush
-    to improve its visibility.
+    to improve its visibility. The corners of the background might
+    be rounded.
   - Font\n
     A text might have an individual font.
   - Color\n
     A text might have an individual color.
   - Render Flags\n
     Flags from Qt::AlignmentFlag and Qt::TextFlag used like in
-    QPainter::drawText.
+    QPainter::drawText().
 
   \sa QwtTextEngine, QwtTextLabel
 */
@@ -63,7 +64,7 @@
     enum TextFormat
     {
         /*!
-          The text format is determined using QwtTextEngine::mightRender for
+          The text format is determined using QwtTextEngine::mightRender() for
           all available text engines in increasing order > PlainText.
           If none of the text engines can render the text is rendered
           like QwtText::PlainText.
@@ -168,9 +169,12 @@
 
     QColor usedColor( const QColor & ) const;
 
-    void setBackgroundPen( const QPen & );
-    QPen backgroundPen() const;
+    void setBorderRadius( double );
+    double borderRadius() const;
 
+    void setBorderPen( const QPen & );
+    QPen borderPen() const;
+
     void setBackgroundBrush( const QBrush & );
     QBrush backgroundBrush() const;
 
Index: qwt_plot_barchart.h
===================================================================
--- qwt_plot_barchart.h	(revision 382)
+++ qwt_plot_barchart.h	(working copy)
@@ -11,16 +11,62 @@
 #define QWT_PLOT_BAR_CHART_H
 
 #include "qwt_global.h"
-#include "qwt_plot_baritem.h"
+#include "qwt_plot_abstract_barchart.h"
 #include "qwt_series_data.h"
 
 class QwtColumnRect;
 class QwtColumnSymbol;
 
+/*!
+  \brief QwtPlotBarChart displays a series of a values as bars.
+
+  Each bar might be customized individually by implementing
+  a specialSymbol(). Otherwise it is rendered using a default symbol.
+
+  Depending on its orientation() the bars are displayed horizontally 
+  or vertically. The bars cover the interval between the baseline() 
+  and the value.
+
+  By activating the LegendBarTitles mode each sample will have
+  its own entry on the legend.
+
+  The most common use case of a bar chart is to display a
+  list of y coordinates, where the x coordinate is simply the index
+  in the list. But for other situations ( f.e. when values are related
+  to dates ) it is also possible to set x coordinates explicitly.
+
+  \sa QwtPlotMultiBarChart, QwtPlotHistogram, QwtPlotCurve::Sticks,
+      QwtPlotSeriesItem::orientation(), QwtPlotAbstractBarChart::baseline()
+ */
 class QWT_EXPORT QwtPlotBarChart:
-    public QwtPlotBarItem, public QwtSeriesStore<QPointF>
+    public QwtPlotAbstractBarChart, public QwtSeriesStore<QPointF>
 {
 public:
+    /*!
+      \brief Legend modes.
+
+      The default setting is QwtPlotBarChart::LegendChartTitle.
+      \sa setLegendMode(), legendMode()
+    */
+    enum LegendMode
+    {
+        /*! 
+          One entry on the legend showing the default symbol
+          and the title() of the chart
+
+          \sa QwtPlotItem::title()
+         */
+        LegendChartTitle,
+
+        /*!
+          One entry for each value showing the individual symbol
+          of the corresponding bar and the bar title.
+
+          \sa specialSymbol(), barTitle()
+         */
+        LegendBarTitles
+    };
+
     explicit QwtPlotBarChart( const QString &title = QString::null );
     explicit QwtPlotBarChart( const QwtText &title );
 
@@ -30,16 +76,25 @@
 
     void setSamples( const QVector<QPointF> & );
     void setSamples( const QVector<double> & );
+    void setSamples( QwtSeriesData<QPointF> *series );
 
     void setSymbol( QwtColumnSymbol * );
     const QwtColumnSymbol *symbol() const;
 
+    void setLegendMode( LegendMode );
+    LegendMode legendMode() const;
+
     virtual void drawSeries( QPainter *painter,
         const QwtScaleMap &xMap, const QwtScaleMap &yMap,
         const QRectF &canvasRect, int from, int to ) const;
 
     virtual QRectF boundingRect() const;
 
+    virtual QwtColumnSymbol *specialSymbol( 
+        int sampleIndex, const QPointF& ) const;
+
+    virtual QwtText barTitle( int sampleIndex ) const;
+
 protected:
     virtual void drawSample( QPainter *painter,
         const QwtScaleMap &xMap, const QwtScaleMap &yMap,
@@ -47,13 +102,12 @@
         int index, const QPointF& sample ) const;
 
     virtual void drawBar( QPainter *,
-        int sampleIndex, const QwtColumnRect & ) const;
+        int sampleIndex, const QPointF& point, 
+        const QwtColumnRect & ) const;
 
-    virtual void drawLabel( QPainter *, int sampleIndex,
-        const QwtColumnRect &, const QwtText & ) const;
+    QList<QwtLegendData> legendData() const;
+    QwtGraphic legendIcon( int index, const QSizeF & ) const;
 
-    virtual QwtText label( int sampleIndex, const QPointF & ) const;
-
 private:
     void init();
 
Index: qwt_dial_needle.h
===================================================================
--- qwt_dial_needle.h	(revision 382)
+++ qwt_dial_needle.h	(working copy)
@@ -22,9 +22,6 @@
   QwtDialNeedle is a pointer that indicates a value by pointing
   to a specific direction.
 
-  Qwt is missing a set of good looking needles.
-  Contributions are very welcome.
-
   \sa QwtDial, QwtCompass
 */
 
@@ -48,7 +45,7 @@
       The origin of the needle is at position (0.0, 0.0 )
       pointing in direction 0.0 ( = east ). 
 
-      The painter is already initilaized with translation and 
+      The painter is already initialized with translation and 
       rotation.
 
       \param painter Painter
Index: qwt_math.h
===================================================================
--- qwt_math.h	(revision 382)
+++ qwt_math.h	(working copy)
@@ -26,24 +26,14 @@
 #include <qmath.h>
 #include "qwt_global.h"
 
-#ifndef LOG10_2
-#define LOG10_2     0.30102999566398119802  /* log10(2) */
+#ifndef M_PI_2
+// For Qt <= 4.8.4 M_PI_2 is not known by MinGW-w64 
+// when compiling with -std=c++11
+#define M_PI_2 (1.57079632679489661923)
 #endif
 
-#ifndef LOG10_3
-#define LOG10_3     0.47712125471966243540  /* log10(3) */
-#endif
-
-#ifndef LOG10_5
-#define LOG10_5     0.69897000433601885749  /* log10(5) */
-#endif
-
-#ifndef M_2PI
-#define M_2PI       6.28318530717958623200  /* 2 pi */
-#endif
-
 #ifndef LOG_MIN
-//! Mininum value for logarithmic scales
+//! Minimum value for logarithmic scales
 #define LOG_MIN 1.0e-100
 #endif
 
@@ -52,61 +42,12 @@
 #define LOG_MAX 1.0e100
 #endif
 
-#ifndef M_E
-#define M_E            2.7182818284590452354   /* e */
-#endif
-
-#ifndef M_LOG2E
-#define M_LOG2E 1.4426950408889634074   /* log_2 e */
-#endif
-
-#ifndef M_LOG10E
-#define M_LOG10E    0.43429448190325182765  /* log_10 e */
-#endif
-
-#ifndef M_LN2
-#define M_LN2       0.69314718055994530942  /* log_e 2 */
-#endif
-
-#ifndef M_LN10
-#define M_LN10         2.30258509299404568402  /* log_e 10 */
-#endif
-
-#ifndef M_PI
-#define M_PI        3.14159265358979323846  /* pi */
-#endif
-
-#ifndef M_PI_2
-#define M_PI_2      1.57079632679489661923  /* pi/2 */
-#endif
-
-#ifndef M_PI_4
-#define M_PI_4      0.78539816339744830962  /* pi/4 */
-#endif
-
-#ifndef M_1_PI
-#define M_1_PI      0.31830988618379067154  /* 1/pi */
-#endif
-
-#ifndef M_2_PI
-#define M_2_PI      0.63661977236758134308  /* 2/pi */
-#endif
-
-#ifndef M_2_SQRTPI
-#define M_2_SQRTPI  1.12837916709551257390  /* 2/sqrt(pi) */
-#endif
-
-#ifndef M_SQRT2
-#define M_SQRT2 1.41421356237309504880  /* sqrt(2) */
-#endif
-
-#ifndef M_SQRT1_2
-#define M_SQRT1_2   0.70710678118654752440  /* 1/sqrt(2) */
-#endif
-
 QWT_EXPORT double qwtGetMin( const double *array, int size );
 QWT_EXPORT double qwtGetMax( const double *array, int size );
 
+QWT_EXPORT double qwtNormalizeRadians( double radians );
+QWT_EXPORT double qwtNormalizeDegrees( double degrees );
+
 /*!
   \brief Compare 2 values, relative to an interval
 
@@ -193,4 +134,16 @@
     return 0.0;
 }
 
+// Translate degrees into radians
+inline double qwtRadians( double degrees )
+{
+    return degrees * M_PI / 180.0;
+}
+
+// Translate radians into degrees
+inline double qwtDegrees( double degrees )
+{
+    return degrees * 180.0 / M_PI;
+}
+
 #endif
Index: qwt_system_clock.cpp
===================================================================
--- qwt_system_clock.cpp	(revision 382)
+++ qwt_system_clock.cpp	(working copy)
@@ -159,7 +159,7 @@
         mach_timebase_info_data_t info;
         kern_return_t err = mach_timebase_info( &info );
 
-        //Convert the timebase into ms
+        // convert the timebase into ms
         if ( err == 0  )
             conversion = 1e-6 * ( double ) info.numer / ( double ) info.denom;
     }
@@ -356,9 +356,8 @@
 }
 
 /*!
-  The start time to the current time and
-  return the time, that is elapsed since the
-  previous start time.
+  Set the start time to the current time 
+  \return Time, that is elapsed since the previous start time.
 */
 double QwtSystemClock::restart()
 {
Index: qwt_plot_directpainter.h
===================================================================
--- qwt_plot_directpainter.h	(revision 382)
+++ qwt_plot_directpainter.h	(working copy)
@@ -54,7 +54,7 @@
         AtomicPainter = 0x01,
 
         /*!
-          When FullRepaint is set the plot canvas is explicitely repainted
+          When FullRepaint is set the plot canvas is explicitly repainted
           after the samples have been rendered.
          */
         FullRepaint = 0x02,
@@ -63,7 +63,7 @@
           When QwtPlotCanvas::BackingStore is enabled the painter
           has to paint to the backing store and the widget. In certain 
           situations/environments it might be faster to paint to 
-          the backing store only and then copy the backingstore to the canvas.
+          the backing store only and then copy the backing store to the canvas.
           This flag can also be useful for settings, where Qt fills the
           the clip region with the widget background.
          */
Index: qwt_plot_scaleitem.cpp
===================================================================
--- qwt_plot_scaleitem.cpp	(revision 382)
+++ qwt_plot_scaleitem.cpp	(working copy)
@@ -9,7 +9,6 @@
 
 #include "qwt_plot_scaleitem.h"
 #include "qwt_plot.h"
-#include "qwt_plot_canvas.h"
 #include "qwt_scale_map.h"
 #include "qwt_interval.h"
 #include <qpalette.h>
@@ -46,8 +45,6 @@
 void QwtPlotScaleItem::PrivateData::updateBorders( const QRectF &canvasRect,
     const QwtScaleMap &xMap, const QwtScaleMap &yMap )
 {
-    canvasRectCache = canvasRect;
-
     QwtInterval interval;
     if ( scaleDraw->orientation() == Qt::Horizontal )
     {
@@ -64,6 +61,7 @@
     scaleDiv.setInterval( interval );
     scaleDraw->setScaleDiv( scaleDiv );
 }
+
 /*!
    \brief Constructor for scale item at the position pos.
 
@@ -284,7 +282,7 @@
    \brief Align the scale to the canvas
 
    If distance is >= 0 the scale will be aligned to a
-   border of the contents rect of the canvas. If
+   border of the contents rectangle of the canvas. If
    alignment() is QwtScaleDraw::LeftScale, the scale will
    be aligned to the right border, if it is QwtScaleDraw::TopScale
    it will be aligned to the bottom (and vice versa),
@@ -353,7 +351,10 @@
     if ( d_data->scaleDivFromAxis )
     {
         if ( canvasRect != d_data->canvasRectCache )
+        {
             d_data->updateBorders( canvasRect, xMap, yMap );
+            d_data->canvasRectCache = canvasRect;
+        }
     }
 
     QPen pen = painter->pen();
@@ -384,7 +385,12 @@
 
         sd->move( canvasRect.left(), y );
         sd->setLength( canvasRect.width() - 1 );
-        sd->setTransformation( xMap.transformation()->copy() );
+
+        QwtTransform *transform = NULL;
+        if ( xMap.transformation() )
+            transform = xMap.transformation()->copy();
+
+        sd->setTransformation( transform );
     }
     else // == Qt::Vertical
     {
@@ -407,7 +413,12 @@
 
         sd->move( x, canvasRect.top() );
         sd->setLength( canvasRect.height() - 1 );
-        sd->setTransformation( yMap.transformation()->copy() );
+
+        QwtTransform *transform = NULL;
+        if ( yMap.transformation() )
+            transform = yMap.transformation()->copy();
+
+        sd->setTransformation( transform );
     }
 
     painter->setFont( d_data->font );
@@ -441,6 +452,7 @@
         {
             d_data->updateBorders( plt->canvas()->contentsRect(),
                 plt->canvasMap( xAxis() ), plt->canvasMap( yAxis() ) );
+            d_data->canvasRectCache = QRect();
         }
     }
 }
Index: qwt_symbol.cpp
===================================================================
--- qwt_symbol.cpp	(revision 382)
+++ qwt_symbol.cpp	(working copy)
@@ -843,7 +843,7 @@
 QwtSymbol::QwtSymbol( Style style )
 {
     d_data = new PrivateData( style, QBrush( Qt::gray ),
-        QPen( Qt::black ), QSize() );
+        QPen( Qt::black, 0 ), QSize() );
 }
 
 /*!
@@ -875,8 +875,8 @@
   \sa setPath(), setBrush(), setPen(), setSize()
 */
 
-QwtSymbol::QwtSymbol( const QPainterPath &path, const QBrush &brush,
-    const QPen &pen )
+QwtSymbol::QwtSymbol( const QPainterPath &path, 
+    const QBrush &brush, const QPen &pen )
 {
     d_data = new PrivateData( QwtSymbol::Path, brush, pen, QSize() );
     setPath( path );
@@ -978,37 +978,77 @@
     return d_data->path.path;
 }
 
+/*!
+  Set a pixmap as symbol
+
+  \param pixmap Pixmap
+
+  \sa pixmap(), setGraphic()
+
+  \note the style() is set to QwtSymbol::Pixmap
+  \note brush() and pen() have no effect
+ */
 void QwtSymbol::setPixmap( const QPixmap &pixmap )
 {
     d_data->style = QwtSymbol::Pixmap;
     d_data->pixmap.pixmap = pixmap;
 }
 
+/*!
+  \return Assigned pixmap
+  \sa setPixmap()
+ */
 const QPixmap &QwtSymbol::pixmap() const
 {
     return d_data->pixmap.pixmap;
 }
 
+/*!
+  Set a graphic as symbol
+
+  \param graphic Graphic
+
+  \sa graphic(), setPixmap()
+
+  \note the style() is set to QwtSymbol::Graphic
+  \note brush() and pen() have no effect
+ */
 void QwtSymbol::setGraphic( const QwtGraphic &graphic )
 {
     d_data->style = QwtSymbol::Graphic;
     d_data->graphic.graphic = graphic;
 }
 
+/*!
+  \return Assigned graphic
+  \sa setGraphic()
+ */
 const QwtGraphic &QwtSymbol::graphic() const
 {
     return d_data->graphic.graphic;
 }
 
 #ifndef QWT_NO_SVG
-    void QwtSymbol::setSvgDocument( const QByteArray &svgDocument )
-    {
-        d_data->style = QwtSymbol::SvgDocument;
-        if ( d_data->svg.renderer == NULL )
-            d_data->svg.renderer = new QSvgRenderer();
 
-        d_data->svg.renderer->load( svgDocument );
-    }
+/*!
+  Set a SVG icon as symbol
+
+  \param svgDocument SVG icon
+
+  \sa setGraphic(), setPixmap()
+
+  \note the style() is set to QwtSymbol::SvgDocument
+  \note brush() and pen() have no effect
+ */
+void QwtSymbol::setSvgDocument( const QByteArray &svgDocument )
+{
+    d_data->style = QwtSymbol::SvgDocument;
+    if ( d_data->svg.renderer == NULL )
+        d_data->svg.renderer = new QSvgRenderer();
+
+    d_data->svg.renderer->load( svgDocument );
+}
+
 #endif
 
 /*!
@@ -1085,6 +1125,25 @@
 }
 
 /*!
+  Build and assign a pen
+
+  In Qt5 the default pen width is 1.0 ( 0.0 in Qt4 )
+  what makes it non cosmetic ( see QPen::isCosmetic() ).
+  This method has been introduced to hide this incompatibility.
+
+  \param color Pen color
+  \param width Pen width
+  \param style Pen style
+
+  \sa pen(), brush()
+ */
+void QwtSymbol::setPen( const QColor &color,
+    qreal width, Qt::PenStyle style )
+{
+    setPen( QPen( color, width, style ) );
+}
+
+/*!
   Assign a pen
 
   The pen is used to draw the symbol's outline.
@@ -1172,6 +1231,20 @@
     }
 }
 
+/*!
+  \brief Set and enable a pin point
+
+  The position of a complex symbol is not always aligned to its center
+  ( f.e an arrow, where the peak points to a position ). The pin point
+  defines the position inside of a Pixmap, Graphic, SvgDocument 
+  or PainterPath symbol where the represented point has to
+  be aligned to.
+  
+  \param pos Position
+  \param enable En/Disable the pin point alignment
+
+  \sa pinPoint(), setPinPointEnabled()
+ */
 void QwtSymbol::setPinPoint( const QPointF &pos, bool enable )
 {
     if ( d_data->pinPoint != pos )
@@ -1186,11 +1259,21 @@
     setPinPointEnabled( enable );
 }
 
+/*!
+  \return Pin point
+  \sa setPinPoint(), setPinPointEnabled()
+ */
 QPointF QwtSymbol::pinPoint() const
 {
     return d_data->pinPoint;
 }
 
+/*!
+  En/Disable the pin point alignment
+
+  \param on Enabled, when on is true
+  \sa setPinPoint(), isPinPointEnabled()
+ */
 void QwtSymbol::setPinPointEnabled( bool on )
 {
     if ( d_data->isPinPointEnabled != on )
@@ -1200,6 +1283,10 @@
     }
 }
 
+/*!
+  \return True, when the pin point translation is enabled
+  \sa setPinPoint(), setPinPointEnabled()
+ */
 bool QwtSymbol::isPinPointEnabled() const
 {
     return d_data->isPinPointEnabled;
@@ -1274,7 +1361,7 @@
         
         if ( d_data->cache.pixmap.isNull() )
         {
-            d_data->cache.pixmap = QPixmap( br.size() );
+            d_data->cache.pixmap = QwtPainter::backingStore( NULL, br.size() );
             d_data->cache.pixmap.fill( Qt::transparent );
 
             QPainter p( &d_data->cache.pixmap );
@@ -1316,7 +1403,6 @@
   \param painter Painter
   \param rect Target rectangle for the symbol 
 */
-
 void QwtSymbol::drawSymbol( QPainter *painter, const QRectF &rect ) const
 {
     if ( d_data->style == QwtSymbol::NoSymbol )
@@ -1389,6 +1475,13 @@
     }
 }
 
+/*!
+  Render the symbol to series of points
+
+  \param painter Qt painter
+  \param points Positions of the symbols
+  \param numPoints Number of points
+ */
 void QwtSymbol::renderSymbols( QPainter *painter,
     const QPointF *points, int numPoints ) const
 {
@@ -1507,6 +1600,12 @@
     }
 }
 
+/*!
+  Calculate the bounding rectangle for a symbol
+  at position (0,0).
+
+  \return Bounding rectangle
+ */
 QRect QwtSymbol::boundingRect() const
 {
     QRectF rect;
@@ -1631,7 +1730,7 @@
 
   The symbol invalidates its cache, whenever an attribute is changed
   that has an effect ob how to display a symbol. In case of derived
-  classes with indidividual styles ( >= QwtSymbol::UserStyle ) it
+  classes with individual styles ( >= QwtSymbol::UserStyle ) it
   might be necessary to call invalidateCache() for attributes
   that are relevant for this style.
 
Index: qwt_magnifier.h
===================================================================
--- qwt_magnifier.h	(revision 382)
+++ qwt_magnifier.h	(working copy)
@@ -42,25 +42,25 @@
     void setMouseFactor( double );
     double mouseFactor() const;
 
-    void setMouseButton( int button, int buttonState = Qt::NoButton );
-    void getMouseButton( int &button, int &buttonState ) const;
+    void setMouseButton( Qt::MouseButton, Qt::KeyboardModifiers = Qt::NoModifier );
+    void getMouseButton( Qt::MouseButton &, Qt::KeyboardModifiers & ) const;
 
     // mouse wheel
     void setWheelFactor( double );
     double wheelFactor() const;
 
-    void setWheelButtonState( int buttonState );
-    int wheelButtonState() const;
+    void setWheelModifiers( Qt::KeyboardModifiers );
+    Qt::KeyboardModifiers wheelModifiers() const;
 
     // keyboard
     void setKeyFactor( double );
     double keyFactor() const;
 
-    void setZoomInKey( int key, int modifiers );
-    void getZoomInKey( int &key, int &modifiers ) const;
+    void setZoomInKey( int key, Qt::KeyboardModifiers = Qt::NoModifier );
+    void getZoomInKey( int &key, Qt::KeyboardModifiers & ) const;
 
-    void setZoomOutKey( int key, int modifiers );
-    void getZoomOutKey( int &key, int &modifiers ) const;
+    void setZoomOutKey( int key, Qt::KeyboardModifiers = Qt::NoModifier );
+    void getZoomOutKey( int &key, Qt::KeyboardModifiers & ) const;
 
     virtual bool eventFilter( QObject *, QEvent * );
 
Index: qwt_dial.cpp
===================================================================
--- qwt_dial.cpp	(revision 382)
+++ qwt_dial.cpp	(working copy)
@@ -12,9 +12,9 @@
 #include "qwt_math.h"
 #include "qwt_scale_engine.h"
 #include "qwt_scale_map.h"
+#include "qwt_round_scale_draw.h"
 #include "qwt_painter.h"
 #include <qpainter.h>
-#include <qbitmap.h>
 #include <qpalette.h>
 #include <qpixmap.h>
 #include <qevent.h>
@@ -24,10 +24,56 @@
 #include <qstyleoption.h>
 #include <qapplication.h>
 
-#if QT_VERSION < 0x040601
-#define qAtan(x) ::atan(x)
-#endif
+static inline double qwtAngleDist( double a1, double a2 )
+{
+    double dist = qAbs( a2 - a1 );
+    if ( dist > 360.0 )
+        dist -= 360.0;
 
+    return dist;
+}
+
+static inline bool qwtIsOnArc( double angle, double min, double max )
+{
+    if ( min < max )
+    {
+        return ( angle >= min ) && ( angle <= max );
+    }
+    else
+    {
+        return ( angle >= min ) || ( angle <= max );
+    }
+}
+
+static inline double qwtBoundedAngle( double min, double angle, double max )
+{
+    double from = qwtNormalizeDegrees( min );
+    double to = qwtNormalizeDegrees( max );
+
+    double a;
+
+    if ( qwtIsOnArc( angle, from, to ) )
+    {
+        a = angle;
+        if ( a < min )
+            a += 360.0;
+    }
+    else
+    {
+        if ( qwtAngleDist( angle, from ) <
+            qwtAngleDist( angle, to ) )
+        {
+            a = min;
+        }
+        else
+        {
+            a = max;
+        }
+    }
+
+    return a;
+}
+
 class QwtDial::PrivateData
 {
 public:
@@ -35,109 +81,52 @@
         frameShadow( Sunken ),
         lineWidth( 0 ),
         mode( RotateNeedle ),
-        direction( Clockwise ),
         origin( 90.0 ),
         minScaleArc( 0.0 ),
         maxScaleArc( 0.0 ),
-        scaleDraw( 0 ),
-        maxMajIntv( 36 ),
-        maxMinIntv( 10 ),
-        scaleStep( 0.0 ),
-        needle( 0 )
+        needle( NULL ),
+        arcOffset( 0.0 ),
+        mouseOffset( 0.0 )
     {
     }
 
     ~PrivateData()
     {
-        delete scaleDraw;
         delete needle;
     }
     Shadow frameShadow;
     int lineWidth;
 
     QwtDial::Mode mode;
-    QwtDial::Direction direction;
 
     double origin;
     double minScaleArc;
     double maxScaleArc;
 
-    QwtDialScaleDraw *scaleDraw;
-    int maxMajIntv;
-    int maxMinIntv;
-    double scaleStep;
-
+    double scalePenWidth;
     QwtDialNeedle *needle;
 
-    static double previousDir;
+    double arcOffset;
+    double mouseOffset;
+
+    QPixmap pixmapCache;
 };
 
-double QwtDial::PrivateData::previousDir = -1.0;
-
 /*!
-  Constructor
+  \brief Constructor
+  \param parent Parent widget
 
-  \param parent Parent dial widget
-*/
-QwtDialScaleDraw::QwtDialScaleDraw( QwtDial *parent ):
-    d_parent( parent ),
-    d_penWidth( 1.0 )
-{
-}
+  Create a dial widget with no needle. The scale is initialized
+  to [ 0.0, 360.0 ] and 360 steps ( QwtAbstractSlider::setTotalSteps() ).
+  The origin of the scale is at 90,
 
-/*!
-  Set the pen width used for painting the scale
+  The value is set to 0.0.
 
-  \param penWidth Pen width
-  \sa penWidth(), QwtDial::drawScale()
+  The default mode is QwtDial::RotateNeedle.
 */
-
-void QwtDialScaleDraw::setPenWidth( double penWidth )
-{
-    d_penWidth = qMax( penWidth, 0.0 );
-}
-
-/*!
-  \return Pen width used for painting the scale
-  \sa setPenWidth, QwtDial::drawScale()
-*/
-double QwtDialScaleDraw::penWidth() const
-{
-    return d_penWidth;
-}
-
-/*!
-  Call QwtDial::scaleLabel of the parent dial widget.
-
-  \param value Value to display
-
-  \sa QwtDial::scaleLabel()
-*/
-QwtText QwtDialScaleDraw::label( double value ) const
-{
-    if ( d_parent == NULL )
-        return QwtRoundScaleDraw::label( value );
-
-    return d_parent->scaleLabel( value );
-}
-
-/*!
-  \brief Constructor
-  \param parent Parent widget
-
-  Create a dial widget with no scale and no needle.
-  The default origin is 90.0 with no valid value. It accepts
-  mouse and keyboard inputs and has no step size. The default mode
-  is QwtDial::RotateNeedle.
-*/
 QwtDial::QwtDial( QWidget* parent ):
-    QwtAbstractSlider( Qt::Horizontal, parent )
+    QwtAbstractSlider( parent )
 {
-    initDial();
-}
-
-void QwtDial::initDial()
-{
     d_data = new PrivateData;
 
     setFocusPolicy( Qt::TabFocus );
@@ -156,11 +145,17 @@
     }
     setPalette( p );
 
-    d_data->scaleDraw = new QwtDialScaleDraw( this );
-    d_data->scaleDraw->setRadius( 0 );
+    QwtRoundScaleDraw* scaleDraw = new QwtRoundScaleDraw();
+    scaleDraw->setRadius( 0 );
 
+    setScaleDraw( scaleDraw );
+
     setScaleArc( 0.0, 360.0 ); // scale as a full circle
-    setRange( 0.0, 360.0, 1.0, 10 ); // degrees as deafult
+
+    setScaleMaxMajor( 10 );
+    setScaleMaxMinor( 5 );
+
+    setValue( 0.0 );
 }
 
 //!  Destructor
@@ -171,6 +166,7 @@
 
 /*!
   Sets the frame shadow value from the frame style.
+
   \param shadow Frame shadow
   \sa setLineWidth(), QFrame::setFrameShadow()
 */
@@ -178,6 +174,8 @@
 {
     if ( shadow != d_data->frameShadow )
     {
+        invalidateCache();
+
         d_data->frameShadow = shadow;
         if ( lineWidth() > 0 )
             update();
@@ -186,7 +184,7 @@
 
 /*!
   \return Frame shadow
-  /sa setFrameShadow(), lineWidth(), QFrame::frameShadow
+  /sa setFrameShadow(), lineWidth(), QFrame::frameShadow()
 */
 QwtDial::Shadow QwtDial::frameShadow() const
 {
@@ -194,7 +192,7 @@
 }
 
 /*!
-  Sets the line width
+  Sets the line width of the frame
 
   \param lineWidth Line width
   \sa setFrameShadow()
@@ -206,6 +204,8 @@
 
     if ( d_data->lineWidth != lineWidth )
     {
+        invalidateCache();
+
         d_data->lineWidth = lineWidth;
         update();
     }
@@ -221,42 +221,43 @@
 }
 
 /*!
-  \return bounding rect of the circle inside the frame
+  \return bounding rectangle of the circle inside the frame
   \sa setLineWidth(), scaleInnerRect(), boundingRect()
 */
-QRectF QwtDial::innerRect() const
+QRect QwtDial::innerRect() const
 {
-    const double lw = lineWidth();
+    const int lw = lineWidth();
     return boundingRect().adjusted( lw, lw, -lw, -lw );
 }
 
 /*!
-  \return bounding rect of the dial including the frame
+  \return bounding rectangle of the dial including the frame
   \sa setLineWidth(), scaleInnerRect(), innerRect()
 */
-QRectF QwtDial::boundingRect() const
+QRect QwtDial::boundingRect() const
 {
-    const QRectF cr = contentsRect();
+    const QRect cr = contentsRect();
 
     const double dim = qMin( cr.width(), cr.height() );
 
-    QRectF inner( 0, 0, dim, dim );
+    QRect inner( 0, 0, dim, dim );
     inner.moveCenter( cr.center() );
 
     return inner;
 }
 
 /*!
-  \return rect inside the scale
+  \return rectangle inside the scale
   \sa setLineWidth(), boundingRect(), innerRect()
 */
-QRectF QwtDial::scaleInnerRect() const
+QRect QwtDial::scaleInnerRect() const
 {
-    QRectF rect = innerRect();
+    QRect rect = innerRect();
 
-    if ( d_data->scaleDraw )
+    const QwtAbstractScaleDraw *sd = scaleDraw();
+    if ( sd )
     {
-        double scaleDist = qCeil( d_data->scaleDraw->extent( font() ) );
+        int scaleDist = qCeil( sd->extent( font() ) );
         scaleDist++; // margin
 
         rect.adjust( scaleDist, scaleDist, -scaleDist, -scaleDist );
@@ -266,13 +267,10 @@
 }
 
 /*!
-  \brief Change the mode of the meter.
+  \brief Change the mode of the dial.
   \param mode New mode
 
-  The value of the meter is indicated by the difference
-  between north of the scale and the direction of the needle.
-  In case of QwtDial::RotateNeedle north is pointing
-  to the origin() and the needle is rotating, in case of
+  In case of QwtDial::RotateNeedle the needle is rotating, in case of
   QwtDial::RotateScale, the needle points to origin()
   and the scale is rotating.
 
@@ -284,23 +282,15 @@
 {
     if ( mode != d_data->mode )
     {
+        invalidateCache();
+
         d_data->mode = mode;
-        update();
+        sliderChange();
     }
 }
 
 /*!
-  \return mode of the dial.
-
-  The value of the dial is indicated by the difference
-  between the origin and the direction of the needle.
-  In case of QwtDial::RotateNeedle the scale arc is fixed
-  to the origin() and the needle is rotating, in case of
-  QwtDial::RotateScale, the needle points to origin()
-  and the scale is rotating.
-
-  The default mode is QwtDial::RotateNeedle.
-
+  \return Mode of the dial.
   \sa setMode(), origin(), setScaleArc(), value()
 */
 QwtDial::Mode QwtDial::mode() const
@@ -309,61 +299,14 @@
 }
 
 /*!
-    Sets whether it is possible to step the value from the highest value to
-    the lowest value and vice versa to on.
-
-    \param wrapping en/disables wrapping
-
-    \sa wrapping(), QwtDoubleRange::periodic()
-    \note The meaning of wrapping is like the wrapping property of QSpinBox,
-          but not like it is used in QDial.
-*/
-void QwtDial::setWrapping( bool wrapping )
+  Invalidate the internal caches used to speed up repainting
+ */
+void QwtDial::invalidateCache()
 {
-    setPeriodic( wrapping );
+    d_data->pixmapCache = QPixmap();
 }
 
 /*!
-    wrapping() holds whether it is possible to step the value from the
-    highest value to the lowest value and vice versa.
-
-    \sa setWrapping(), QwtDoubleRange::setPeriodic()
-    \note The meaning of wrapping is like the wrapping property of QSpinBox,
-          but not like it is used in QDial.
-*/
-bool QwtDial::wrapping() const
-{
-    return periodic();
-}
-
-/*!
-    Set the direction of the dial (clockwise/counterclockwise)
-
-    \param direction Direction
-    \sa direction()
-*/
-void QwtDial::setDirection( Direction direction )
-{
-    if ( direction != d_data->direction )
-    {
-        d_data->direction = direction;
-        update();
-    }
-}
-
-/*!
-   \return Direction of the dial
-
-   The default direction of a dial is QwtDial::Clockwise
-
-   \sa setDirection()
-*/
-QwtDial::Direction QwtDial::direction() const
-{
-    return d_data->direction;
-}
-
-/*!
    Paint the dial
    \param event Paint event
 */
@@ -376,52 +319,52 @@
     opt.init(this);
     style()->drawPrimitive(QStyle::PE_Widget, &opt, &painter, this);
 
-    painter.setRenderHint( QPainter::Antialiasing, true );
+    if ( d_data->mode == QwtDial::RotateScale )
+    {
+        painter.save();
+        painter.setRenderHint( QPainter::Antialiasing, true );
 
-    painter.save();
-    drawContents( &painter );
-    painter.restore();
+        drawContents( &painter );
 
-    painter.save();
-    drawFrame( &painter );
-    painter.restore();
+        painter.restore();
+    }
 
+    const QRect r = contentsRect();
+    if ( r.size() != d_data->pixmapCache.size() )
+    {
+        d_data->pixmapCache = QwtPainter::backingStore( this, r.size() );
+        d_data->pixmapCache.fill( Qt::transparent );
+
+        QPainter p( &d_data->pixmapCache );
+        p.setRenderHint( QPainter::Antialiasing, true );
+        p.translate( -r.topLeft() );
+            
+        if ( d_data->mode != QwtDial::RotateScale )
+            drawContents( &p );
+
+        if ( lineWidth() > 0 )
+            drawFrame( &p );
+
+        if ( d_data->mode != QwtDial::RotateNeedle )
+            drawNeedle( &p );
+    }
+
+    painter.drawPixmap( r.topLeft(), d_data->pixmapCache );
+
+    if ( d_data->mode == QwtDial::RotateNeedle )
+        drawNeedle( &painter );
+
     if ( hasFocus() )
         drawFocusIndicator( &painter );
 }
 
 /*!
-  Draw a dotted round circle, if !isReadOnly()
-
+  Draw the focus indicator
   \param painter Painter
 */
 void QwtDial::drawFocusIndicator( QPainter *painter ) const
 {
-    if ( !isReadOnly() )
-    {
-        QRectF focusRect = innerRect();
-
-        const int margin = 2;
-        focusRect.adjust( margin, margin, -margin, -margin );
-
-        QColor color = palette().color( QPalette::Base );
-        if ( color.isValid() )
-        {
-            const QColor gray( Qt::gray );
-
-            int h, s, v;
-            color.getHsv( &h, &s, &v );
-            color = ( v > 128 ) ? gray.dark( 120 ) : gray.light( 120 );
-        }
-        else
-            color = Qt::darkGray;
-
-        painter->save();
-        painter->setBrush( Qt::NoBrush );
-        painter->setPen( QPen( color, 0, Qt::DotLine ) );
-        painter->drawEllipse( focusRect );
-        painter->restore();
-    }
+    QwtPainter::drawFocusRect( painter, this, boundingRect() );
 }
 
 /*!
@@ -432,51 +375,8 @@
 */
 void QwtDial::drawFrame( QPainter *painter )
 {
-    if ( lineWidth() <= 0 )
-        return;
-
-    const double lw2 = 0.5 * lineWidth();
-
-    QRectF r = boundingRect();
-    r.adjust( lw2, lw2, -lw2, -lw2 );
-
-    QPen pen;
-
-    switch ( d_data->frameShadow )
-    {
-        case QwtDial::Raised:
-        case QwtDial::Sunken:
-        {
-            QColor c1 = palette().color( QPalette::Light );
-            QColor c2 = palette().color( QPalette::Dark );
-
-            if ( d_data->frameShadow == QwtDial::Sunken )
-                qSwap( c1, c2 );
-
-            QLinearGradient gradient( r.topLeft(), r.bottomRight() );
-            gradient.setColorAt( 0.0, c1 );
-#if 0
-            gradient.setColorAt( 0.3, c1 );
-            gradient.setColorAt( 0.7, c2 );
-#endif
-            gradient.setColorAt( 1.0, c2 );
-
-            pen = QPen( gradient, lineWidth() );
-            break;
-        }
-        default: // Plain
-        {
-            pen = QPen( palette().brush( QPalette::Dark ), lineWidth() );
-        }
-    }
-
-    painter->save();
-
-    painter->setPen( pen );
-    painter->setBrush( Qt::NoBrush );
-    painter->drawEllipse( r );
-
-    painter->restore();
+    QwtPainter::drawRoundFrame( painter, boundingRect(),
+        palette(), lineWidth(), d_data->frameShadow );
 }
 
 /*!
@@ -487,6 +387,7 @@
   QPalette::WindowText is the background color inside the scale.
 
   \param painter Painter
+
   \sa boundingRect(), innerRect(),
     scaleInnerRect(), QWidget::setPalette()
 */
@@ -505,7 +406,6 @@
         painter->restore();
     }
 
-
     const QRectF insideScaleRect = scaleInnerRect();
     if ( palette().brush( QPalette::WindowText ) !=
             palette().brush( QPalette::Base ) )
@@ -520,57 +420,13 @@
     const QPointF center = insideScaleRect.center();
     const double radius = 0.5 * insideScaleRect.width();
 
-    double direction = d_data->origin;
-
-    if ( isValid() )
-    {
-        direction = d_data->minScaleArc;
-        if ( maxValue() > minValue() && 
-            d_data->maxScaleArc > d_data->minScaleArc )
-        {
-            const double ratio =
-                ( value() - minValue() ) / ( maxValue() - minValue() );
-            direction += ratio * ( d_data->maxScaleArc - d_data->minScaleArc );
-        }
-
-        if ( d_data->direction == QwtDial::CounterClockwise )
-            direction = d_data->maxScaleArc - ( direction - d_data->minScaleArc );
-
-        direction += d_data->origin;
-        if ( direction >= 360.0 )
-            direction -= 360.0;
-        else if ( direction < 0.0 )
-            direction += 360.0;
-    }
-
-    double origin = d_data->origin;
-    if ( mode() == RotateScale )
-    {
-        origin -= direction - d_data->origin;
-        direction = d_data->origin;
-    }
-
     painter->save();
-    drawScale( painter, center, radius, origin,
-        d_data->minScaleArc, d_data->maxScaleArc );
+    drawScale( painter, center, radius );
     painter->restore();
 
     painter->save();
     drawScaleContents( painter, center, radius );
     painter->restore();
-
-    if ( isValid() )
-    {
-        QPalette::ColorGroup cg;
-        if ( isEnabled() )
-            cg = hasFocus() ? QPalette::Active : QPalette::Inactive;
-        else
-            cg = QPalette::Disabled;
-
-        painter->save();
-        drawNeedle( painter, center, radius, direction, cg );
-        painter->restore();
-    }
 }
 
 /*!
@@ -580,73 +436,65 @@
   \param center Center of the dial
   \param radius Length for the needle
   \param direction Direction of the needle in degrees, counter clockwise
-  \param cg ColorGroup
+  \param colorGroup ColorGroup
 */
 void QwtDial::drawNeedle( QPainter *painter, const QPointF &center,
-    double radius, double direction, QPalette::ColorGroup cg ) const
+    double radius, double direction, QPalette::ColorGroup colorGroup ) const
 {
     if ( d_data->needle )
     {
         direction = 360.0 - direction; // counter clockwise
-        d_data->needle->draw( painter, center, radius, direction, cg );
+        d_data->needle->draw( painter, center, radius, direction, colorGroup );
     }
 }
 
+void QwtDial::drawNeedle( QPainter *painter ) const
+{
+    if ( !isValid() )
+        return;
+
+    QPalette::ColorGroup colorGroup;
+    if ( isEnabled() )
+        colorGroup = hasFocus() ? QPalette::Active : QPalette::Inactive;
+    else
+        colorGroup = QPalette::Disabled;
+
+    const QRectF sr = scaleInnerRect();
+
+    painter->save();
+    painter->setRenderHint( QPainter::Antialiasing, true );
+    drawNeedle( painter, sr.center(), 0.5 * sr.width(),
+        transform( value() ) + 270.0, colorGroup );
+    painter->restore();
+}
+
 /*!
   Draw the scale
 
   \param painter Painter
   \param center Center of the dial
   \param radius Radius of the scale
-  \param origin Origin of the scale
-  \param minArc Minimum of the arc
-  \param maxArc Minimum of the arc
-
-  \sa QwtRoundScaleDraw::setAngleRange()
 */
-void QwtDial::drawScale( QPainter *painter, const QPointF &center,
-    double radius, double origin, double minArc, double maxArc ) const
+void QwtDial::drawScale( QPainter *painter, 
+    const QPointF &center, double radius ) const
 {
-    if ( d_data->scaleDraw == NULL )
+    QwtRoundScaleDraw *sd = const_cast<QwtRoundScaleDraw *>( scaleDraw() );
+    if ( sd == NULL )
         return;
 
-    origin -= 270.0; // hardcoded origin of QwtScaleDraw
+    sd->setRadius( radius );
+    sd->moveCenter( center );
 
-    double angle = maxArc - minArc;
-    if ( angle > 360.0 )
-        angle = ::fmod( angle, 360.0 );
-
-    minArc += origin;
-    if ( minArc < -360.0 )
-        minArc = ::fmod( minArc, 360.0 );
-
-    maxArc = minArc + angle;
-    if ( maxArc > 360.0 )
-    {
-        // QwtRoundScaleDraw::setAngleRange accepts only values
-        // in the range [-360.0..360.0]
-        minArc -= 360.0;
-        maxArc -= 360.0;
-    }
-
-    if ( d_data->direction == QwtDial::CounterClockwise )
-        qSwap( minArc, maxArc );
-
-    painter->setFont( font() );
-
-    d_data->scaleDraw->setAngleRange( minArc, maxArc );
-    d_data->scaleDraw->setRadius( radius );
-    d_data->scaleDraw->moveCenter( center );
-
     QPalette pal = palette();
 
     const QColor textColor = pal.color( QPalette::Text );
-    pal.setColor( QPalette::WindowText, textColor ); //ticks, backbone
+    pal.setColor( QPalette::WindowText, textColor ); // ticks, backbone
 
-    painter->setPen( QPen( textColor, d_data->scaleDraw->penWidth() ) );
+    painter->setFont( font() );
+    painter->setPen( QPen( textColor, sd->penWidth() ) );
 
     painter->setBrush( Qt::red );
-    d_data->scaleDraw->draw( painter, pal );
+    sd->draw( painter, pal );
 }
 
 /*!
@@ -658,7 +506,6 @@
   \param center Center of the contents circle
   \param radius Radius of the contents circle
 */
-
 void QwtDial::drawScaleContents( QPainter *painter,
     const QPointF &center, double radius ) const
 {
@@ -670,12 +517,10 @@
 /*!
   Set a needle for the dial
 
-  Qwt is missing a set of good looking needles.
-  Contributions are very welcome.
-
   \param needle Needle
+
   \warning The needle will be deleted, when a different needle is
-    set or in ~QwtDial()
+           set or in ~QwtDial()
 */
 void QwtDial::setNeedle( QwtDialNeedle *needle )
 {
@@ -707,150 +552,101 @@
     return d_data->needle;
 }
 
-//! QwtDoubleRange update hook
-void QwtDial::rangeChange()
+//! \return the scale draw
+QwtRoundScaleDraw *QwtDial::scaleDraw()
 {
-    updateScale();
+    return static_cast<QwtRoundScaleDraw *>( abstractScaleDraw() );
 }
 
-/*!
-  Update the scale with the current attributes
-  \sa setScale()
-*/
-void QwtDial::updateScale()
+//! \return the scale draw
+const QwtRoundScaleDraw *QwtDial::scaleDraw() const
 {
-    if ( d_data->scaleDraw )
-    {
-        QwtLinearScaleEngine scaleEngine;
-
-        const QwtScaleDiv scaleDiv = scaleEngine.divideScale(
-            minValue(), maxValue(),
-            d_data->maxMajIntv, d_data->maxMinIntv, d_data->scaleStep );
-
-        d_data->scaleDraw->setTransformation( scaleEngine.transformation() );
-        d_data->scaleDraw->setScaleDiv( scaleDiv );
-    }
+    return static_cast<const QwtRoundScaleDraw *>( abstractScaleDraw() );
 }
 
-//! Return the scale draw
-QwtDialScaleDraw *QwtDial::scaleDraw()
-{
-    return d_data->scaleDraw;
-}
-
-//! Return the scale draw
-const QwtDialScaleDraw *QwtDial::scaleDraw() const
-{
-    return d_data->scaleDraw;
-}
-
 /*!
   Set an individual scale draw
 
+  The motivation for setting a scale draw is often
+  to overload QwtRoundScaleDraw::label() to return 
+  individual tick labels.
+  
   \param scaleDraw Scale draw
   \warning The previous scale draw is deleted
 */
-void QwtDial::setScaleDraw( QwtDialScaleDraw *scaleDraw )
+void QwtDial::setScaleDraw( QwtRoundScaleDraw *scaleDraw )
 {
-    if ( scaleDraw != d_data->scaleDraw )
-    {
-        if ( d_data->scaleDraw )
-            delete d_data->scaleDraw;
-
-        d_data->scaleDraw = scaleDraw;
-        updateScale();
-        update();
-    }
+    setAbstractScaleDraw( scaleDraw );
+    sliderChange();
 }
 
 /*!
-  Change the intervals of the scale
+  Change the arc of the scale
 
-  \param maxMajIntv Maximum for the number of major steps
-  \param maxMinIntv Maximum number of minor steps
-  \param step Step size
+  \param minArc Lower limit
+  \param maxArc Upper limit
 
-  \sa QwtScaleEngine::divideScale()
+  \sa minScaleArc(), maxScaleArc()
 */
-void QwtDial::setScale( int maxMajIntv, int maxMinIntv, double step )
+void QwtDial::setScaleArc( double minArc, double maxArc )
 {
-    d_data->maxMajIntv = maxMajIntv;
-    d_data->maxMinIntv = maxMinIntv;
-    d_data->scaleStep = step;
+    if ( minArc != 360.0 && minArc != -360.0 )
+        minArc = ::fmod( minArc, 360.0 );
+    if ( maxArc != 360.0 && maxArc != -360.0 )
+        maxArc = ::fmod( maxArc, 360.0 );
 
-    updateScale();
-}
+    double minScaleArc = qMin( minArc, maxArc );
+    double maxScaleArc = qMax( minArc, maxArc );
 
-/*!
-  A wrapper method for accessing the scale draw.
+    if ( maxScaleArc - minScaleArc > 360.0 )
+        maxScaleArc = minScaleArc + 360.0;
 
-  \param components Scale components
-  \sa QwtAbstractScaleDraw::enableComponent()
-*/
-void QwtDial::setScaleComponents( 
-    QwtAbstractScaleDraw::ScaleComponents components )
-{
-    if ( components == 0 )
-        setScaleDraw( NULL );
+    if ( ( minScaleArc != d_data->minScaleArc ) || 
+        ( maxScaleArc != d_data->maxScaleArc ) )
+    {
+        d_data->minScaleArc = minScaleArc;
+        d_data->maxScaleArc = maxScaleArc;
 
-    QwtDialScaleDraw *sd = d_data->scaleDraw;
-    if ( sd == NULL )
-        return;
-
-    sd->enableComponent( QwtAbstractScaleDraw::Backbone,
-        components & QwtAbstractScaleDraw::Backbone );
-
-    sd->enableComponent( QwtAbstractScaleDraw::Ticks,
-        components & QwtAbstractScaleDraw::Ticks );
-
-    sd->enableComponent( QwtAbstractScaleDraw::Labels,
-        components & QwtAbstractScaleDraw::Labels );
+        invalidateCache();
+        sliderChange();
+    }
 }
 
-/*!
-  Assign length and width of the ticks
+/*! 
+  Set the lower limit for the scale arc
 
-  \param minLen Length of the minor ticks
-  \param medLen Length of the medium ticks
-  \param majLen Length of the major ticks
-  \param penWidth Width of the pen for all ticks
-
-  \sa QwtAbstractScaleDraw::setTickLength(), QwtDialScaleDraw::setPenWidth()
-*/
-void QwtDial::setScaleTicks( int minLen, int medLen,
-                             int majLen, int penWidth )
+  \param min Lower limit of the scale arc
+  \sa setScaleArc(), setMaxScaleArc()
+ */
+void QwtDial::setMinScaleArc( double min )
 {
-    QwtDialScaleDraw *sd = d_data->scaleDraw;
-    if ( sd )
-    {
-        sd->setTickLength( QwtScaleDiv::MinorTick, minLen );
-        sd->setTickLength( QwtScaleDiv::MediumTick, medLen );
-        sd->setTickLength( QwtScaleDiv::MajorTick, majLen );
-        sd->setPenWidth( penWidth );
-    }
+    setScaleArc( min, d_data->maxScaleArc );
 }
 
-/*!
-   Find the label for a value
-
-   \param value Value
-   \return label
+/*! 
+  \return Lower limit of the scale arc
+  \sa setScaleArc()
 */
-QwtText QwtDial::scaleLabel( double value ) const
+double QwtDial::minScaleArc() const
 {
-    if ( value == -0.0 )
-        value = 0.0;
-
-    return QString::number( value );
+    return d_data->minScaleArc;
 }
 
-//! \return Lower limit of the scale arc
-double QwtDial::minScaleArc() const
+/*! 
+  Set the upper limit for the scale arc
+
+  \param max Upper limit of the scale arc
+  \sa setScaleArc(), setMinScaleArc()
+ */
+void QwtDial::setMaxScaleArc( double max )
 {
-    return d_data->minScaleArc;
+    setScaleArc( d_data->minScaleArc, max );
 }
 
-//! \return Upper limit of the scale arc
+/*! 
+  \return Upper limit of the scale arc
+  \sa setScaleArc()
+*/
 double QwtDial::maxScaleArc() const
 {
     return d_data->maxScaleArc;
@@ -866,8 +662,10 @@
 */
 void QwtDial::setOrigin( double origin )
 {
+    invalidateCache();
+
     d_data->origin = origin;
-    update();
+    sliderChange();
 }
 
 /*!
@@ -882,41 +680,14 @@
 }
 
 /*!
-  Change the arc of the scale
-
-  \param minArc Lower limit
-  \param maxArc Upper limit
-*/
-void QwtDial::setScaleArc( double minArc, double maxArc )
-{
-    if ( minArc != 360.0 && minArc != -360.0 )
-        minArc = ::fmod( minArc, 360.0 );
-    if ( maxArc != 360.0 && maxArc != -360.0 )
-        maxArc = ::fmod( maxArc, 360.0 );
-
-    d_data->minScaleArc = qMin( minArc, maxArc );
-    d_data->maxScaleArc = qMax( minArc, maxArc );
-    if ( d_data->maxScaleArc - d_data->minScaleArc > 360.0 )
-        d_data->maxScaleArc = d_data->minScaleArc + 360.0;
-
-    update();
-}
-
-//! QwtDoubleRange update hook
-void QwtDial::valueChange()
-{
-    update();
-    QwtAbstractSlider::valueChange();
-}
-
-/*!
   \return Size hint
+  \sa minimumSizeHint()
 */
 QSize QwtDial::sizeHint() const
 {
     int sh = 0;
-    if ( d_data->scaleDraw )
-        sh = qCeil( d_data->scaleDraw->extent( font() ) );
+    if ( scaleDraw() )
+        sh = qCeil( scaleDraw()->extent( font() ) );
 
     const int d = 6 * sh + 2 * lineWidth();
 
@@ -928,229 +699,174 @@
 }
 
 /*!
-  \brief Return a minimum size hint
-  \warning The return value of QwtDial::minimumSizeHint() depends on the
-           font and the scale.
+  \return Minimum size hint
+  \sa sizeHint()
 */
 QSize QwtDial::minimumSizeHint() const
 {
     int sh = 0;
-    if ( d_data->scaleDraw )
-        sh = qCeil( d_data->scaleDraw->extent( font() ) );
+    if ( scaleDraw() )
+        sh = qCeil( scaleDraw()->extent( font() ) );
 
     const int d = 3 * sh + 2 * lineWidth();
 
     return QSize( d, d );
 }
 
-static double line2Radians( const QPointF &p1, const QPointF &p2 )
-{
-    const QPointF p = p2 - p1;
-
-    double angle;
-    if ( p.x() == 0.0 )
-    {
-        angle = ( p.y() <= 0.0 ) ? M_PI_2 : 3 * M_PI_2;
-    }
-    else
-    {
-        angle = qAtan( double( -p.y() ) / double( p.x() ) );
-        if ( p.x() < 0.0 )
-            angle += M_PI;
-        if ( angle < 0.0 )
-            angle += 2 * M_PI;
-    }
-    return 360.0 - angle * 180.0 / M_PI;
-}
-
 /*!
-  Find the value for a given position
+  \brief Determine what to do when the user presses a mouse button.
 
-  \param pos Position
-  \return Value
+  \param pos Mouse position
+
+  \retval True, when the inner circle contains pos 
+  \sa scrolledTo()
 */
-double QwtDial::getValue( const QPoint &pos )
+bool QwtDial::isScrollPosition( const QPoint &pos ) const
 {
-    if ( d_data->maxScaleArc == d_data->minScaleArc || maxValue() == minValue() )
-        return minValue();
+    const QRegion region( innerRect(), QRegion::Ellipse );
+    if ( region.contains( pos ) && ( pos != innerRect().center() ) )
+    {
+        double angle = QLineF( rect().center(), pos ).angle();
+        if ( d_data->mode == QwtDial::RotateScale )
+            angle = 360.0 - angle;
 
-    double dir = line2Radians( innerRect().center(), pos ) - d_data->origin;
-    if ( dir < 0.0 )
-        dir += 360.0;
+        double valueAngle = 
+            qwtNormalizeDegrees( 90.0 - transform( value() ) );
 
-    if ( mode() == RotateScale )
-        dir = 360.0 - dir;
+        d_data->mouseOffset = qwtNormalizeDegrees( angle - valueAngle );
+        d_data->arcOffset = scaleMap().p1();
 
-    // The position might be in the area that is outside the scale arc.
-    // We need the range of the scale if it was a complete circle.
+        return true;
+    }
 
-    const double completeCircle = 360.0 / ( d_data->maxScaleArc - d_data->minScaleArc )
-        * ( maxValue() - minValue() );
+    return false;
+}
 
-    double posValue = minValue() + completeCircle * dir / 360.0;
+/*!
+  \brief Determine the value for a new position of the
+         slider handle.
 
-    if ( scrollMode() == ScrMouse )
+  \param pos Mouse position
+
+  \return Value for the mouse position
+  \sa isScrollPosition()
+*/
+double QwtDial::scrolledTo( const QPoint &pos ) const
+{
+    double angle = QLineF( rect().center(), pos ).angle();
+    if ( d_data->mode == QwtDial::RotateScale )
     {
-        if ( d_data->previousDir >= 0.0 ) // valid direction
-        {
-            // We have to find out whether the mouse is moving
-            // clock or counter clockwise
+        angle += scaleMap().p1() - d_data->arcOffset;
+        angle = 360.0 - angle;
+    }
 
-            bool clockWise = false;
+    angle = qwtNormalizeDegrees( angle - d_data->mouseOffset );
+    angle = qwtNormalizeDegrees( 90.0 - angle );
 
-            const double angle = dir - d_data->previousDir;
-            if ( ( angle >= 0.0 && angle <= 180.0 ) || angle < -180.0 )
-                clockWise = true;
+    if ( scaleMap().pDist() >= 360.0 )
+    {
+        if ( angle < scaleMap().p1() )
+            angle += 360.0;
 
-            if ( clockWise )
-            {
-                if ( dir < d_data->previousDir && mouseOffset() > 0.0 )
-                {
-                    // We passed 360 -> 0
-                    setMouseOffset( mouseOffset() - completeCircle );
-                }
+        if ( !wrapping() )
+        {
+            double boundedAngle = angle;
 
-                if ( wrapping() )
-                {
-                    if ( posValue - mouseOffset() > maxValue() )
-                    {
-                        // We passed maxValue and the value will be set
-                        // to minValue. We have to adjust the mouseOffset.
-
-                        setMouseOffset( posValue - minValue() );
-                    }
-                }
-                else
-                {
-                    if ( posValue - mouseOffset() > maxValue() ||
-                            value() == maxValue() )
-                    {
-                        // We fix the value at maxValue by adjusting
-                        // the mouse offset.
-
-                        setMouseOffset( posValue - maxValue() );
-                    }
-                }
-            }
-            else
+            const double arc = angle - transform( value() );
+            if ( qAbs( arc ) > 180.0 )
             {
-                if ( dir > d_data->previousDir && mouseOffset() < 0.0 )
-                {
-                    // We passed 0 -> 360
-                    setMouseOffset( mouseOffset() + completeCircle );
-                }
+                boundedAngle = ( arc > 0 ) 
+                    ? scaleMap().p1() : scaleMap().p2();
+            }
 
-                if ( wrapping() )
-                {
-                    if ( posValue - mouseOffset() < minValue() )
-                    {
-                        // We passed minValue and the value will be set
-                        // to maxValue. We have to adjust the mouseOffset.
+            d_data->mouseOffset += ( boundedAngle - angle );
 
-                        setMouseOffset( posValue - maxValue() );
-                    }
-                }
-                else
-                {
-                    if ( posValue - mouseOffset() < minValue() ||
-                        value() == minValue() )
-                    {
-                        // We fix the value at minValue by adjusting
-                        // the mouse offset.
-
-                        setMouseOffset( posValue - minValue() );
-                    }
-                }
-            }
+            angle = boundedAngle;
         }
-        d_data->previousDir = dir;
     }
+    else
+    {
+        const double boundedAngle =
+            qwtBoundedAngle( scaleMap().p1(), angle, scaleMap().p2() );
 
-    return posValue;
+        if ( !wrapping() )
+            d_data->mouseOffset += ( boundedAngle - angle );
+
+        angle = boundedAngle;
+    }
+
+    return invTransform( angle );
 }
 
 /*!
-  See QwtAbstractSlider::getScrollMode()
+  Change Event handler
+  \param event Change event
 
-  \param pos point where the mouse was pressed
-  \retval scrollMode The scrolling mode
-  \retval direction  direction: 1, 0, or -1.
-
-  \sa QwtAbstractSlider::getScrollMode()
+  Invalidates internal paint caches if necessary
 */
-void QwtDial::getScrollMode( const QPoint &pos, 
-    QwtAbstractSlider::ScrollMode &scrollMode, int &direction ) const
+void QwtDial::changeEvent( QEvent *event )
 {
-    direction = 0;
-    scrollMode = QwtAbstractSlider::ScrNone;
-
-    const QRegion region( innerRect().toRect(), QRegion::Ellipse );
-    if ( region.contains( pos ) && pos != innerRect().center() )
+    switch( event->type() )
     {
-        scrollMode = QwtAbstractSlider::ScrMouse;
-        d_data->previousDir = -1.0;
+        case QEvent::EnabledChange:
+        case QEvent::FontChange:
+        case QEvent::StyleChange:
+        case QEvent::PaletteChange:
+        case QEvent::LanguageChange:
+        case QEvent::LocaleChange:
+        {
+            invalidateCache();
+            break;
+        }
+        default:
+            break;
     }
+    
+    QwtAbstractSlider::changeEvent( event );
 }
 
 /*!
-  Handles key events
-
-  - Key_Down, KeyLeft\n
-    Decrement by 1
-  - Key_Prior\n
-    Decrement by pageSize()
-  - Key_Home\n
-    Set the value to minValue()
-
-  - Key_Up, KeyRight\n
-    Increment by 1
-  - Key_Next\n
-    Increment by pageSize()
-  - Key_End\n
-    Set the value to maxValue()
-
-  \param event Key event
-  \sa isReadOnly()
+  Wheel Event handler
+  \param event Wheel event
 */
-void QwtDial::keyPressEvent( QKeyEvent *event )
+void QwtDial::wheelEvent( QWheelEvent *event )
 {
-    if ( isReadOnly() )
+    const QRegion region( innerRect(), QRegion::Ellipse );
+    if ( region.contains( event->pos() ) )
+        QwtAbstractSlider::wheelEvent( event );
+}
+
+void QwtDial::setAngleRange( double angle, double span )
+{
+    QwtRoundScaleDraw *sd = const_cast<QwtRoundScaleDraw *>( scaleDraw() );
+    if ( sd  )
     {
-        event->ignore();
-        return;
+        angle = qwtNormalizeDegrees( angle - 270.0 );
+        sd->setAngleRange( angle, angle + span );
     }
+}
 
-    if ( !isValid() )
-        return;
+/*!
+  Invalidate the internal caches and call 
+  QwtAbstractSlider::scaleChange()
+ */
+void QwtDial::scaleChange()
+{
+    invalidateCache();
+    QwtAbstractSlider::scaleChange();
+}
 
-    double previous = prevValue();
-    switch ( event->key() )
-    {
-        case Qt::Key_Down:
-        case Qt::Key_Left:
-            QwtDoubleRange::incValue( -1 );
-            break;
-        case Qt::Key_PageUp:
-            QwtDoubleRange::incValue( -pageSize() );
-            break;
-        case Qt::Key_Home:
-            setValue( minValue() );
-            break;
+void QwtDial::sliderChange()
+{
+    setAngleRange( d_data->origin + d_data->minScaleArc,
+        d_data->maxScaleArc - d_data->minScaleArc );
 
-        case Qt::Key_Up:
-        case Qt::Key_Right:
-            QwtDoubleRange::incValue( 1 );
-            break;
-        case Qt::Key_PageDown:
-            QwtDoubleRange::incValue( pageSize() );
-            break;
-        case Qt::Key_End:
-            setValue( maxValue() );
-            break;
-        default:;
-            event->ignore();
+    if ( mode() == RotateScale )
+    {
+        const double arc = transform( value() ) - scaleMap().p1();
+        setAngleRange( d_data->origin - arc,
+            d_data->maxScaleArc - d_data->minScaleArc );
     }
 
-    if ( value() != previous )
-        Q_EMIT sliderMoved( value() );
+    QwtAbstractSlider::sliderChange();
 }
Index: qwt_plot_canvas.cpp
===================================================================
--- qwt_plot_canvas.cpp	(revision 382)
+++ qwt_plot_canvas.cpp	(working copy)
@@ -17,10 +17,6 @@
 #include <qstyleoption.h>
 #include <qpaintengine.h>
 #include <qevent.h>
-#include <qbitmap.h>
-#ifdef Q_WS_X11
-#include <qx11info_x11.h>
-#endif
 
 class QwtStyleSheetRecorder: public QwtNullPaintDevice
 {
@@ -165,15 +161,21 @@
     QPointF d_origin;
 };
 
-static void qwtDrawBackground( QPainter *painter, QWidget *widget )
+static void qwtDrawBackground( QPainter *painter, QwtPlotCanvas *canvas )
 {
+    painter->save();
+
+    const QPainterPath borderClip = canvas->borderPath( canvas->rect() );
+    if ( !borderClip.isEmpty() )
+        painter->setClipPath( borderClip, Qt::IntersectClip );
+
     const QBrush &brush = 
-        widget->palette().brush( widget->backgroundRole() );
+        canvas->palette().brush( canvas->backgroundRole() );
 
     if ( brush.style() == Qt::TexturePattern )
     {
-        QPixmap pm( widget->size() );
-        pm.fill( widget, 0, 0 );
+        QPixmap pm( canvas->size() );
+        QwtPainter::fillPixmap( canvas, pm );
         painter->drawPixmap( 0, 0, pm );
     }
     else if ( brush.gradient() )
@@ -182,7 +184,7 @@
 
         if ( brush.gradient()->coordinateMode() == QGradient::ObjectBoundingMode )
         {
-            rects += widget->rect();
+            rects += canvas->rect();
         } 
         else 
         {
@@ -221,7 +223,7 @@
                 }
             }
             
-            QImage image( widget->size(), format );
+            QImage image( canvas->size(), format );
 
             QPainter p( &image );
             p.setPen( Qt::NoPen );
@@ -235,40 +237,33 @@
         }
         else
         {
-            painter->save();
-
             painter->setPen( Qt::NoPen );
             painter->setBrush( brush );
 
             painter->drawRects( rects );
-
-            painter->restore();
         }
     }
     else
     {
-        painter->save();
-
         painter->setPen( Qt::NoPen );
         painter->setBrush( brush );
 
         painter->drawRects( painter->clipRegion().rects() );
 
-        painter->restore();
     }
+
+    painter->restore();
 }
 
 static inline void qwtRevertPath( QPainterPath &path )
 {
     if ( path.elementCount() == 4 )
     {
-        QPainterPath::Element &el0 = 
-            const_cast<QPainterPath::Element &>( path.elementAt(0) );
-        QPainterPath::Element &el2 = 
-            const_cast<QPainterPath::Element &>( path.elementAt(3) );
+        QPainterPath::Element el0 = path.elementAt(0);
+        QPainterPath::Element el3 = path.elementAt(3);
 
-        qSwap( el0.x, el2.x );
-        qSwap( el0.y, el2.y );
+        path.setElementPositionAt( 0, el3.x, el3.y );
+        path.setElementPositionAt( 3, el0.x, el0.y );
     }
 }
 
@@ -445,7 +440,7 @@
         if ( clipRegion.intersects( rect ) )
         {
             QPixmap pm( rect.size() );
-            pm.fill( bgWidget, widget->mapTo( bgWidget, rect.topLeft() ) );
+            QwtPainter::fillPixmap( bgWidget, pm, widget->mapTo( bgWidget, rect.topLeft() ) );
             painter->drawPixmap( rect, pm );
         }
     }
@@ -525,11 +520,18 @@
 
 };
 
-//! Sets a cross cursor, enables QwtPlotCanvas::BackingStore
+/*! 
+  \brief Constructor
 
+  \param plot Parent plot widget
+  \sa QwtPlot::setCanvas()
+*/
 QwtPlotCanvas::QwtPlotCanvas( QwtPlot *plot ):
     QFrame( plot )
 {
+    setFrameStyle( QFrame::Panel | QFrame::Sunken );
+    setLineWidth( 2 );
+
     d_data = new PrivateData;
 
 #ifndef QT_NO_CURSOR
@@ -589,8 +591,12 @@
 
                 if ( isVisible() )
                 {
+#if QT_VERSION >= 0x050000
+                    *d_data->backingStore = grab( rect() );
+#else
                     *d_data->backingStore = 
                         QPixmap::grabWidget( this, rect() );
+#endif
                 }
             }
             else
@@ -616,10 +622,10 @@
 }
 
 /*!
-  Test wether a paint attribute is enabled
+  Test whether a paint attribute is enabled
 
   \param attribute Paint attribute
-  \return true if the attribute is enabled
+  \return true, when attribute is enabled
   \sa setPaintAttribute()
 */
 bool QwtPlotCanvas::testPaintAttribute( PaintAttribute attribute ) const
@@ -682,7 +688,9 @@
 
 /*!
   Qt event handler for QEvent::PolishRequest and QEvent::StyleChange
+
   \param event Qt Event
+  \return See QFrame::event()
 */
 bool QwtPlotCanvas::event( QEvent *event )
 {
@@ -722,13 +730,8 @@
         QPixmap &bs = *d_data->backingStore;
         if ( bs.size() != size() )
         {
-            bs = QPixmap( size() );
+            bs = QwtPainter::backingStore( this, size() );
 
-#ifdef Q_WS_X11
-            if ( bs.x11Info().screen() != x11Info().screen() )
-                bs.x11SetScreen( x11Info().screen() );
-#endif
-
             if ( testAttribute(Qt::WA_StyledBackground) )
             {
                 QPainter p( &bs );
@@ -740,7 +743,7 @@
                 QPainter p;
                 if ( d_data->borderRadius <= 0.0 )
                 {
-                    bs.fill( this, 0, 0 );
+                    QwtPainter::fillPixmap( this, bs );
                     p.begin( &bs );
                     drawCanvas( &p, false );
                 }
@@ -777,9 +780,29 @@
             if ( testAttribute( Qt::WA_OpaquePaintEvent ) )
             {
                 if ( autoFillBackground() )
+                {
+                    qwtFillBackground( &painter, this );
                     qwtDrawBackground( &painter, this );
+                }
             }
+            else
+            {
+                if ( borderRadius() > 0.0 )
+                {
+                    QPainterPath clipPath;
+                    clipPath.addRect( rect() );
+                    clipPath = clipPath.subtracted( borderPath( rect() ) );
 
+                    painter.save();
+
+                    painter.setClipPath( clipPath, Qt::IntersectClip );
+                    qwtFillBackground( &painter, this );
+                    qwtDrawBackground( &painter, this );
+
+                    painter.restore();
+                }
+            }
+
             drawCanvas( &painter, false );
 
             if ( frameWidth() > 0 ) 
@@ -844,7 +867,7 @@
             painter->setPen( Qt::NoPen );
             painter->setBrush( palette().brush( backgroundRole() ) );
 
-            if ( d_data->borderRadius > 0.0 )
+            if ( d_data->borderRadius > 0.0 && ( rect() == frameRect() ) )
             {
                 if ( frameWidth() > 0 )
                 {
@@ -859,7 +882,7 @@
             }
             else
             {
-                painter->drawRect( contentsRect() );
+                painter->drawRect( rect() );
             }
         }
 
@@ -876,7 +899,7 @@
     else
     {
         if ( d_data->borderRadius > 0.0 )
-            painter->setClipPath( borderPath( rect() ), Qt::IntersectClip );
+            painter->setClipPath( borderPath( frameRect() ), Qt::IntersectClip );
         else
             painter->setClipRect( contentsRect(), Qt::IntersectClip );
     }
@@ -898,7 +921,7 @@
   Draw the border of the plot canvas
 
   \param painter Painter
-  \sa setBorderRadius(), QFrame::drawFrame()
+  \sa setBorderRadius()
 */
 void QwtPlotCanvas::drawBorder( QPainter *painter )
 {
@@ -906,14 +929,53 @@
     {
         if ( frameWidth() > 0 )
         {
-            QwtPainter::drawRoundedFrame( painter, QRectF( rect() ), 
+            QwtPainter::drawRoundedFrame( painter, QRectF( frameRect() ), 
                 d_data->borderRadius, d_data->borderRadius,
                 palette(), frameWidth(), frameStyle() );
         }
     }
     else
     {
+#if QT_VERSION >= 0x040500
+        QStyleOptionFrameV3 opt;
+        opt.init(this);
+
+        int frameShape  = frameStyle() & QFrame::Shape_Mask;
+        int frameShadow = frameStyle() & QFrame::Shadow_Mask;
+
+        opt.frameShape = QFrame::Shape( int( opt.frameShape ) | frameShape );
+#if 0
+        opt.rect = frameRect();
+#endif
+
+        switch (frameShape) 
+        {
+            case QFrame::Box:
+            case QFrame::HLine:
+            case QFrame::VLine:
+            case QFrame::StyledPanel:
+            case QFrame::Panel:
+            {
+                opt.lineWidth = lineWidth();
+                opt.midLineWidth = midLineWidth();
+                break; 
+            }
+            default: 
+            {
+                opt.lineWidth = frameWidth();
+                break;
+            }
+        }
+    
+        if ( frameShadow == Sunken )
+            opt.state |= QStyle::State_Sunken;
+        else if ( frameShadow == Raised )
+            opt.state |= QStyle::State_Raised;
+
+        style()->drawControl(QStyle::CE_ShapedFrame, &opt, painter, this);
+#else
         drawFrame( painter );
+#endif
     }
 }
 
@@ -956,7 +1018,7 @@
         update( contentsRect() );
 }
 
-//! Update the cached informations about the current style sheet
+//! Update the cached information about the current style sheet
 void QwtPlotCanvas::updateStyleSheetInfo()
 {
     if ( !testAttribute(Qt::WA_StyledBackground ) )
@@ -1033,54 +1095,3 @@
     
     return QPainterPath();
 }
-
-/*!
-   Calculate a mask, that can be used to clip away the border frame
-
-   \param size Size including the frame
-*/
-QBitmap QwtPlotCanvas::borderMask( const QSize &size ) const
-{
-    const QRect r( 0, 0, size.width(), size.height() );
-
-    const QPainterPath path = borderPath( r );
-    if ( path.isEmpty() )
-        return QBitmap();
-
-    QImage image( size, QImage::Format_ARGB32_Premultiplied );
-    image.fill( Qt::color0 );
-
-    QPainter painter( &image );
-    painter.setClipPath( path );
-    painter.fillRect( r, Qt::color1 );
-
-    // now erase the frame
-
-    painter.setCompositionMode( QPainter::CompositionMode_DestinationOut );
-
-    if ( testAttribute(Qt::WA_StyledBackground ) )
-    {
-        QStyleOptionFrame opt;
-        opt.initFrom(this);
-        opt.rect = r;
-        style()->drawPrimitive( QStyle::PE_Frame, &opt, &painter, this );
-    }
-    else
-    {
-        if ( d_data->borderRadius > 0 && frameWidth() > 0 )
-        {
-            painter.setPen( QPen( Qt::color1, frameWidth() ) );
-            painter.setBrush( Qt::NoBrush );
-            painter.setRenderHint( QPainter::Antialiasing, true );
-
-            painter.drawPath( path );
-        }
-    }
-
-    painter.end();
-
-    const QImage mask = image.createMaskFromColor(
-        QColor( Qt::color1 ).rgb(), Qt::MaskOutColor );
-
-    return QBitmap::fromImage( mask );
-}
Index: qwt_abstract_slider.h
===================================================================
--- qwt_abstract_slider.h	(revision 382)
+++ qwt_abstract_slider.h	(working copy)
@@ -11,116 +11,94 @@
 #define QWT_ABSTRACT_SLIDER_H
 
 #include "qwt_global.h"
-#include "qwt_double_range.h"
-#include <qwidget.h>
+#include "qwt_abstract_scale.h"
 
 /*!
-  \brief An abstract base class for slider widgets
+  \brief An abstract base class for slider widgets with a scale
 
-  QwtAbstractSlider is a base class for
-  slider widgets. It handles mouse events
-  and updates the slider's value accordingly. Derived classes
-  only have to implement the getValue() and
-  getScrollMode() members, and should react to a
-  valueChange(), which normally requires repainting.
+  A slider widget displays a value according to a scale.
+  The class is designed as a common super class for widgets like 
+  QwtKnob, QwtDial and QwtSlider.
+
+  When the slider is nor readOnly() its value can be modified 
+  by keyboard, mouse and wheel inputs. 
+
+  The range of the slider is divided into a number of steps from
+  which the value increments according to user inputs depend. 
+  Only for linear scales the number of steps correspond with
+  a fixed step size.
 */
 
-class QWT_EXPORT QwtAbstractSlider : public QWidget, public QwtDoubleRange
+class QWT_EXPORT QwtAbstractSlider: public QwtAbstractScale
 {
     Q_OBJECT
+
+    Q_PROPERTY( double value READ value WRITE setValue )
+
+    Q_PROPERTY( uint totalSteps READ totalSteps WRITE setTotalSteps )
+    Q_PROPERTY( uint singleSteps READ singleSteps WRITE setSingleSteps )
+    Q_PROPERTY( uint pageSteps READ pageSteps WRITE setPageSteps )
+    Q_PROPERTY( bool stepAlignment READ stepAlignment WRITE setStepAlignment )
+
     Q_PROPERTY( bool readOnly READ isReadOnly WRITE setReadOnly )
-    Q_PROPERTY( bool valid READ isValid WRITE setValid )
-    Q_PROPERTY( double mass READ mass WRITE setMass )
-    Q_PROPERTY( Qt::Orientation orientation
-                READ orientation WRITE setOrientation )
+    Q_PROPERTY( bool tracking READ isTracking WRITE setTracking )
+    Q_PROPERTY( bool wrapping READ wrapping WRITE setWrapping )
 
+    Q_PROPERTY( bool invertedControls READ invertedControls WRITE setInvertedControls )
+
 public:
-    /*!
-      Scroll mode
-      \sa getScrollMode()
-     */
-    enum ScrollMode
-    {
-        //! Scrolling switched off. Don't change the value.
-        ScrNone,
+    explicit QwtAbstractSlider( QWidget *parent = NULL );
+    virtual ~QwtAbstractSlider();
 
-        /*!
-          Change the value while the user keeps the
-          button pressed and moves the mouse.
-         */
-        ScrMouse,
+    void setValid( bool );
+    bool isValid() const;
 
-        /*!
-          Automatic scrolling. Increment the value in the specified direction 
-          as long as the user keeps the button pressed.
-         */
-        ScrTimer,
+    double value() const;
 
-        ScrDirect,
+    void setWrapping( bool );
+    bool wrapping() const;
 
-        //! Automatic scrolling. Same as ScrTimer, but increment by page size.
-        ScrPage
-    };
+    void setTotalSteps( uint );
+    uint totalSteps() const;
 
-    explicit QwtAbstractSlider( Qt::Orientation, QWidget *parent = NULL );
-    virtual ~QwtAbstractSlider();
+    void setSingleSteps( uint );
+    uint singleSteps() const;
 
-    void setUpdateTime( int t );
-    void stopMoving();
-    void setTracking( bool enable );
+    void setPageSteps( uint );
+    uint pageSteps() const;
 
-    virtual void setMass( double val );
-    virtual double mass() const;
+    void setStepAlignment( bool ); 
+    bool stepAlignment() const;
 
-    virtual void setOrientation( Qt::Orientation o );
-    Qt::Orientation orientation() const;
+    void setTracking( bool );
+    bool isTracking() const;
 
+    void setReadOnly( bool );
     bool isReadOnly() const;
 
-    /*
-        Wrappers for QwtDblRange::isValid/QwtDblRange::setValid made
-        to be available as Q_PROPERTY in the designer.
-    */
+    void setInvertedControls( bool );
+    bool invertedControls() const;
 
-    /*!
-      \sa QwtDblRange::isValid()
-    */
-    bool isValid() const
-    {
-        return QwtDoubleRange::isValid();
-    }
-
-    /*!
-      \param valid true/false
-      \sa QwtDblRange::isValid()
-    */
-    void setValid( bool valid )
-    {
-        QwtDoubleRange::setValid( valid );
-    }
-
 public Q_SLOTS:
-    virtual void setValue( double val );
-    virtual void fitValue( double val );
-    virtual void incValue( int steps );
+    void setValue( double val );
 
-    virtual void setReadOnly( bool );
-
 Q_SIGNALS:
 
     /*!
       \brief Notify a change of value.
 
-      In the default setting
-      (tracking enabled), this signal will be emitted every
-      time the value changes ( see setTracking() ).
-      \param value new value
+      When tracking is enabled (default setting), 
+      this signal will be emitted every time the value changes. 
+
+      \param value New value
+
+      \sa setTracking(), sliderMoved()
     */
     void valueChanged( double value );
 
     /*!
       This signal is emitted when the user presses the
-      movable part of the slider (start ScrMouse Mode).
+      movable part of the slider.
     */
     void sliderPressed();
 
@@ -128,58 +106,59 @@
       This signal is emitted when the user releases the
       movable part of the slider.
     */
-
     void sliderReleased();
+
     /*!
       This signal is emitted when the user moves the
       slider with the mouse.
-      \param value new value
+
+      \param value New value
+
+      \sa valueChanged()
     */
     void sliderMoved( double value );
 
 protected:
-    virtual void setPosition( const QPoint & );
-    virtual void valueChange();
+    virtual void mousePressEvent( QMouseEvent * );
+    virtual void mouseReleaseEvent( QMouseEvent * );
+    virtual void mouseMoveEvent( QMouseEvent * );
+    virtual void keyPressEvent( QKeyEvent * );
+    virtual void wheelEvent( QWheelEvent * );
 
-    virtual void timerEvent( QTimerEvent *e );
-    virtual void mousePressEvent( QMouseEvent *e );
-    virtual void mouseReleaseEvent( QMouseEvent *e );
-    virtual void mouseMoveEvent( QMouseEvent *e );
-    virtual void keyPressEvent( QKeyEvent *e );
-    virtual void wheelEvent( QWheelEvent *e );
-
     /*!
-      \brief Determine the value corresponding to a specified poind
+      \brief Determine what to do when the user presses a mouse button.
 
-      This is an abstract virtual function which is called when
-      the user presses or releases a mouse button or moves the
-      mouse. It has to be implemented by the derived class.
-      \param p point
+      \param pos Mouse position
+
+      \retval True, when pos is a valid scroll position
+      \sa scrolledTo()
     */
-    virtual double getValue( const QPoint & p ) = 0;
+    virtual bool isScrollPosition( const QPoint &pos ) const = 0;
 
     /*!
-      \brief Determine what to do when the user presses a mouse button.
+      \brief Determine the value for a new position of the
+             movable part of the slider
 
-      This function is abstract and has to be implemented by derived classes.
-      It is called on a mousePress event. The derived class can determine
-      what should happen next in dependence of the position where the mouse
-      was pressed by returning scrolling mode and direction. 
+      \param pos Mouse position
 
-      \param pos point where the mouse was pressed
-      \retval scrollMode The scrolling mode
-      \retval direction  direction: 1, 0, or -1.
+      \return Value for the mouse position
+      \sa isScrollPosition()
     */
-    virtual void getScrollMode( const QPoint &pos,
-        ScrollMode &scrollMode, int &direction ) const = 0;
+    virtual double scrolledTo( const QPoint &pos ) const = 0;
 
-    void setMouseOffset( double );
-    double mouseOffset() const;
+    void incrementValue( int numSteps );
 
-    int scrollMode() const;
+    virtual void scaleChange();
 
+protected:
+    virtual void sliderChange();
+
+    double incrementedValue( 
+        double value, int stepCount ) const;
+
 private:
-    void buttonReleased();
+    double alignedValue( double ) const;
+    double boundedValue( double ) const;
 
     class PrivateData;
     PrivateData *d_data;
Index: qwt_round_scale_draw.cpp
===================================================================
--- qwt_round_scale_draw.cpp	(revision 382)
+++ qwt_round_scale_draw.cpp	(working copy)
@@ -11,6 +11,7 @@
 #include "qwt_painter.h"
 #include "qwt_scale_div.h"
 #include "qwt_scale_map.h"
+#include "qwt_math.h"
 #include <qpen.h>
 #include <qpainter.h>
 #include <qfontmetrics.h>
@@ -22,8 +23,8 @@
     PrivateData():
         center( 50.0, 50.0 ),
         radius( 50.0 ),
-        startAngle( -135 * 16 ),
-        endAngle( 135 * 16 )
+        startAngle( -135.0 ),
+        endAngle( 135.0 )
     {
     }
 
@@ -73,6 +74,7 @@
 
   Radius is the radius of the backbone without ticks and labels.
 
+  \return Radius of the scale
   \sa setRadius(), extent()
 */
 double QwtRoundScaleDraw::radius() const
@@ -109,18 +111,20 @@
   \warning <ul>
   <li>The angle range is limited to [-360, 360] degrees. Angles exceeding
       this range will be clipped.
-  <li>For angles more than 359 degrees above or below min(angle1, angle2),
+  <li>For angles more or equal than 360 degrees above or below min(angle1, angle2),
       scale marks will not be drawn.
-  <li>If you need a counterclockwise scale, use QwtScaleDiv::setRange
+  <li>If you need a counterclockwise scale, use QwtScaleDiv::setInterval()
   </ul>
 */
 void QwtRoundScaleDraw::setAngleRange( double angle1, double angle2 )
 {
+#if 0
     angle1 = qBound( -360.0, angle1, 360.0 );
     angle2 = qBound( -360.0, angle2, 360.0 );
+#endif
 
-    d_data->startAngle = angle1 * 16.0;
-    d_data->endAngle = angle2 * 16.0;
+    d_data->startAngle = angle1;
+    d_data->endAngle = angle2;
 
     if ( d_data->startAngle == d_data->endAngle )
     {
@@ -146,8 +150,8 @@
         return;
 
     const double tval = scaleMap().transform( value );
-    if ( ( tval > d_data->startAngle + 359 * 16 )
-        || ( tval < d_data->startAngle - 359 * 16 ) )
+    if ( ( tval >= d_data->startAngle + 360.0 )
+        || ( tval <= d_data->startAngle - 360.0 ) )
     {
         return;
     }
@@ -163,12 +167,12 @@
         radius += tickLength( QwtScaleDiv::MajorTick );
 
     const QSizeF sz = label.textSize( painter->font() );
-    const double arc = tval / 16.0 / 360.0 * 2 * M_PI;
+    const double arc = qwtRadians( tval );
 
     const double x = d_data->center.x() +
         ( radius + sz.width() / 2.0 ) * qSin( arc );
     const double y = d_data->center.y() -
-        ( radius + sz.height() / 2.0 ) * cos( arc );
+        ( radius + sz.height() / 2.0 ) * qCos( arc );
 
     const QRectF r( x - sz.width() / 2, y - sz.height() / 2,
         sz.width(), sz.height() );
@@ -195,10 +199,10 @@
     const double cy = d_data->center.y();
     const double radius = d_data->radius;
 
-    if ( ( tval <= d_data->startAngle + 359 * 16 )
-        || ( tval >= d_data->startAngle - 359 * 16 ) )
+    if ( ( tval < d_data->startAngle + 360.0 )
+        || ( tval > d_data->startAngle - 360.0 ) )
     {
-        const double arc = double( tval ) / 16.0 * M_PI / 180.0;
+        const double arc = qwtRadians( tval );
 
         const double sinArc = qSin( arc );
         const double cosArc = qCos( arc );
@@ -223,15 +227,15 @@
     const double deg1 = scaleMap().p1();
     const double deg2 = scaleMap().p2();
 
-    const int a1 = qRound( qMin( deg1, deg2 ) - 90 * 16 );
-    const int a2 = qRound( qMax( deg1, deg2 ) - 90 * 16 );
+    const int a1 = qRound( qMin( deg1, deg2 ) - 90 );
+    const int a2 = qRound( qMax( deg1, deg2 ) - 90 );
 
     const double radius = d_data->radius;
     const double x = d_data->center.x() - radius;
     const double y = d_data->center.y() - radius;
 
     painter->drawArc( QRectF( x, y, 2 * radius, 2 * radius ),
-        -a2, a2 - a1 + 1 );          // counterclockwise
+        -a2 * 16, ( a2 - a1 + 1 ) * 16 );          // counterclockwise
 }
 
 /*!
@@ -242,9 +246,10 @@
    for the radius of the bounding circle.
 
    \param font Font used for painting the labels
+   \return Calculated extent
 
    \sa setMinimumExtent(), minimumExtent()
-   \warning The implemented algo is not too smart and
+   \warning The implemented algorithm is not too smart and
             calculates only an upper limit, that might be a
             few pixels too large
 */
@@ -267,10 +272,10 @@
                 continue;
 
             const double tval = scaleMap().transform( value );
-            if ( ( tval < d_data->startAngle + 360 * 16 )
-                && ( tval > d_data->startAngle - 360 * 16 ) )
+            if ( ( tval < d_data->startAngle + 360 )
+                && ( tval > d_data->startAngle - 360 ) )
             {
-                const double arc = tval / 16.0 / 360.0 * 2 * M_PI;
+                const double arc = qwtRadians( tval );
 
                 const QSizeF sz = label.textSize( font );
                 const double off = qMax( sz.width(), sz.height() );
@@ -292,7 +297,7 @@
 
     if ( hasComponent( QwtAbstractScaleDraw::Backbone ) )
     {
-        const double pw = qMax( 1, penWidth() );  // penwidth can be zero
+        const double pw = qMax( 1, penWidth() );  // pen width can be zero
         d += pw;
     }
 
Index: qwt_plot_legenditem.cpp
===================================================================
--- qwt_plot_legenditem.cpp	(revision 382)
+++ qwt_plot_legenditem.cpp	(working copy)
@@ -139,7 +139,7 @@
         alignment( Qt::AlignRight | Qt::AlignBottom )
     {
         layout = new QwtDynGridLayout();
-        layout->setMaxCols( 2 );
+        layout->setMaxColumns( 2 );
 
         layout->setSpacing( 0 );
         layout->setContentsMargins( 0, 0, 0, 0 );
@@ -167,6 +167,7 @@
     QwtDynGridLayout *layout;
 };
 
+//! Constructor 
 QwtPlotLegendItem::QwtPlotLegendItem():
     QwtPlotItem( QwtText( "Legend" ) )
 {
@@ -189,6 +190,19 @@
     return QwtPlotItem::Rtti_PlotLegend;
 }
 
+/*!
+  \brief Set the alignmnet
+
+  Alignment means the position of the legend relative
+  to the geometry of the plot canvas. 
+
+  \param alignment Alignment flags
+
+  \sa alignment(), setMaxColumns()
+
+  \note To align a legend with many items horizontally 
+        the number of columns need to be limited
+ */
 void QwtPlotLegendItem::setAlignment( Qt::Alignment alignment )
 {
     if ( d_data->alignment != alignment )
@@ -198,25 +212,51 @@
     }
 }
 
+/*!
+  \return Alignment flags
+  \sa setAlignment()
+ */
 Qt::Alignment QwtPlotLegendItem::alignment() const
 {
     return d_data->alignment;
 }
 
+/*!
+  \brief Limit the number of columns
+
+  When aligning the legend horizontally ( Qt::AlignLeft, Qt::AlignRight )
+  the number of columns needs to be limited to avoid, that
+  the width of the legend grows with an increasing number of entries.
+
+  \param maxColumns Maximum number of columns. 0 means unlimited.
+  \sa maxColumns(), QwtDynGridLayout::setMaxColumns()
+ */
 void QwtPlotLegendItem::setMaxColumns( uint maxColumns )
 {
-    if ( maxColumns != d_data->layout->maxCols() )
+    if ( maxColumns != d_data->layout->maxColumns() )
     {
-        d_data->layout->setMaxCols( maxColumns );
+        d_data->layout->setMaxColumns( maxColumns );
         itemChanged();
     }
 }
 
+/*!
+  \return Maximum number of columns
+  \sa maxColumns(), QwtDynGridLayout::maxColumns()
+ */
 uint QwtPlotLegendItem::maxColumns() const
 {
-    return d_data->layout->maxCols();
+    return d_data->layout->maxColumns();
 }
 
+/*!
+  \brief Set the margin around legend items
+
+  The default setting for the margin is 0.
+
+  \param margin Margin in pixels
+  \sa margin(), setSpacing(), setItemMargin(), setItemSpacing
+ */
 void QwtPlotLegendItem::setMargin( int margin )
 {
     margin = qMax( margin, 0 );
@@ -224,10 +264,15 @@
     {
         d_data->layout->setContentsMargins( 
             margin, margin, margin, margin );
+
         itemChanged();
     }
 }
 
+/*!
+  \return Margin around the legend items
+  \sa setMargin(), spacing(), itemMargin(), itemSpacing()
+ */
 int QwtPlotLegendItem::margin() const
 {
     int left;
@@ -236,6 +281,12 @@
     return left;
 }
 
+/*!
+  \brief Set the spacing between the legend items
+
+  \param spacing Spacing in pixels
+  \sa spacing(), setMargin()
+*/
 void QwtPlotLegendItem::setSpacing( int spacing )
 {
     spacing = qMax( spacing, 0 );
@@ -246,44 +297,74 @@
     }
 }
 
+/*!
+  \return Spacing between the legend items
+  \sa setSpacing(), margin(), itemSpacing(), itemMargin()
+ */
 int QwtPlotLegendItem::spacing() const
 {
     return d_data->layout->spacing();
 }
 
+/*!
+  Set the margin around each item
+
+  \param margin Margin
+  \sa itemMargin(), setItemSpacing(), setMargin(), setSpacing()
+ */
 void QwtPlotLegendItem::setItemMargin( int margin )
 {
     margin = qMax( margin, 0 );
     if ( margin != d_data->itemMargin )
     {
         d_data->itemMargin = margin;
+
         d_data->layout->invalidate();
+        itemChanged();
     }
 }
 
+/*!
+  \return Margin around each item
+  \sa setItemMargin(), itemSpacing(), margin(), spacing()
+*/
 int QwtPlotLegendItem::itemMargin() const
 {
     return d_data->itemMargin;
 }
 
+/*!
+  Set the spacing inside of each item
+
+  \param spacing Spacing
+  \sa itemSpacing(), setItemMargin(), setMargin(), setSpacing()
+ */
 void QwtPlotLegendItem::setItemSpacing( int spacing )
 {
     spacing = qMax( spacing, 0 );
     if ( spacing != d_data->itemSpacing )
     {
         d_data->itemSpacing = spacing;
+
         d_data->layout->invalidate();
+        itemChanged();
     }
 
 }
 
+/*!
+  \return Spacing inside of each item
+  \sa setItemSpacing(), itemMargin(), margin(), spacing()
+*/
 int QwtPlotLegendItem::itemSpacing() const
 {
     return d_data->itemSpacing;
 }
 
 /*!
-   Change the tick label font
+   Change the font used for drawing the text label
+
+   \param font Legend font
    \sa font()
 */
 void QwtPlotLegendItem::setFont( const QFont &font )
@@ -291,12 +372,14 @@
     if ( font != d_data->font )
     {
         d_data->font = font;
+
+        d_data->layout->invalidate();
         itemChanged();
     }
 }
 
 /*!
-   \return tick label font
+   \return Font used for drawing the text label
    \sa setFont()
 */
 QFont QwtPlotLegendItem::font() const
@@ -304,6 +387,14 @@
     return d_data->font;
 }
 
+/*!
+  \brief Set the margin between the legend and the canvas border
+
+  The default setting for the margin is 10 pixels.
+
+  \param distance Margin in pixels
+  \sa setMargin()
+ */
 void QwtPlotLegendItem::setBorderDistance( int distance )
 {
     if ( distance < 0 )
@@ -316,11 +407,21 @@
     }
 }
 
+/*!
+  \return Margin between the legend and the canvas border
+  \sa margin()
+ */
 int QwtPlotLegendItem::borderDistance() const
 {
     return d_data->borderDistance;
 }
 
+/*!
+  Set the radius for the border
+  
+  \param radius A value <= 0 defines a rectangular border
+  \sa borderRadius(), setBorderPen()
+ */
 void QwtPlotLegendItem::setBorderRadius( double radius )
 {
     radius = qMax( 0.0, radius );
@@ -332,11 +433,21 @@
     }
 }
 
+/*!
+  \return Radius of the border
+  \sa setBorderRadius(), setBorderPen()
+ */
 double QwtPlotLegendItem::borderRadius() const
 {
     return d_data->borderRadius;
 }
 
+/*!
+  Set the pen for drawing the border
+
+  \param pen Border pen
+  \sa borderPen(), setBackgroundBrush()
+ */
 void QwtPlotLegendItem::setBorderPen( const QPen &pen )
 {
     if ( d_data->borderPen != pen )
@@ -346,12 +457,23 @@
     }
 }
 
+/*!
+  \return Pen for drawing the border
+  \sa setBorderPen(), backgroundBrush()
+ */
 QPen QwtPlotLegendItem::borderPen() const
 {
     return d_data->borderPen;
 }
 
+/*!
+  \brief Set the background brush
 
+  The brush is used to fill the background
+
+  \param brush Brush
+  \sa backgroundBrush(), setBackgroundMode(), drawBackground()
+ */
 void QwtPlotLegendItem::setBackgroundBrush( const QBrush &brush )
 {
     if ( d_data->backgroundBrush != brush )
@@ -361,11 +483,25 @@
     }
 }
 
+/*!
+  \return Brush is used to fill the background
+  \sa setBackgroundBrush(), backgroundMode(), drawBackground()
+ */
 QBrush QwtPlotLegendItem::backgroundBrush() const
 {
     return d_data->backgroundBrush;
 }
 
+/*!
+  \brief Set the background mode
+
+  Depending on the mode the complete legend or each item 
+  might have an background.
+
+  The default setting is LegendBackground.
+
+   \sa backgroundMode(), setBackgroundBrush(), drawBackground()
+ */
 void QwtPlotLegendItem::setBackgroundMode( BackgroundMode mode )
 {
     if ( mode != d_data->backgroundMode )
@@ -375,11 +511,21 @@
     }
 }
 
+/*! 
+  \return backgroundMode
+  \sa setBackgroundMode(), backgroundBrush(), drawBackground()
+ */
 QwtPlotLegendItem::BackgroundMode QwtPlotLegendItem::backgroundMode() const
 {
     return d_data->backgroundMode;
 }
 
+/*!
+  \brief Set the pen for drawing text labels
+
+  \param pen Text pen
+  \sa textPen(), setFont()
+ */
 void QwtPlotLegendItem::setTextPen( const QPen &pen )
 {
     if ( d_data->textPen != pen )
@@ -389,11 +535,23 @@
     }
 }
 
+/*!
+  \return Pen for drawing text labels
+  \sa setTextPen(), font()
+ */
 QPen QwtPlotLegendItem::textPen() const
 {
     return d_data->textPen;
 }
 
+/*!
+  Draw the legend
+
+  \param painter Painter
+  \param xMap x Scale Map
+  \param yMap y Scale Map
+  \param canvasRect Contents rectangle of the canvas in painter coordinates
+*/
 void QwtPlotLegendItem::draw( QPainter *painter,
     const QwtScaleMap &xMap, const QwtScaleMap &yMap,
     const QRectF &canvasRect ) const
@@ -423,6 +581,15 @@
     }
 }
 
+/*!
+  Draw a rounded rect
+
+  \param painter Painter
+  \param rect Bounding rectangle
+
+  \sa setBorderRadius(), setBorderPen(),
+      setBackgroundBrush(), setBackgroundMode()
+ */
 void QwtPlotLegendItem::drawBackground( 
     QPainter *painter, const QRectF &rect ) const
 {
@@ -437,6 +604,12 @@
     painter->restore();
 }
 
+/*!
+  Calculate the geometry of the legend on the canvas
+
+  \param canvasRect Geometry of the canvas
+  \return Geometry of the legend
+*/
 QRect QwtPlotLegendItem::geometry( const QRectF &canvasRect ) const
 {
     QRect rect;
@@ -474,6 +647,13 @@
     return rect;
 }
 
+/*!
+  Update the legend items according to modifications of a 
+  plot item
+
+  \param plotItem Plot item
+  \param data Attributes of the legend entries
+ */
 void QwtPlotLegendItem::updateLegend( const QwtPlotItem *plotItem,
         const QList<QwtLegendData> &data )
 {
@@ -531,6 +711,7 @@
     }
 }
 
+//! Remove all items from the legend
 void QwtPlotLegendItem::clearLegend()
 {
     if ( !d_data->map.isEmpty() )
@@ -544,12 +725,19 @@
     }
 }
 
+/*!
+  Draw an entry on the legend
+
+  \param painter Qt Painter
+  \param plotItem Plot item, represented by the entry
+  \param data Attributes of the legend entry
+  \param rect Bounding rectangle for the entry
+ */
 void QwtPlotLegendItem::drawLegendData( QPainter *painter,
     const QwtPlotItem *plotItem, const QwtLegendData &data, 
     const QRectF &rect ) const
 {
-    if ( !plotItem->testItemAttribute(QwtPlotItem::Legend) )
-      return;
+    Q_UNUSED( plotItem );
 
     const int m = d_data->itemMargin;
     const QRectF r = rect.toRect().adjusted( m, m, -m, -m );
@@ -582,6 +770,12 @@
     }
 }
 
+/*!
+  Minimum size hint needed to display an entry
+
+  \param data Attributes of the legend entry
+  \return Minimum size
+ */
 QSize QwtPlotLegendItem::minimumSize( const QwtLegendData &data ) const
 {
     QSize size( 2 * d_data->itemMargin, 2 * d_data->itemMargin );
@@ -616,10 +810,15 @@
     return size;
 }
 
+/*!
+  \return The preferred height, for a width.
+  \param data Attributes of the legend entry
+  \param width Width
+*/
 int QwtPlotLegendItem::heightForWidth( 
-    const QwtLegendData &data, int w ) const
+    const QwtLegendData &data, int width ) const
 {
-    w -= 2 * d_data->itemMargin;
+    width -= 2 * d_data->itemMargin;
 
     const QwtGraphic graphic = data.icon();
     const QwtText text = data.title();
@@ -628,10 +827,40 @@
         return graphic.height();
 
     if ( graphic.width() > 0 )
-        w -= graphic.width() + d_data->itemSpacing;
+        width -= graphic.width() + d_data->itemSpacing;
 
-    int h = text.heightForWidth( w, font() );
+    int h = text.heightForWidth( width, font() );
     h += 2 * d_data->itemMargin;
 
     return qMax( graphic.height(), h );
 }
+
+/*! 
+  \return All plot items with an entry on the legend
+  \note A plot item might have more than one entry on the legend
+ */
+QList< const QwtPlotItem * > QwtPlotLegendItem::plotItems() const
+{
+    return d_data->map.keys();
+}
+
+/*!
+  \return Geometries of the items of a plot item
+  \note Usually a plot item has only one entry on the legend
+*/
+QList< QRect > QwtPlotLegendItem::legendGeometries( 
+    const QwtPlotItem *plotItem ) const
+{
+    QList<QwtLegendLayoutItem *> layoutItems;
+
+    QMap<const QwtPlotItem *, QList<QwtLegendLayoutItem *> >::iterator it =
+        d_data->map.find( plotItem );
+    if ( it != d_data->map.end() )
+        layoutItems = it.value();
+
+    QList<QRect> geometries;
+    for ( int i = 0; i < layoutItems.size(); i++ )
+        geometries += layoutItems[i]->geometry();
+
+    return geometries;
+}
Index: qwt_plot_rasteritem.cpp
===================================================================
--- qwt_plot_rasteritem.cpp	(revision 382)
+++ qwt_plot_rasteritem.cpp	(working copy)
@@ -14,6 +14,7 @@
 #include <qdesktopwidget.h>
 #include <qpainter.h>
 #include <qpaintengine.h>
+#include <qmath.h>
 #if QT_VERSION >= 0x040400
 #include <qthread.h>
 #include <qfuture.h>
@@ -26,14 +27,12 @@
 public:
     PrivateData():
         alpha( -1 ),
-        renderThreadCount( 1 ),
         paintAttributes( QwtPlotRasterItem::PaintInDeviceResolution )
     {
         cache.policy = QwtPlotRasterItem::NoCache;
     }
 
     int alpha;
-    uint renderThreadCount;
 
     QwtPlotRasterItem::PaintAttributes paintAttributes;
 
@@ -473,7 +472,7 @@
 }
 
 /*!
-    \brief Return the current paint attributes
+    \return True, when attribute is enabled
     \sa PaintAttribute, setPaintAttribute()
 */
 bool QwtPlotRasterItem::testPaintAttribute( PaintAttribute attribute ) const
@@ -570,44 +569,13 @@
 }
 
 /*!
-   Rendering an image from the raster data can often be done
-   parallel on a multicore system.
-
-   \param numThreads Number of threads to be used for rendering.
-                     If numThreads is set to 0, the system specific
-                     ideal thread count is used.
-
-   The default thread count is 1 ( = no additional threads )
-
-   \warning Rendering in multiple threads is only supported for Qt >= 4.4
-   \sa renderThreadCount(), renderImage(), renderTile()
-*/
-void QwtPlotRasterItem::setRenderThreadCount( uint numThreads )
-{
-    d_data->renderThreadCount = numThreads;
-}
-
-/*!
-   \return Number of threads to be used for rendering.
-           If numThreads is set to 0, the system specific
-           ideal thread count is used.
-
-   \warning Rendering in multiple threads is only supported for Qt >= 4.4
-   \sa setRenderThreadCount(), renderImage(), renderTile()
-*/
-uint QwtPlotRasterItem::renderThreadCount() const
-{
-    return d_data->renderThreadCount;
-}
-
-/*!
    \brief Pixel hint
 
    The geometry of a pixel is used to calculated the resolution and
    alignment of the rendered image. 
 
    Width and height of the hint need to be the horizontal  
-   and vertical distances between 2 neighboured points. 
+   and vertical distances between 2 neighbored points. 
    The center of the hint has to be the position of any point 
    ( it doesn't matter which one ).
 
@@ -637,7 +605,7 @@
   \param painter Painter
   \param xMap X-Scale Map
   \param yMap Y-Scale Map
-  \param canvasRect Contents rect of the plot canvas
+  \param canvasRect Contents rectangle of the plot canvas
 */
 void QwtPlotRasterItem::draw( QPainter *painter,
     const QwtScaleMap &xMap, const QwtScaleMap &yMap,
@@ -652,7 +620,7 @@
     const QwtInterval yInterval = interval( Qt::YAxis );
 
     /*
-        Scaling a rastered image always results in a loss of
+        Scaling an image always results in a loss of
         precision/quality. So we always render the image in
         paint device resolution.
     */
@@ -679,11 +647,11 @@
     QRectF pixelRect = pixelHint(area);
     if ( !pixelRect.isEmpty() )
     {
-        const QRectF r = QwtScaleMap::invTransform( 
-            xxMap, yyMap, QRectF(0, 0, 1, 1) ).normalized();
+        // pixel in target device resolution 
+        const double dx = qAbs( xxMap.invTransform( 1 ) - xxMap.invTransform( 0 ) );
+        const double dy = qAbs( yyMap.invTransform( 1 ) - yyMap.invTransform( 0 ) );
 
-        if ( r.width() > pixelRect.width() &&
-            r.height() > pixelRect.height() )
+        if ( dx > pixelRect.width() && dy > pixelRect.height() )
         {
             /*
               When the resolution of the data pixels is higher than
@@ -795,7 +763,7 @@
 }
 
 /*!
-   \return Bounding rect of the data
+   \return Bounding rectangle of the data
    \sa QwtPlotRasterItem::interval()
 */
 QRectF QwtPlotRasterItem::boundingRect() const
@@ -928,6 +896,8 @@
    \param area Area to be painted on the image
    \param imageSize Image size
    \param pixelSize Width/Height of a data pixel
+
+   \return Calculated scale map
 */
 QwtScaleMap QwtPlotRasterItem::imageMap(
     Qt::Orientation orientation,
Index: qwt_column_symbol.cpp
===================================================================
--- qwt_column_symbol.cpp	(revision 382)
+++ qwt_column_symbol.cpp	(working copy)
@@ -9,12 +9,11 @@
 
 #include "qwt_column_symbol.h"
 #include "qwt_math.h"
-#include "qwt_text.h"
 #include "qwt_painter.h"
 #include <qpainter.h>
 #include <qpalette.h>
 
-static void drawBox( QPainter *p, const QRectF &rect,
+static void qwtDrawBox( QPainter *p, const QRectF &rect,
     const QPalette &pal, double lw )
 {
     if ( lw > 0.0 )
@@ -57,7 +56,7 @@
         p->fillRect( windowRect, pal.window() );
 }
 
-static void drawPanel( QPainter *painter, const QRectF &rect,
+static void qwtDrawPanel( QPainter *painter, const QRectF &rect,
     const QPalette &pal, double lw )
 {
     if ( lw > 0.0 )
@@ -124,8 +123,6 @@
     QwtColumnSymbol::FrameStyle frameStyle;
 
     QPalette palette;
-    QwtText label;
-
     int lineWidth;
 };
 
@@ -280,12 +277,12 @@
     {
         case QwtColumnSymbol::Raised:
         {
-            ::drawPanel( painter, r, d_data->palette, d_data->lineWidth );
+            qwtDrawPanel( painter, r, d_data->palette, d_data->lineWidth );
             break;
         }
         case QwtColumnSymbol::Plain:
         {
-            ::drawBox( painter, r, d_data->palette, d_data->lineWidth );
+            qwtDrawBox( painter, r, d_data->palette, d_data->lineWidth );
             break;
         }
         default:
Index: qwt_series_data.cpp
===================================================================
--- qwt_series_data.cpp	(revision 382)
+++ qwt_series_data.cpp	(working copy)
@@ -57,7 +57,7 @@
 }
 
 /*!
-  \brief Calculate the bounding rect of a series subset
+  \brief Calculate the bounding rectangle of a series subset
 
   Slow implementation, that iterates over the series.
 
@@ -111,7 +111,7 @@
 }
 
 /*!
-  \brief Calculate the bounding rect of a series subset
+  \brief Calculate the bounding rectangle of a series subset
 
   Slow implementation, that iterates over the series.
 
@@ -128,7 +128,7 @@
 }
 
 /*!
-  \brief Calculate the bounding rect of a series subset
+  \brief Calculate the bounding rectangle of a series subset
 
   Slow implementation, that iterates over the series.
 
@@ -145,7 +145,7 @@
 }
 
 /*!
-  \brief Calculate the bounding rect of a series subset
+  \brief Calculate the bounding rectangle of a series subset
 
   The horizontal coordinates represent the azimuth, the
   vertical coordinates the radius.
@@ -165,7 +165,7 @@
 }
 
 /*!
-  \brief Calculate the bounding rect of a series subset
+  \brief Calculate the bounding rectangle of a series subset
 
   Slow implementation, that iterates over the series.
 
@@ -182,7 +182,7 @@
 }
 
 /*!
-  \brief Calculate the bounding rect of a series subset
+  \brief Calculate the bounding rectangle of a series subset
 
   Slow implementation, that iterates over the series.
 
@@ -199,7 +199,7 @@
 }
 
 /*!
-  \brief Calculate the bounding rect of a series subset
+  \brief Calculate the bounding rectangle of a series subset
 
   Slow implementation, that iterates over the series.
 
@@ -226,7 +226,7 @@
 }
 
 /*!
-  \brief Calculate the bounding rect
+  \brief Calculate the bounding rectangle
 
   The bounding rectangle is calculated once by iterating over all
   points and is stored for all following requests.
@@ -252,7 +252,7 @@
 }
 
 /*!
-  \brief Calculate the bounding rect
+  \brief Calculate the bounding rectangle
 
   The bounding rectangle is calculated once by iterating over all
   points and is stored for all following requests.
@@ -278,7 +278,7 @@
 }
 
 /*!
-  \brief Calculate the bounding rect
+  \brief Calculate the bounding rectangle
 
   The bounding rectangle is calculated once by iterating over all
   points and is stored for all following requests.
@@ -304,7 +304,7 @@
 }
 
 /*!
-  \brief Calculate the bounding rect
+  \brief Calculate the bounding rectangle
 
   The bounding rectangle is calculated once by iterating over all
   points and is stored for all following requests.
@@ -330,7 +330,7 @@
 }
 
 /*!
-  \brief Calculate the bounding rect
+  \brief Calculate the bounding rectangle
 
   The bounding rectangle is calculated once by iterating over all
   points and is stored for all following requests.
Index: qwt_counter.h
===================================================================
--- qwt_counter.h	(revision 382)
+++ qwt_counter.h	(working copy)
@@ -11,7 +11,6 @@
 #define QWT_COUNTER_H
 
 #include "qwt_global.h"
-#include "qwt_double_range.h"
 #include <qwidget.h>
 
 /*!
@@ -22,53 +21,47 @@
   of the label which can be used to increment or decrement
   the counter's value.
 
-  A Counter has a range from a minimum value to a maximum value
-  and a step size. The range can be specified using
-  QwtDblRange::setRange().
-  The counter's value is an integer multiple of the step size.
-  The number of steps by which a button increments or decrements
-  the value can be specified using QwtCounter::setIncSteps().
-  The number of buttons can be changed with
-  QwtCounter::setNumButtons().
+  A counter has a range from a minimum value to a maximum value
+  and a step size. When the wrapping property is set
+  the counter is circular.
+ 
+  The number of steps by which a button increments or decrements the value 
+  can be specified using setIncSteps(). The number of buttons can be 
+  changed with setNumButtons().
 
-  Holding the space bar down with focus on a button is the
-  fastest method to step through the counter values.
-  When the counter underflows/overflows, the focus is set
-  to the smallest up/down button and counting is disabled.
-  Counting is re-enabled on a button release event (mouse or
-  space bar).
-
   Example:
 \code
-#include "../include/qwt_counter.h>
+#include <qwt_counter.h>
 
-QwtCounter *cnt;
+QwtCounter *counter = new QwtCounter(parent);
 
-cnt = new QwtCounter(parent, name);
+counter->setRange(0.0, 100.0);                  // From 0.0 to 100
+counter->setSingleStep( 1.0 );                  // Step size 1.0
+counter->setNumButtons(2);                      // Two buttons each side
+counter->setIncSteps(QwtCounter::Button1, 1);   // Button 1 increments 1 step
+counter->setIncSteps(QwtCounter::Button2, 20);  // Button 2 increments 20 steps
 
-cnt->setRange(0.0, 100.0, 1.0);             // From 0.0 to 100, step 1.0
-cnt->setNumButtons(2);                      // Two buttons each side
-cnt->setIncSteps(QwtCounter::Button1, 1);   // Button 1 increments 1 step
-cnt->setIncSteps(QwtCounter::Button2, 20);  // Button 2 increments 20 steps
-
-connect(cnt, SIGNAL(valueChanged(double)), my_class, SLOT(newValue(double)));
+connect(counter, SIGNAL(valueChanged(double)), myClass, SLOT(newValue(double)));
 \endcode
  */
 
-class QWT_EXPORT QwtCounter : public QWidget, public QwtDoubleRange
+class QWT_EXPORT QwtCounter : public QWidget
 {
     Q_OBJECT
 
+    Q_PROPERTY( double value READ value WRITE setValue )
+    Q_PROPERTY( double minimum READ minimum WRITE setMinimum )
+    Q_PROPERTY( double maximum READ maximum WRITE setMaximum )
+    Q_PROPERTY( double singleStep READ singleStep WRITE setSingleStep )
+
     Q_PROPERTY( int numButtons READ numButtons WRITE setNumButtons )
-    Q_PROPERTY( double basicstep READ step WRITE setStep )
-    Q_PROPERTY( double minValue READ minValue WRITE setMinValue )
-    Q_PROPERTY( double maxValue READ maxValue WRITE setMaxValue )
     Q_PROPERTY( int stepButton1 READ stepButton1 WRITE setStepButton1 )
     Q_PROPERTY( int stepButton2 READ stepButton2 WRITE setStepButton2 )
     Q_PROPERTY( int stepButton3 READ stepButton3 WRITE setStepButton3 )
-    Q_PROPERTY( double value READ value WRITE setValue )
-    Q_PROPERTY( bool editable READ editable WRITE setEditable )
 
+    Q_PROPERTY( bool readOnly READ isReadOnly WRITE setReadOnly )
+    Q_PROPERTY( bool wrapping READ wrapping WRITE setWrapping )
+
 public:
     //! Button index
     enum Button
@@ -89,9 +82,15 @@
     explicit QwtCounter( QWidget *parent = NULL );
     virtual ~QwtCounter();
 
-    bool editable() const;
-    void setEditable( bool );
+    void setValid( bool );
+    bool isValid() const;
 
+    void setWrapping( bool );
+    bool wrapping() const;
+
+    bool isReadOnly() const;
+    void setReadOnly( bool );
+
     void setNumButtons( int n );
     int numButtons() const;
 
@@ -100,17 +99,17 @@
 
     virtual QSize sizeHint() const;
 
-    // a set of dummies to help the designer
+    double singleStep() const;
+    void setSingleStep( double s );
 
-    double step() const;
-    void setStep( double s );
+    void setRange( double min, double max );
+    
+    double minimum() const;
+    void setMinimum( double min );
 
-    double minValue() const;
-    void setMinValue( double m );
+    double maximum() const;
+    void setMaximum( double max );
 
-    double maxValue() const;
-    void setMaxValue( double m );
-
     void setStepButton1( int nSteps );
     int stepButton1() const;
 
@@ -120,10 +119,10 @@
     void setStepButton3( int nSteps );
     int stepButton3() const;
 
-    virtual double value() const;
+    double value() const;
 
 public Q_SLOTS:
-    virtual void setValue( double );
+    void setValue( double );
 
 
 Q_SIGNALS:
@@ -143,7 +142,6 @@
     virtual bool event( QEvent * );
     virtual void wheelEvent( QWheelEvent * );
     virtual void keyPressEvent( QKeyEvent * );
-    virtual void rangeChange();
 
 private Q_SLOTS:
     void btnReleased();
@@ -151,10 +149,10 @@
     void textChanged();
 
 private:
+    void incrementValue( int numSteps );
     void initCounter();
     void updateButtons();
-    void showNum( double );
-    virtual void valueChange();
+    void showNumber( double );
 
     class PrivateData;
     PrivateData *d_data;
Index: qwt_null_paintdevice.cpp
===================================================================
--- qwt_null_paintdevice.cpp	(revision 382)
+++ qwt_null_paintdevice.cpp	(working copy)
@@ -404,6 +404,10 @@
 
 /*! 
     See QPaintDevice::metric()
+
+    \param deviceMetric Type of metric
+    \return Metric information for the given paint device metric.
+
     \sa sizeMetrics()
 */
 int QwtNullPaintDevice::metric( PaintDeviceMetric deviceMetric ) const
Index: qwt_legend_data.cpp
===================================================================
--- qwt_legend_data.cpp	(revision 382)
+++ qwt_legend_data.cpp	(working copy)
@@ -9,34 +9,65 @@
 
 #include "qwt_legend_data.h"
 
+//! Constructor
 QwtLegendData::QwtLegendData()
 {
 }
 
+//! Destructor
 QwtLegendData::~QwtLegendData()
 {
 }
 
+/*!
+  Set the legend attributes
+
+  QwtLegendData actually is a QMap<int, QVariant> with some
+  convenience interfaces
+
+  \param map Values
+  \sa values()
+ */
 void QwtLegendData::setValues( const QMap<int, QVariant> &map )
 {
     d_map = map;
 }
 
+/*!
+  \return Legend attributes
+  \sa setValues()
+ */
 const QMap<int, QVariant> &QwtLegendData::values() const
 {
     return d_map;
 }
 
+/*!
+  \param role Attribute role
+  \return True, when the internal map has an entry for role
+ */
 bool QwtLegendData::hasRole( int role ) const
 {
     return d_map.contains( role );
 }
 
+/*!
+  Set an attribute value
+
+  \param role Attribute role
+  \param data Attribute value
+
+  \sa value()
+ */
 void QwtLegendData::setValue( int role, const QVariant &data )
 {
     d_map[role] = data;
 }
 
+/*!
+  \param role Attribute role
+  \return Attribute value for a specific role
+ */
 QVariant QwtLegendData::value( int role ) const
 {
     if ( !d_map.contains( role ) )
@@ -45,11 +76,13 @@
     return d_map[role];
 }
 
+//! \return True, when the internal map is empty
 bool QwtLegendData::isValid() const
 {
     return !d_map.isEmpty();
 }
 
+//! \return Value of the TitleRole attribute
 QwtText QwtLegendData::title() const
 {
     QwtText text;
@@ -67,6 +100,7 @@
     return text;
 }
 
+//! \return Value of the IconRole attribute
 QwtGraphic QwtLegendData::icon() const
 {
     const QVariant iconValue = value( QwtLegendData::IconRole );
@@ -80,6 +114,7 @@
     return graphic;
 }
 
+//! \return Value of the ModeRole attribute
 QwtLegendData::Mode QwtLegendData::mode() const
 {
     const QVariant modeValue = value( QwtLegendData::ModeRole );
Index: qwt_plot_curve.h
===================================================================
--- qwt_plot_curve.h	(revision 382)
+++ qwt_plot_curve.h	(working copy)
@@ -120,7 +120,7 @@
           A QwtCurveFitter tries to
           interpolate/smooth the curve, before it is painted.
 
-          \note Curve fitting requires temorary memory
+          \note Curve fitting requires temporary memory
           for calculating coefficients and additional points.
           If painting in QwtPlotCurve::Fitted mode is slow it might be better
           to fit the points, before they are passed to QwtPlotCurve.
@@ -186,7 +186,7 @@
           Tries to reduce the data that has to be painted, by sorting out
           duplicates, or paintings outside the visible area. Might have a
           notable impact on curves with many close points.
-          Only a couple of very basic filtering algos are implemented.
+          Only a couple of very basic filtering algorithms are implemented.
          */
         FilterPoints = 0x02,
 
@@ -229,6 +229,7 @@
     void setSamples( const QVector<double> &xData, const QVector<double> &yData );
 #endif
     void setSamples( const QVector<QPointF> & );
+    void setSamples( QwtSeriesData<QPointF> * );
 
     int closestPoint( const QPoint &pos, double *dist = NULL ) const;
 
@@ -240,6 +241,7 @@
     void setCurveAttribute( CurveAttribute, bool on = true );
     bool testCurveAttribute( CurveAttribute ) const;
 
+    void setPen( const QColor &, qreal width = 0.0, Qt::PenStyle = Qt::SolidLine );
     void setPen( const QPen & );
     const QPen &pen() const;
 
@@ -252,7 +254,7 @@
     void setStyle( CurveStyle style );
     CurveStyle style() const;
 
-    void setSymbol( const QwtSymbol *s );
+    void setSymbol( QwtSymbol * );
     const QwtSymbol *symbol() const;
 
     void setCurveFitter( QwtCurveFitter * );
@@ -276,19 +278,19 @@
         const QwtScaleMap &xMap, const QwtScaleMap &yMap,
         const QRectF &canvasRect, int from, int to ) const;
 
-    void drawLines( QPainter *p,
+    virtual void drawLines( QPainter *p,
         const QwtScaleMap &xMap, const QwtScaleMap &yMap,
         const QRectF &canvasRect, int from, int to ) const;
 
-    void drawSticks( QPainter *p,
+    virtual void drawSticks( QPainter *p,
         const QwtScaleMap &xMap, const QwtScaleMap &yMap,
         const QRectF &canvasRect, int from, int to ) const;
 
-    void drawDots( QPainter *p,
+    virtual void drawDots( QPainter *p,
         const QwtScaleMap &xMap, const QwtScaleMap &yMap,
         const QRectF &canvasRect, int from, int to ) const;
 
-    void drawSteps( QPainter *p,
+    virtual void drawSteps( QPainter *p,
         const QwtScaleMap &xMap, const QwtScaleMap &yMap,
         const QRectF &canvasRect, int from, int to ) const;
 
Index: qwt_plot_grid.h
===================================================================
--- qwt_plot_grid.h	(revision 382)
+++ qwt_plot_grid.h	(working copy)
@@ -24,7 +24,7 @@
 
   The QwtPlotGrid class can be used to draw a coordinate grid.
   A coordinate grid consists of major and minor vertical
-  and horizontal gridlines. The locations of the gridlines
+  and horizontal grid lines. The locations of the grid lines
   are determined by the X and Y scale divisions which can
   be assigned with setXDiv() and setYDiv().
   The draw() member draws the grid within a bounding
@@ -57,13 +57,16 @@
     void setYDiv( const QwtScaleDiv &sy );
     const QwtScaleDiv &yScaleDiv() const;
 
-    void setPen( const QPen &p );
+    void setPen( const QColor &, qreal width = 0.0, Qt::PenStyle = Qt::SolidLine );
+    void setPen( const QPen & );
 
-    void setMajPen( const QPen &p );
-    const QPen& majPen() const;
+    void setMajorPen( const QColor &, qreal width = 0.0, Qt::PenStyle = Qt::SolidLine );
+    void setMajorPen( const QPen & );
+    const QPen& majorPen() const;
 
-    void setMinPen( const QPen &p );
-    const QPen& minPen() const;
+    void setMinorPen( const QColor &, qreal width = 0.0, Qt::PenStyle = Qt::SolidLine );
+    void setMinorPen( const QPen &p );
+    const QPen& minorPen() const;
 
     virtual void draw( QPainter *p,
         const QwtScaleMap &xMap, const QwtScaleMap &yMap,
Index: qwt_interval.h
===================================================================
--- qwt_interval.h	(revision 382)
+++ qwt_interval.h	(working copy)
@@ -11,6 +11,8 @@
 #define QWT_INTERVAL_H
 
 #include "qwt_global.h"
+#include <qmetatype.h>
+
 #ifndef QT_NO_DEBUG_STREAM
 #include <qdebug.h>
 #endif
@@ -199,10 +201,27 @@
 }
 
 /*!
-   Return the width of an interval
+   A interval is valid when minValue() <= maxValue().
+   In case of QwtInterval::ExcludeBorders it is true
+   when minValue() < maxValue()
+
+   \return True, when the interval is valid
+*/
+inline bool QwtInterval::isValid() const
+{
+    if ( ( d_borderFlags & ExcludeBorders ) == 0 )
+        return d_minValue <= d_maxValue;
+    else
+        return d_minValue < d_maxValue;
+}
+
+/*!
+   \brief Return the width of an interval
+
    The width of invalid intervals is 0.0, otherwise the result is
    maxValue() - minValue().
 
+   \return Interval width
    \sa isValid()
 */
 inline double QwtInterval::width() const
@@ -211,34 +230,51 @@
 }
 
 /*!
-   Intersection of two intervals
+   \brief Intersection of two intervals
+ 
+   \param other Interval to intersect with
+   \return Intersection of this and other
+
    \sa intersect()
 */
 inline QwtInterval QwtInterval::operator&(
-    const QwtInterval &interval ) const
+    const QwtInterval &other ) const
 {
-    return intersect( interval );
+    return intersect( other );
 }
 
 /*!
    Union of two intervals
+
+   \param other Interval to unite with
+   \return Union of this and other
+
    \sa unite()
 */
 inline QwtInterval QwtInterval::operator|(
-    const QwtInterval &interval ) const
+    const QwtInterval &other ) const
 {
-    return unite( interval );
+    return unite( other );
 }
 
-//! Compare two intervals
+/*! 
+   \brief Compare two intervals
+
+   \param other Interval to compare with
+   \return True, when this and other are equal
+*/
 inline bool QwtInterval::operator==( const QwtInterval &other ) const
 {
     return ( d_minValue == other.d_minValue ) &&
            ( d_maxValue == other.d_maxValue ) &&
            ( d_borderFlags == other.d_borderFlags );
 }
+/*! 
+   \brief Compare two intervals
 
-//! Compare two intervals
+   \param other Interval to compare with
+   \return True, when this and other are not equal
+*/
 inline bool QwtInterval::operator!=( const QwtInterval &other ) const
 {
     return ( !( *this == other ) );
@@ -263,19 +299,6 @@
 }
 
 /*!
-   A interval is valid when minValue() <= maxValue().
-   In case of QwtInterval::ExcludeBorders it is true
-   when minValue() < maxValue()
-*/
-inline bool QwtInterval::isValid() const
-{
-    if ( ( d_borderFlags & ExcludeBorders ) == 0 )
-        return d_minValue <= d_maxValue;
-    else
-        return d_minValue < d_maxValue;
-}
-
-/*!
   Invalidate the interval
 
   The limits are set to interval [0.0, -1.0]
@@ -288,6 +311,7 @@
 }
 
 Q_DECLARE_OPERATORS_FOR_FLAGS( QwtInterval::BorderFlags )
+Q_DECLARE_METATYPE( QwtInterval )
 
 #ifndef QT_NO_DEBUG_STREAM
 QWT_EXPORT QDebug operator<<( QDebug, const QwtInterval & );
Index: qwt_plot_spectrogram.h
===================================================================
--- qwt_plot_spectrogram.h	(revision 382)
+++ qwt_plot_spectrogram.h	(working copy)
@@ -20,15 +20,19 @@
 /*!
   \brief A plot item, which displays a spectrogram
 
-  A spectrogram displays threedimenional data, where the 3rd dimension
+  A spectrogram displays 3-dimensional data, where the 3rd dimension
   ( the intensity ) is displayed using colors. The colors are calculated
   from the values using a color map.
 
+  On multi-core systems the performance of the image composition
+  can often be improved by dividing the area into tiles - each of them
+  rendered in a different thread ( see QwtPlotItem::setRenderThreadCount() ).
+
   In ContourMode contour lines are painted for the contour levels.
 
   \image html spectrogram3.png
 
-  \sa QwtRasterData, QwtColorMap
+  \sa QwtRasterData, QwtColorMap, QwtPlotItem::setRenderThreadCount()
 */
 
 class QWT_EXPORT QwtPlotSpectrogram: public QwtPlotRasterItem
@@ -67,6 +71,8 @@
     virtual QwtInterval interval(Qt::Axis) const;
     virtual QRectF pixelHint( const QRectF & ) const;
 
+    void setDefaultContourPen( const QColor &, 
+        qreal width = 0.0, Qt::PenStyle = Qt::SolidLine );
     void setDefaultContourPen( const QPen & );
     QPen defaultContourPen() const;
 
Index: qwt_plot_tradingcurve.cpp
===================================================================
--- qwt_plot_tradingcurve.cpp	(revision 382)
+++ qwt_plot_tradingcurve.cpp	(working copy)
@@ -25,72 +25,14 @@
     return !isOffScreen;
 }
 
-static inline void qwtDrawBar( QPainter *painter,
-    const QwtOHLCSample &sample, Qt::Orientation orientation, 
-    bool inverted, double width )
-{
-    double w2 = 0.5 * width;
-    if ( inverted )
-        w2 *= -1;
-
-    if ( orientation == Qt::Vertical )
-    {
-        QwtPainter::drawLine( painter,
-            sample.time, sample.low, sample.time, sample.high );
-
-        QwtPainter::drawLine( painter,
-            sample.time - w2, sample.open, sample.time, sample.open );
-        QwtPainter::drawLine( painter,
-            sample.time + w2, sample.close, sample.time, sample.close );
-    }
-    else
-    {
-        QwtPainter::drawLine( painter, sample.low, sample.time,
-            sample.high, sample.time );
-        QwtPainter::drawLine( painter,
-            sample.open, sample.time - w2, sample.open, sample.time );
-        QwtPainter::drawLine( painter,
-            sample.close, sample.time + w2, sample.close, sample.time );
-    }
-}
-
-static inline void qwtDrawCandleStick( QPainter *painter,
-    const QwtOHLCSample &sample, Qt::Orientation orientation, double width )
-{
-    const double t = sample.time;
-    const double v1 = qMin( sample.low, sample.high );
-    const double v2 = qMin( sample.open, sample.close );
-    const double v3 = qMax( sample.low, sample.high );
-    const double v4 = qMax( sample.open, sample.close );
-
-    if ( orientation == Qt::Vertical )
-    {
-        QwtPainter::drawLine( painter, t, v1, t, v2 );
-        QwtPainter::drawLine( painter, t, v3, t, v4 );
-
-        QRectF rect( t - 0.5 * width, sample.open,
-            width, sample.close - sample.open );
-
-        QwtPainter::drawRect( painter, rect );
-    }
-    else
-    {
-        QwtPainter::drawLine( painter, v1, t, v2, t );
-        QwtPainter::drawLine( painter, v3, t, v4, t );
-
-        const QRectF rect( sample.open, t - 0.5 * width,
-            sample.close - sample.open, width );
-
-        QwtPainter::drawRect( painter, rect );
-    }
-}
-
 class QwtPlotTradingCurve::PrivateData
 {
 public:
     PrivateData():
         symbolStyle( QwtPlotTradingCurve::CandleStick ),
-        symbolWidth( 0.6 ),
+        symbolExtent( 0.6 ),
+        minSymbolWidth( 2.0 ),
+        maxSymbolWidth( -1.0 ),
         paintAttributes( QwtPlotTradingCurve::ClipSymbols )
     {
         symbolBrush[0] = QBrush( Qt::white );
@@ -98,7 +40,9 @@
     }
 
     QwtPlotTradingCurve::SymbolStyle symbolStyle;
-    double symbolWidth;
+    double symbolExtent;
+    double minSymbolWidth;
+    double maxSymbolWidth;
 
     QPen symbolPen;
     QBrush symbolBrush[2]; // Increasing/Decreasing
@@ -167,7 +111,7 @@
 }
 
 /*!
-    \brief Return the current paint attributes
+    \return True, when attribute is enabled
     \sa PaintAttribute, setPaintAttribute()
 */
 bool QwtPlotTradingCurve::testPaintAttribute(
@@ -189,11 +133,27 @@
 }
 
 /*!
+  Assign a series of samples
+    
+  setSamples() is just a wrapper for setData() without any additional
+  value - beside that it is easier to find for the developer.
+    
+  \param data Data
+  \warning The item takes ownership of the data object, deleting
+           it when its not used anymore. 
+*/
+void QwtPlotTradingCurve::setSamples(
+    QwtSeriesData<QwtOHLCSample> *data )
+{
+    setData( data );
+}   
+
+/*!
   Set the symbol style
 
   \param style Symbol style
 
-  \sa symbolStyle(), setSymbolWidth(),
+  \sa symbolStyle(), setSymbolExtent(),
       setSymbolPen(), setSymbolBrush()
 */
 void QwtPlotTradingCurve::setSymbolStyle( SymbolStyle style )
@@ -209,13 +169,32 @@
 
 /*!
   \return Symbol style
-  \sa setSymbolStyle(), symbolWidth(), symbolPen(), symbolBrush()
+  \sa setSymbolStyle(), symbolExtent(), symbolPen(), symbolBrush()
 */
 QwtPlotTradingCurve::SymbolStyle QwtPlotTradingCurve::symbolStyle() const
 {
     return d_data->symbolStyle;
 }
 
+/*! 
+  Build and assign the symbol pen
+    
+  In Qt5 the default pen width is 1.0 ( 0.0 in Qt4 ) what makes it
+  non cosmetic ( see QPen::isCosmetic() ). This method has been introduced
+  to hide this incompatibility.
+    
+  \param color Pen color
+  \param width Pen width
+  \param style Pen style
+    
+  \sa pen(), brush()
+ */ 
+void QwtPlotTradingCurve::setSymbolPen( 
+    const QColor &color, qreal width, Qt::PenStyle style )
+{   
+    setSymbolPen( QPen( color, width, style ) );
+}
+
 /*!
   \brief Set the symbol pen
 
@@ -284,22 +263,24 @@
 }
 
 /*!
-  \brief Set the width of the symbol
+  \brief Set the extent of the symbol
 
   The width of the symbol is given in scale coordinates. When painting
-  a the symbols the width is scaled into paint device coordinates
-  by scaledSymbolWidth().
+  a symbol the width is scaled into paint device coordinates
+  by scaledSymbolWidth(). The scaled width is bounded by
+  minSymbolWidth(), maxSymbolWidth()
 
-  \param width Symbol width in scale coordinates
+  \param extent Symbol width in scale coordinates
 
-  \sa symbolWidth(), scaledSymbolWidth()
+  \sa symbolExtent(), scaledSymbolWidth(), 
+      setMinSymbolWidth(), setMaxSymbolWidth()
 */
-void QwtPlotTradingCurve::setSymbolWidth( double width )
+void QwtPlotTradingCurve::setSymbolExtent( double extent )
 {
-    width = qMax( 0.0, width );
-    if ( width != d_data->symbolWidth )
+    extent = qMax( 0.0, extent );
+    if ( extent != d_data->symbolExtent )
     {
-        d_data->symbolWidth = width;
+        d_data->symbolExtent = extent;
 
         legendChanged();
         itemChanged();
@@ -307,15 +288,71 @@
 }
 
 /*!
-  \return Symbol width in scale coordinates
-  \sa setSymbolWidth(), scaledSymbolWidth()
+  \return Extent of a symbol in scale coordinates
+  \sa setSymbolExtent(), scaledSymbolWidth(),
+      minSymbolWidth(), maxSymbolWidth()
 */
-double QwtPlotTradingCurve::symbolWidth() const
+double QwtPlotTradingCurve::symbolExtent() const
 {
-    return d_data->symbolWidth;
+    return d_data->symbolExtent;
 }
 
 /*!
+  Set a minimum for the symbol width
+
+  \param width Width in paint device coordinates
+  \sa minSymbolWidth(), setMaxSymbolWidth(), setSymbolExtent()
+ */
+void QwtPlotTradingCurve::setMinSymbolWidth( double width )
+{
+    width = qMax( width, 0.0 );
+    if ( width != d_data->minSymbolWidth )
+    {
+        d_data->minSymbolWidth = width;
+
+        legendChanged();
+        itemChanged();
+    }
+}
+
+/*!
+  \return Minmum for the symbol width
+  \sa setMinSymbolWidth(), maxSymbolWidth(), symbolExtent()
+ */
+double QwtPlotTradingCurve::minSymbolWidth() const
+{
+    return d_data->minSymbolWidth;
+}
+
+/*!
+  Set a maximum for the symbol width
+
+  A value <= 0.0 means an unlimited width
+
+  \param width Width in paint device coordinates
+  \sa maxSymbolWidth(), setMinSymbolWidth(), setSymbolExtent()
+ */
+void QwtPlotTradingCurve::setMaxSymbolWidth( double width )
+{
+    if ( width != d_data->maxSymbolWidth )
+    {
+        d_data->maxSymbolWidth = width;
+    
+        legendChanged();
+        itemChanged();
+    }
+}
+
+/*!
+  \return Maximum for the symbol width
+  \sa setMaxSymbolWidth(), minSymbolWidth(), symbolExtent()
+ */
+double QwtPlotTradingCurve::maxSymbolWidth() const
+{
+    return d_data->maxSymbolWidth;
+}
+
+/*!
   \return Bounding rectangle of all samples.
   For an empty series the rectangle is invalid.
 */
@@ -334,7 +371,7 @@
   \param painter Painter
   \param xMap Maps x-values into pixel coordinates.
   \param yMap Maps y-values into pixel coordinates.
-  \param canvasRect Contents rect of the canvas
+  \param canvasRect Contents rectangle of the canvas
   \param from Index of the first point to be painted
   \param to Index of the last point to be painted. If to < 0 the
          curve will be painted to its last point.
@@ -368,7 +405,7 @@
   \param painter Painter
   \param xMap x map
   \param yMap y map
-  \param canvasRect Contents rect of the canvas
+  \param canvasRect Contents rectangle of the canvas
   \param from Index of the first point to be painted
   \param to Index of the last point to be painted
 
@@ -406,8 +443,6 @@
     }
 
     const bool inverted = timeMap->isInverting();
-
-
     const bool doClip = d_data->paintAttributes & ClipSymbols;
     const bool doAlign = QwtPainter::roundingAlignment( painter );
 
@@ -451,15 +486,15 @@
             {
                 case Bar:
                 {
-                    qwtDrawBar( painter,
-                        translatedSample, orient, inverted, symbolWidth );
+                    drawBar( painter, translatedSample, 
+                        orient, inverted, symbolWidth );
                     break;
                 }
                 case CandleStick:
                 {
                     painter->setBrush( d_data->symbolBrush[ brushIndex ] );
-                    qwtDrawCandleStick( painter,
-                        translatedSample, orient, symbolWidth );
+                    drawCandleStick( painter, translatedSample, 
+                        orient, symbolWidth );
                     break;
                 }
                 default:
@@ -468,7 +503,7 @@
                     {
                         painter->setBrush( d_data->symbolBrush[ brushIndex ] );
                         drawUserSymbol( painter, d_data->symbolStyle,
-                            symbolWidth, translatedSample );
+                            translatedSample, orient, inverted, symbolWidth );
                     }
                 }
             }
@@ -483,20 +518,113 @@
 
   \param painter Qt painter, initialized with pen/brush
   \param symbolStyle Symbol style
-  \param symbolWidth Width of the symbol in paint device metrics
   \param sample Samples already translated into paint device coordinates
+  \param orientation Vertical or horizontal
+  \param inverted True, when the opposite scale 
+                  ( Qt::Vertical: x, Qt::Horizontal: y ) is increasing
+                  in the opposite direction as QPainter coordinates.
+  \param symbolWidth Width of the symbol in paint device coordinates
 */
 void QwtPlotTradingCurve::drawUserSymbol( QPainter *painter,
-    SymbolStyle symbolStyle, double symbolWidth,
-    const QwtOHLCSample &sample ) const
+    SymbolStyle symbolStyle, const QwtOHLCSample &sample,
+    Qt::Orientation orientation, bool inverted, double symbolWidth ) const
 {
     Q_UNUSED( painter )
     Q_UNUSED( symbolStyle )
+    Q_UNUSED( orientation )
+    Q_UNUSED( inverted )
     Q_UNUSED( symbolWidth )
     Q_UNUSED( sample )
 }
 
 /*!
+  \brief Draw a bar
+
+  \param painter Qt painter, initialized with pen/brush
+  \param sample Sample, already translated into paint device coordinates
+  \param orientation Vertical or horizontal
+  \param inverted When inverted is false the open tick is painted
+                  to the left/top, otherwise it is painted right/bottom.
+                  The close tick is painted in the opposite direction
+                  of the open tick.
+                  painted in the opposite d
+                  opposite direction.
+  \param width Width or height of the candle, depending on the orientation
+
+  \sa Bar
+*/
+void QwtPlotTradingCurve::drawBar( QPainter *painter,
+    const QwtOHLCSample &sample, Qt::Orientation orientation, 
+    bool inverted, double width ) const
+{
+    double w2 = 0.5 * width;
+    if ( inverted )
+        w2 *= -1;
+
+    if ( orientation == Qt::Vertical )
+    {
+        QwtPainter::drawLine( painter,
+            sample.time, sample.low, sample.time, sample.high );
+
+        QwtPainter::drawLine( painter,
+            sample.time - w2, sample.open, sample.time, sample.open );
+        QwtPainter::drawLine( painter,
+            sample.time + w2, sample.close, sample.time, sample.close );
+    }
+    else
+    {
+        QwtPainter::drawLine( painter, sample.low, sample.time,
+            sample.high, sample.time );
+        QwtPainter::drawLine( painter,
+            sample.open, sample.time - w2, sample.open, sample.time );
+        QwtPainter::drawLine( painter,
+            sample.close, sample.time + w2, sample.close, sample.time );
+    }
+}
+
+/*!
+  \brief Draw a candle stick
+
+  \param painter Qt painter, initialized with pen/brush
+  \param sample Samples already translated into paint device coordinates
+  \param orientation Vertical or horizontal
+  \param width Width or height of the candle, depending on the orientation
+
+  \sa CandleStick
+*/
+void QwtPlotTradingCurve::drawCandleStick( QPainter *painter,
+    const QwtOHLCSample &sample, Qt::Orientation orientation, 
+    double width ) const
+{
+    const double t = sample.time;
+    const double v1 = qMin( sample.low, sample.high );
+    const double v2 = qMin( sample.open, sample.close );
+    const double v3 = qMax( sample.low, sample.high );
+    const double v4 = qMax( sample.open, sample.close );
+
+    if ( orientation == Qt::Vertical )
+    {
+        QwtPainter::drawLine( painter, t, v1, t, v2 );
+        QwtPainter::drawLine( painter, t, v3, t, v4 );
+
+        QRectF rect( t - 0.5 * width, sample.open,
+            width, sample.close - sample.open );
+
+        QwtPainter::drawRect( painter, rect );
+    }
+    else
+    {
+        QwtPainter::drawLine( painter, v1, t, v2, t );
+        QwtPainter::drawLine( painter, v3, t, v4, t );
+
+        const QRectF rect( sample.open, t - 0.5 * width,
+            sample.close - sample.open, width );
+
+        QwtPainter::drawRect( painter, rect );
+    }
+}
+
+/*!
   \return A rectangle filled with the color of the symbol pen
 
   \param index Index of the legend entry 
@@ -513,16 +641,19 @@
 }
 
 /*!
-  \param Scale the symbol width into paint coordinates
+  Calculate the symbol width in paint coordinates
 
+  The width is calculated by scaling the symbol extent into
+  paint device coordinates bounded by the minimum/maximum
+  symbol width.
+
   \param xMap Maps x-values into pixel coordinates.
   \param yMap Maps y-values into pixel coordinates.
-  \param canvasRect Contents rect of the canvas
+  \param canvasRect Contents rectangle of the canvas
 
-  \return Scaled symbol width, or a a minimum of 2,
-          when it gets too small
+  \return Symbol width in paint coordinates
 
-  \sa setSymbolWidth()
+  \sa symbolExtent(), minSymbolWidth(), maxSymbolWidth()
 */
 double QwtPlotTradingCurve::scaledSymbolWidth(
     const QwtScaleMap &xMap, const QwtScaleMap &yMap,
@@ -530,13 +661,22 @@
 {
     Q_UNUSED( canvasRect );
 
+    if ( d_data->maxSymbolWidth > 0.0 &&
+        d_data->minSymbolWidth >= d_data->maxSymbolWidth )
+    {
+        return d_data->minSymbolWidth;
+    }
+
     const QwtScaleMap *map =
         ( orientation() == Qt::Vertical ) ? &xMap : &yMap;
 
-    double w = map->transform( d_data->symbolWidth ) - map->transform( 0.0 );
-    w = qAbs( w );
-    if ( w < 2.0 )
-        w = 2.0;
+    const double pos = map->transform( map->s1() + d_data->symbolExtent ); 
 
-    return qAbs( w );
+    double width = qAbs( pos - map->p1() );
+
+    width = qMax( width,  d_data->minSymbolWidth );
+    if ( d_data->maxSymbolWidth > 0.0 )
+        width = qMin( width, d_data->maxSymbolWidth );
+
+    return width;
 }
Index: qwt_double_range.h
===================================================================
--- qwt_double_range.h	(revision 382)
+++ qwt_double_range.h	(working copy)
@@ -1,78 +0,0 @@
-/* -*- mode: C++ ; c-file-style: "stroustrup" -*- *****************************
- * Qwt Widget Library
- * Copyright (C) 1997   Josef Wilgen
- * Copyright (C) 2002   Uwe Rathmann
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the Qwt License, Version 1.0
- *****************************************************************************/
-
-#ifndef QWT_DOUBLE_RANGE_H
-#define QWT_DOUBLE_RANGE_H
-
-#include "qwt_global.h"
-
-/*!
-  \brief A class which controls a value within an interval
-
-  This class is useful as a base class or a member for sliders.
-  It represents an interval of type double within which a value can
-  be moved. The value can be either an arbitrary point inside
-  the interval (see QwtDoubleRange::setValue), or it can be fitted
-  into a step raster (see QwtDoubleRange::fitValue and
-  QwtDoubleRange::incValue).
-
-  As a special case, a QwtDoubleRange can be periodic, which means that
-  a value outside the interval will be mapped to a value inside the
-  interval when QwtDoubleRange::setValue(), QwtDoubleRange::fitValue(),
-  QwtDoubleRange::incValue() or QwtDoubleRange::incPages() are called.
-*/
-
-class QWT_EXPORT QwtDoubleRange
-{
-public:
-    QwtDoubleRange();
-    virtual ~QwtDoubleRange();
-
-    void setRange( double vmin, double vmax, 
-        double vstep = 0.0, int pagesize = 1 );
-
-    void setValid( bool );
-    bool isValid() const;
-
-    virtual void setValue( double );
-    double value() const;
-
-    void setPeriodic( bool tf );
-    bool periodic() const;
-
-    void setStep( double );
-    double step() const;
-
-    double maxValue() const;
-    double minValue() const;
-
-    int pageSize() const;
-
-    virtual void incValue( int );
-    virtual void incPages( int );
-    virtual void fitValue( double );
-
-protected:
-
-    double exactValue() const;
-    double exactPrevValue() const;
-    double prevValue() const;
-
-    virtual void valueChange();
-    virtual void stepChange();
-    virtual void rangeChange();
-
-private:
-    void setNewValue( double value, bool align = false );
-
-    class PrivateData;
-    PrivateData *d_data;
-};
-
-#endif
Index: qwt_legend_label.cpp
===================================================================
--- qwt_legend_label.cpp	(revision 382)
+++ qwt_legend_label.cpp	(working copy)
@@ -55,6 +55,12 @@
     int spacing;
 };
 
+/*!
+  Set the attributes of the legend label
+
+  \param legendData Attributes of the label
+  \sa data()
+ */
 void QwtLegendLabel::setData( const QwtLegendData &legendData )
 {
     d_data->legendData = legendData;
@@ -75,6 +81,10 @@
     }
 }
 
+/*!
+  \return Attributes of the label
+  \sa setData(), QwtPlotItem::legendData()
+ */
 const QwtLegendData &QwtLegendLabel::data() const
 {
     return d_data->legendData;
@@ -138,8 +148,7 @@
 }
 
 /*!
-   Return the item mode
-
+   \return Item mode
    \sa setItemMode()
 */
 QwtLegendData::Mode QwtLegendLabel::itemMode() const
@@ -175,7 +184,8 @@
 }
 
 /*!
-   Change the spacing
+   \brief Change the spacing between icon and text
+
    \param spacing Spacing
    \sa spacing(), QwtTextLabel::margin()
 */
@@ -195,7 +205,7 @@
 }
 
 /*!
-   Return the spacing
+   \return Spacing between icon and text
    \sa setSpacing(), QwtTextLabel::margin()
 */
 int QwtLegendLabel::spacing() const
Index: CMakeLists.txt
===================================================================
--- CMakeLists.txt	(revision 382)
+++ CMakeLists.txt	(working copy)
@@ -8,12 +8,13 @@
                   qwt_plot_zoomer.h qwt_scale_widget.h qwt_slider.h
                   qwt_text_label.h qwt_thermo.h qwt_wheel.h
                   qwt_plot_renderer.h qwt_sampling_thread.h
-                  qwt_abstract_legend.h qwt_legend_label.h qwt_series_store.h)
+                  qwt_abstract_legend.h qwt_legend_label.h
+                  qwt_abstract_scale.h)
 
 set (HEADERS qwt.h qwt_dial_needle.h qwt_plot_magnifier.h
-             qwt_scale_div.h qwt_abstract_scale.h 
+             qwt_scale_div.h qwt_abstract_scale.h qwt_plot_abstract_barchart.h
              qwt_painter.h qwt_plot_marker.h qwt_scale_draw.h
-             qwt_abstract_scale_draw.h qwt_double_range.h qwt_panner.h
+             qwt_abstract_scale_draw.h qwt_panner.h
              qwt_plot_panner.h qwt_scale_engine.h qwt_abstract_slider.h
              qwt_picker.h qwt_plot_picker.h qwt_scale_map.h
              qwt_analog_clock.h qwt_dyngrid_layout.h qwt_picker_machine.h
@@ -37,15 +38,17 @@
              qwt_plot_spectrocurve.h qwt_system_clock.h qwt_compat.h
              qwt_abstract_legend.h qwt_graphic.h qwt_interval.h qwt_legend_data.h
              qwt_legend_label.h qwt_matrix_raster_data.h qwt_null_paintdevice.h
-             qwt_painter_command.h qwt_pixel_matrix.h qwt_plot_barchart.h qwt_plot_baritem.h
+             qwt_painter_command.h qwt_pixel_matrix.h qwt_plot_barchart.h
              qwt_plot_legenditem.h qwt_plot_multi_barchart.h qwt_plot_tradingcurve.h
              qwt_point_3d.h qwt_point_data.h qwt_point_mapper.h qwt_point_polar.h
-             qwt_samples.h qwt_series_store.h)
+             qwt_samples.h qwt_series_store.h qwt_date.h qwt_date_scale_engine.h
+             qwt_widget_overlay.h qwt_plot_zoneitem.h qwt_transform.h
+             qwt_plot_shapeitem.h qwt_date_scale_draw.h qwt_plot_textlabel.h)
 
 
-set (SOURCES qwt_abstract_scale.cpp qwt_double_range.cpp
+set (SOURCES qwt_abstract_scale.cpp qwt qwt_plot_abstract_barchart.cpp
              qwt_picker_machine.cpp qwt_plot_picker.cpp qwt_scale_engine.cpp
-             qwt_abstract_scale_draw.cpp qwt_plot.cpp
+             qwt_abstract_scale_draw.cpp qwt_plot.cpp qwt_widget_overlay.cpp
              qwt_scale_map.cpp qwt_abstract_slider.cpp
              qwt_dyngrid_layout.cpp qwt_plot_axis.cpp 
              qwt_scale_widget.cpp qwt_analog_clock.cpp qwt_event_pattern.cpp
@@ -53,7 +56,7 @@
              qwt_arrow_button.cpp qwt_interval_symbol.cpp qwt_plot_curve.cpp
              qwt_plot_rescaler.cpp qwt_slider.cpp qwt_clipper.cpp qwt_knob.cpp
              qwt_plot_dict.cpp qwt_plot_scaleitem.cpp qwt_spline.cpp
-             qwt_color_map.cpp 
+             qwt_color_map.cpp qwt_plot_shapeitem.cpp
              qwt_plot_directpainter.cpp qwt_plot_seriesitem.cpp qwt_symbol.cpp
              qwt_column_symbol.cpp qwt_legend.cpp qwt_plot_grid.cpp
              qwt_plot_spectrogram.cpp qwt_text.cpp qwt_compass.cpp
@@ -72,10 +75,14 @@
              qwt_graphic.cpp qwt_interval.cpp qwt_legend_data.cpp
              qwt_legend_label.cpp qwt_matrix_raster_data.cpp qwt_null_paintdevice.cpp
              qwt_painter_command.cpp qwt_pixel_matrix.cpp qwt_plot_barchart.cpp
-             qwt_plot_baritem.cpp qwt_plot_legenditem.cpp qwt_plot_multi_barchart.cpp
+             qwt_plot_legenditem.cpp qwt_plot_multi_barchart.cpp
              qwt_plot_tradingcurve.cpp qwt_point_3d.cpp qwt_point_data.cpp
-             qwt_point_mapper.cpp qwt_point_polar.cpp)
+             qwt_point_mapper.cpp qwt_point_polar.cpp qwt_plot_zoneitem.cpp
+             qwt_date_scale_draw.cpp qwt_date_scale_engine.cpp
+             qwt_transform.cpp qwt_date.cpp qwt_plot_textlabel.cpp)
 
+add_definitions (-DQWT_NO_OPENGL)
+
 add_shared_library(qwt
                    SOURCES ${HEADERS} ${SOURCES} ${MOC}
                    LIBRARIES ${QT_LIBRARIES}
Index: qwt_plot_item.h
===================================================================
--- qwt_plot_item.h	(revision 382)
+++ qwt_plot_item.h	(working copy)
@@ -16,6 +16,7 @@
 #include "qwt_graphic.h"
 #include <qrect.h>
 #include <qlist.h>
+#include <qmetatype.h>
 
 class QPainter;
 class QwtScaleMap;
@@ -49,7 +50,7 @@
     - ...
 
   Depending on the QwtPlotItem::ItemAttribute flags, an item is included
-  into autoscaling or has an entry on the legnd.
+  into autoscaling or has an entry on the legend.
 
   Before misusing the existing item classes it might be better to
   implement a new type of plot item
@@ -112,6 +113,16 @@
 
         //! For QwtPlotMultiBarChart
         Rtti_PlotMultiBarChart,
+
+        //! For QwtPlotShapeItem
+        Rtti_PlotShape,
+
+        //! For QwtPlotTextLabel
+        Rtti_PlotTextLabel,
+
+        //! For QwtPlotZoneItem
+        Rtti_PlotZone,
+
         /*! 
            Values >= Rtti_PlotUserItem are reserved for plot items
            not implemented in the Qwt library.
@@ -135,7 +146,8 @@
 
         /*!
            The boundingRect() of the item is included in the
-           autoscaling calculation.
+           autoscaling calculation as long as its width or height
+           is >= 0.0.
          */
         AutoScale = 0x02,
 
@@ -155,7 +167,7 @@
 
        Plot items might depend on the situation of the corresponding
        plot widget. By enabling an interest the plot item will be
-       notified, when the corrsponding attribute of the plot widgets
+       notified, when the corresponding attribute of the plot widgets
        has changed.
 
        \sa setItemAttribute(), testItemAttribute(), ItemInterest
@@ -188,24 +200,7 @@
     enum RenderHint
     {
         //! Enable antialiasing
-        RenderAntialiased = 0x1,
-
-        /*!
-          Certain painter operations are faster, when using integers
-          than floats ( f.e raster paint engine: drawPolyline() ) - even
-          if the corresponding paint engine doesn't support floats at all.
-          So a plot item might decide to transform coordinates into integers 
-          for these paint engines.
-
-          By setting RenderFloats this optimization can be suppressed.
-
-          \note For paint engines, that can use floats ( SVG, PDF ) this
-                flag has no effect, because these are rendered always
-                as floats.
-
-          \sa QwtPainter::roundingAlignment()
-         */
-        RenderFloats = 0x2
+        RenderAntialiased = 0x1
     };
 
     //! Render hints
@@ -234,6 +229,9 @@
     void setRenderHint( RenderHint, bool on = true );
     bool testRenderHint( RenderHint ) const;
 
+    void setRenderThreadCount( uint numThreads );
+    uint renderThreadCount() const;
+
     void setLegendIconSize( const QSize & );
     QSize legendIconSize() const;
 
@@ -304,4 +302,6 @@
 Q_DECLARE_OPERATORS_FOR_FLAGS( QwtPlotItem::ItemInterests )
 Q_DECLARE_OPERATORS_FOR_FLAGS( QwtPlotItem::RenderHints )
 
+Q_DECLARE_METATYPE( QwtPlotItem * )
+
 #endif
Index: qwt_wheel.cpp
===================================================================
--- qwt_wheel.cpp	(revision 382)
+++ qwt_wheel.cpp	(working copy)
@@ -16,42 +16,92 @@
 #include <qstyle.h>
 #include <qstyleoption.h>
 #include <qapplication.h>
+#include <qdatetime.h>
 
 #if QT_VERSION < 0x040601
+#define qFabs(x) ::fabs(x)
 #define qFastSin(x) ::sin(x)
+#define qExp(x) ::exp(x)
 #endif
 
 class QwtWheel::PrivateData
 {
 public:
-    PrivateData()
+    PrivateData():
+        orientation( Qt::Horizontal ),
+        viewAngle( 175.0 ),
+        totalAngle( 360.0 ),
+        tickCount( 10 ),
+        wheelBorderWidth( 2 ),
+        borderWidth( 2 ),
+        wheelWidth( 20 ),
+        isScrolling( false ),
+        mouseOffset( 0.0 ),
+        tracking( true ),
+        pendingValueChanged( false ),
+        updateInterval( 50 ),
+        mass( 0.0 ),
+        timerId( 0 ),
+        speed( 0.0 ),
+        mouseValue( 0.0 ),
+        flyingValue( 0.0 ),
+        minimum( 0.0 ),
+        maximum( 100.0 ),
+        singleStep( 1.0 ),
+        pageStepCount( 1 ),
+        stepAlignment( true ),
+        value( 0.0 ),
+        inverted( false ),
+        wrapping( false )
     {
-        viewAngle = 175.0;
-        totalAngle = 360.0;
-        tickCnt = 10;
-        wheelBorderWidth = 2;
-        borderWidth = 2;
-        wheelWidth = 20;
     };
 
+    Qt::Orientation orientation;
     double viewAngle;
     double totalAngle;
-    int tickCnt;
+    int tickCount;
     int wheelBorderWidth;
     int borderWidth;
     int wheelWidth;
+
+    bool isScrolling;
+    double mouseOffset;
+
+    bool tracking;
+    bool pendingValueChanged; // when not tracking
+
+    int updateInterval;
+    double mass;
+
+    // for the flying wheel effect
+    int timerId;
+    QTime time;
+    double speed;
+    double mouseValue;
+    double flyingValue;
+
+    double minimum;
+    double maximum;
+
+    double singleStep;
+    int pageStepCount;
+    bool stepAlignment;
+
+    double value;
+
+    bool inverted;
+    bool wrapping;
 };
 
 //! Constructor
 QwtWheel::QwtWheel( QWidget *parent ):
-    QwtAbstractSlider( Qt::Horizontal, parent )
+    QWidget( parent )
 {
     d_data = new PrivateData;
 
+    setFocusPolicy( Qt::StrongFocus );
     setSizePolicy( QSizePolicy::Preferred, QSizePolicy::Fixed );
-
     setAttribute( Qt::WA_WState_OwnSizePolicy, false );
-    setUpdateTime( 50 );
 }
 
 //! Destructor
@@ -61,39 +111,426 @@
 }
 
 /*!
+  \brief En/Disable tracking
+
+  If tracking is enabled (the default), the wheel emits the valueChanged() 
+  signal while the wheel is moving. If tracking is disabled, the wheel 
+  emits the valueChanged() signal only when the wheel movement is terminated.
+
+  The wheelMoved() signal is emitted regardless id tracking is enabled or not.
+
+  \param enable On/Off
+  \sa isTracking()
+ */
+void QwtWheel::setTracking( bool enable )
+{
+    d_data->tracking = enable;
+}
+
+/*!
+  \return True, when tracking is enabled
+  \sa setTracking(), valueChanged(), wheelMoved()
+*/
+bool QwtWheel::isTracking() const
+{
+    return d_data->tracking;
+}
+
+/*!
+  \brief Specify the update interval when the wheel is flying
+
+  Default and minimum value is 50 ms.
+
+  \param interval Interval in milliseconds
+  \sa updateInterval(), setMass(), setTracking()
+*/
+void QwtWheel::setUpdateInterval( int interval )
+{
+    d_data->updateInterval = qMax( interval, 50 );
+}
+
+/*!
+  \return Update interval when the wheel is flying
+  \sa setUpdateInterval(), mass(), isTracking()
+ */
+int QwtWheel::updateInterval() const
+{
+    return d_data->updateInterval;
+}
+
+/*!
+   \brief Mouse press event handler
+
+   Start movement of the wheel. 
+
+   \param event Mouse event
+*/
+void QwtWheel::mousePressEvent( QMouseEvent *event )
+{
+    stopFlying();
+
+    d_data->isScrolling = wheelRect().contains( event->pos() );
+
+    if ( d_data->isScrolling )
+    {
+        d_data->time.start();
+        d_data->speed = 0.0;
+        d_data->mouseValue = valueAt( event->pos() );
+        d_data->mouseOffset = d_data->mouseValue - d_data->value;
+        d_data->pendingValueChanged = false;
+
+        Q_EMIT wheelPressed();
+    }
+}
+
+/*!
+   \brief Mouse Move Event handler
+
+   Turn the wheel according to the mouse position
+
+   \param event Mouse event
+*/
+void QwtWheel::mouseMoveEvent( QMouseEvent *event )
+{
+    if ( !d_data->isScrolling )
+        return;
+
+    double mouseValue = valueAt( event->pos() );
+
+    if ( d_data->mass > 0.0 )
+    {
+        double ms = d_data->time.restart();
+
+        // the interval when mouse move events are posted are somehow
+        // random. To avoid unrealistic speed values we limit ms
+
+        ms = qMax( ms, 5.0 );
+
+        d_data->speed = ( mouseValue - d_data->mouseValue ) / ms;
+    }
+    
+    d_data->mouseValue = mouseValue; 
+
+    double value = boundedValue( mouseValue - d_data->mouseOffset );
+    if ( d_data->stepAlignment )
+        value = alignedValue( value );
+        
+    if ( value != d_data->value )
+    {
+        d_data->value = value;
+
+        update();
+
+        Q_EMIT wheelMoved( d_data->value );
+
+        if ( d_data->tracking )
+            Q_EMIT valueChanged( d_data->value );
+        else
+            d_data->pendingValueChanged = true;
+    }
+}
+
+/*!
+   \brief Mouse Release Event handler
+
+   When the wheel has no mass the movement of the wheel stops, otherwise
+   it starts flying.
+
+   \param event Mouse event
+*/  
+
+void QwtWheel::mouseReleaseEvent( QMouseEvent *event )
+{
+    Q_UNUSED( event );
+
+    if ( !d_data->isScrolling )
+        return;
+
+    d_data->isScrolling = false;
+
+    bool startFlying = false;
+
+    if ( d_data->mass > 0.0 )
+    {
+        const int ms = d_data->time.elapsed();
+        if ( ( qFabs( d_data->speed ) > 0.0 ) && ( ms < 50 ) )
+            startFlying = true;
+    }
+
+    if ( startFlying )
+    {
+        d_data->flyingValue = 
+            boundedValue( d_data->mouseValue - d_data->mouseOffset );
+
+        d_data->timerId = startTimer( d_data->updateInterval );
+    }
+    else
+    {
+        if ( d_data->pendingValueChanged )
+            Q_EMIT valueChanged( d_data->value );
+    }
+
+    d_data->pendingValueChanged = false;
+    d_data->mouseOffset = 0.0;
+
+    Q_EMIT wheelReleased();
+}
+
+/*!
+  \brief Qt timer event
+
+  The flying wheel effect is implemented using a timer
+   
+  \param event Timer event
+
+  \sa updateInterval()
+ */
+void QwtWheel::timerEvent( QTimerEvent *event )
+{
+    if ( event->timerId() != d_data->timerId )
+    {
+        QWidget::timerEvent( event );
+        return;
+    }
+
+    d_data->speed *= qExp( -d_data->updateInterval * 0.001 / d_data->mass );
+
+    d_data->flyingValue += d_data->speed * d_data->updateInterval;
+    d_data->flyingValue = boundedValue( d_data->flyingValue );
+
+    double value = d_data->flyingValue;
+    if ( d_data->stepAlignment )
+        value = alignedValue( value );
+
+    if ( qFabs( d_data->speed ) < 0.001 * d_data->singleStep )
+    {
+        // stop if d_data->speed < one step per second
+        stopFlying();
+    }
+
+    if ( value != d_data->value )
+    {
+        d_data->value = value;
+        update();
+
+        if ( d_data->tracking || d_data->timerId == 0 )
+            Q_EMIT valueChanged( d_data->value );
+    }
+}
+
+
+/*!
+  \brief Handle wheel events
+
+  In/Decrement the value 
+
+  \param event Wheel event
+*/
+void QwtWheel::wheelEvent( QWheelEvent *event )
+{
+    if ( !wheelRect().contains( event->pos() ) )
+    {
+        event->ignore();
+        return;
+    }
+
+    if ( d_data->isScrolling )
+        return;
+
+    stopFlying();
+
+    double increment = 0.0;
+
+    if ( ( event->modifiers() & Qt::ControlModifier) || 
+        ( event->modifiers() & Qt::ShiftModifier ) )
+    {
+        // one page regardless of delta
+        increment = d_data->singleStep * d_data->pageStepCount;
+        if ( event->delta() < 0 )
+            increment = -increment;
+    }
+    else
+    {
+        const int numSteps = event->delta() / 120;
+        increment = d_data->singleStep * numSteps;
+    }
+
+    if ( d_data->orientation == Qt::Vertical && d_data->inverted )
+        increment = -increment;
+
+    double value = boundedValue( d_data->value + increment );
+
+    if ( d_data->stepAlignment )
+        value = alignedValue( value );
+
+    if ( value != d_data->value )
+    {
+        d_data->value = value;
+        update();
+
+        Q_EMIT valueChanged( d_data->value );
+        Q_EMIT wheelMoved( d_data->value );
+    }
+}
+
+/*!
+  Handle key events
+
+  - Qt::Key_Home\n
+    Step to minimum()
+
+  - Qt::Key_End\n
+    Step to maximum()
+
+  - Qt::Key_Up\n
+    In case of a horizontal or not inverted vertical wheel the value 
+    will be incremented by the step size. For an inverted vertical wheel
+    the value will be decremented by the step size.
+
+  - Qt::Key_Down\n
+    In case of a horizontal or not inverted vertical wheel the value 
+    will be decremented by the step size. For an inverted vertical wheel
+    the value will be incremented by the step size.
+
+  - Qt::Key_PageUp\n
+    The value will be incremented by pageStepSize() * singleStepSize().
+
+  - Qt::Key_PageDown\n
+    The value will be decremented by pageStepSize() * singleStepSize().
+
+  \param event Key event
+*/
+void QwtWheel::keyPressEvent( QKeyEvent *event )
+{
+    if ( d_data->isScrolling )
+    {
+        // don't interfere mouse scrolling
+        return;
+    }
+
+    double value = d_data->value;
+    double increment = 0.0;
+
+    switch ( event->key() )
+    {
+        case Qt::Key_Down:
+        {
+            if ( d_data->orientation == Qt::Vertical && d_data->inverted )
+                increment = d_data->singleStep;
+            else
+                increment = -d_data->singleStep;
+
+            break;
+        }
+        case Qt::Key_Up:
+        {
+            if ( d_data->orientation == Qt::Vertical && d_data->inverted )
+                increment = -d_data->singleStep;
+            else
+                increment = d_data->singleStep;
+
+            break;
+        }
+        case Qt::Key_Left:
+        {
+            if ( d_data->orientation == Qt::Horizontal )
+            {
+                if ( d_data->inverted )
+                    increment = d_data->singleStep;
+                else
+                    increment = -d_data->singleStep;
+            }
+            break;
+        }
+        case Qt::Key_Right:
+        {
+            if ( d_data->orientation == Qt::Horizontal )
+            {
+                if ( d_data->inverted )
+                    increment = -d_data->singleStep;
+                else
+                    increment = d_data->singleStep;
+            }
+            break;
+        }
+        case Qt::Key_PageUp:
+        {
+            increment = d_data->pageStepCount * d_data->singleStep;
+            break;
+        }
+        case Qt::Key_PageDown:
+        {
+            increment = -d_data->pageStepCount * d_data->singleStep;
+            break;
+        }
+        case Qt::Key_Home:
+        {
+            value = d_data->minimum;
+            break;
+        }
+        case Qt::Key_End:
+        {
+            value = d_data->maximum;
+            break;
+        }
+        default:;
+        {
+            event->ignore();
+        }
+    }
+
+    if ( event->isAccepted() )
+        stopFlying();
+    
+    if ( increment != 0.0 )
+    {
+        value = boundedValue( d_data->value + increment );
+
+        if ( d_data->stepAlignment )
+            value = alignedValue( value );
+    }
+
+    if ( value != d_data->value )
+    {
+        d_data->value = value;
+        update();
+
+        Q_EMIT valueChanged( d_data->value );
+        Q_EMIT wheelMoved( d_data->value );
+    }
+}
+
+/*!
   \brief Adjust the number of grooves in the wheel's surface.
 
-  The number of grooves is limited to 6 <= cnt <= 50.
+  The number of grooves is limited to 6 <= count <= 50.
   Values outside this range will be clipped.
   The default value is 10.
 
-  \param cnt Number of grooves per 360 degrees
-  \sa tickCnt()
+  \param count Number of grooves per 360 degrees
+  \sa tickCount()
 */
-void QwtWheel::setTickCnt( int cnt )
+void QwtWheel::setTickCount( int count )
 {
-    d_data->tickCnt = qBound( 6, cnt, 50 );
-    update();
+    count = qBound( 6, count, 50 );
+
+    if ( count != d_data->tickCount )
+    {
+        d_data->tickCount = qBound( 6, count, 50 );
+        update();
+    }
 }
 
 /*!
   \return Number of grooves in the wheel's surface.
   \sa setTickCnt()
 */
-int QwtWheel::tickCnt() const
+int QwtWheel::tickCount() const
 {
-    return d_data->tickCnt;
+    return d_data->tickCount;
 }
 
 /*!
-    \return mass
-*/
-double QwtWheel::mass() const
-{
-    return QwtAbstractSlider::mass();
-}
-
-/*!
   \brief Set the wheel border width of the wheel.
 
   The wheel border must not be smaller than 1
@@ -187,14 +624,15 @@
 
 /*!
   \brief Set the wheel's orientation.
-  \param o Orientation. Allowed values are
-           Qt::Horizontal and Qt::Vertical.
-   Defaults to Qt::Horizontal.
-  \sa QwtAbstractSlider::orientation()
+
+  The default orientation is Qt::Horizontal.
+
+  \param orientation Qt::Horizontal or Qt::Vertical.
+  \sa orientation()
 */
-void QwtWheel::setOrientation( Qt::Orientation o )
+void QwtWheel::setOrientation( Qt::Orientation orientation )
 {
-    if ( orientation() == o )
+    if ( d_data->orientation == orientation )
         return;
 
     if ( !testAttribute( Qt::WA_WState_OwnSizePolicy ) )
@@ -206,11 +644,20 @@
         setAttribute( Qt::WA_WState_OwnSizePolicy, false );
     }
 
-    QwtAbstractSlider::setOrientation( o );
+    d_data->orientation = orientation;
     update();
 }
 
 /*!
+  \return Orientation
+  \sa setOrientation()
+*/
+Qt::Orientation QwtWheel::orientation() const
+{
+    return d_data->orientation;
+}
+
+/*!
   \brief Specify the visible portion of the wheel.
 
   You may use this function for fine-tuning the appearance of
@@ -235,51 +682,48 @@
     return d_data->viewAngle;
 }
 
-//! Determine the value corresponding to a specified point
-double QwtWheel::getValue( const QPoint &p )
+/*! 
+  Determine the value corresponding to a specified point
+
+  \param pos Position
+  \return Value corresponding to pos
+*/
+double QwtWheel::valueAt( const QPoint &pos ) const
 {
     const QRectF rect = wheelRect();
 
-    // The reference position is arbitrary, but the
-    // sign of the offset is important
     double w, dx;
-    if ( orientation() == Qt::Vertical )
+    if ( d_data->orientation == Qt::Vertical )
     {
         w = rect.height();
-        dx = rect.y() - p.y();
+        dx = rect.top() - pos.y();
     }
     else
     {
         w = rect.width();
-        dx = p.x() - rect.x();
+        dx = pos.x() - rect.left();
     }
 
     if ( w == 0.0 )
         return 0.0;
 
+    if ( d_data->inverted )
+    {
+        dx = w - dx;
+    }
+
     // w pixels is an arc of viewAngle degrees,
     // so we convert change in pixels to change in angle
     const double ang = dx * d_data->viewAngle / w;
 
     // value range maps to totalAngle degrees,
     // so convert the change in angle to a change in value
-    const double val = ang * ( maxValue() - minValue() ) / d_data->totalAngle;
+    const double val = ang * ( maximum() - minimum() ) / d_data->totalAngle;
 
-    // Note, range clamping and rasterizing to step is automatically
-    // handled by QwtAbstractSlider, so we simply return the change in value
     return val;
 }
 
 /*! 
-   \brief Qt Resize Event
-   \param event Resize event
-*/
-void QwtWheel::resizeEvent( QResizeEvent *event )
-{
-    QwtAbstractSlider::resizeEvent( event );
-}
-
-/*! 
    \brief Qt Paint Event
    \param event Paint event
 */
@@ -306,7 +750,7 @@
    Draw the Wheel's background gradient
 
    \param painter Painter
-   \param rect Rectangle for the wheel
+   \param rect Geometry for the wheel
 */
 void QwtWheel::drawWheelBackground( 
     QPainter *painter, const QRectF &rect )
@@ -317,9 +761,9 @@
 
     //  draw shaded background
     QLinearGradient gradient( rect.topLeft(), 
-        ( orientation() == Qt::Horizontal ) ? rect.topRight() : rect.bottomLeft() );
+        ( d_data->orientation == Qt::Horizontal ) ? rect.topRight() : rect.bottomLeft() );
     gradient.setColorAt( 0.0, pal.color( QPalette::Button ) );
-    gradient.setColorAt( 0.2, pal.color( QPalette::Light ) );
+    gradient.setColorAt( 0.2, pal.color( QPalette::Midlight ) );
     gradient.setColorAt( 0.7, pal.color( QPalette::Mid ) );
     gradient.setColorAt( 1.0, pal.color( QPalette::Dark ) );
 
@@ -334,7 +778,7 @@
 
     const double bw2 = 0.5 * d_data->wheelBorderWidth;
 
-    if ( orientation() == Qt::Horizontal )
+    if ( d_data->orientation == Qt::Horizontal )
     {
         painter->setPen( lightPen );
         painter->drawLine( QPointF( rect.left(), rect.top() + bw2 ), 
@@ -362,12 +806,13 @@
    Draw the Wheel's ticks
 
    \param painter Painter
-   \param rect Rectangle for the wheel
+   \param rect Geometry for the wheel
 */
 void QwtWheel::drawTicks( QPainter *painter, const QRectF &rect )
 {
-    if ( qFuzzyCompare( maxValue(), minValue() )
-        || qFuzzyCompare( d_data->totalAngle, 0.0 ) )
+    const double range = d_data->maximum - d_data->minimum;
+
+    if ( range == 0.0 || d_data->totalAngle == 0.0 )
     {
         return;
     }
@@ -377,17 +822,16 @@
     const QPen darkPen( palette().color( QPalette::Dark ), 
         0, Qt::SolidLine, Qt::FlatCap );
 
-    const double sign = ( minValue() < maxValue() ) ? 1.0 : -1.0;
-    const double cnvFactor = qAbs( d_data->totalAngle / ( maxValue() - minValue() ) );
+    const double cnvFactor = qAbs( d_data->totalAngle / range );
     const double halfIntv = 0.5 * d_data->viewAngle / cnvFactor;
     const double loValue = value() - halfIntv;
     const double hiValue = value() + halfIntv;
-    const double tickWidth = 360.0 / double( d_data->tickCnt ) / cnvFactor;
+    const double tickWidth = 360.0 / double( d_data->tickCount ) / cnvFactor;
     const double sinArc = qFastSin( d_data->viewAngle * M_PI / 360.0 );
 
-    if ( orientation() == Qt::Horizontal )
+    if ( d_data->orientation == Qt::Horizontal )
     {
-        const double halfSize = rect.width() * 0.5;
+        const double radius = rect.width() * 0.5;
 
         double l1 = rect.top() + d_data->wheelBorderWidth;
         double l2 = rect.bottom() - d_data->wheelBorderWidth - 1;
@@ -406,12 +850,17 @@
         for ( double tickValue = ::ceil( loValue / tickWidth ) * tickWidth;
             tickValue < hiValue; tickValue += tickWidth )
         {
-            const double angle = ( tickValue - value() ) * M_PI / 180.0;
+            const double angle = qwtRadians( tickValue - value() );
             const double s = qFastSin( angle * cnvFactor );
 
-            const double tickPos = 
-                rect.right() - halfSize * ( sinArc + sign * s ) / sinArc;
+            const double off = radius * ( sinArc + s ) / sinArc;
 
+            double tickPos;
+            if ( d_data->inverted ) 
+                tickPos = rect.left() + off;
+            else
+                tickPos = rect.right() - off;
+
             if ( ( tickPos <= maxpos ) && ( tickPos > minpos ) )
             {
                 painter->setPen( darkPen );
@@ -425,7 +874,7 @@
     }
     else // Qt::Vertical
     {
-        const double halfSize = rect.height() * 0.5;
+        const double radius = rect.height() * 0.5;
 
         double l1 = rect.left() + d_data->wheelBorderWidth;
         double l2 = rect.right() - d_data->wheelBorderWidth - 1;
@@ -442,12 +891,18 @@
         for ( double tickValue = ::ceil( loValue / tickWidth ) * tickWidth;
             tickValue < hiValue; tickValue += tickWidth )
         {
-            const double angle = ( tickValue - value() ) * M_PI / 180.0;
+            const double angle = qwtRadians( tickValue - value() );
             const double s = qFastSin( angle * cnvFactor );
 
-            const double tickPos = 
-                rect.y() + halfSize * ( sinArc + sign * s ) / sinArc;
+            const double off = radius * ( sinArc + s ) / sinArc;
 
+            double tickPos;
+
+            if ( d_data->inverted )
+                tickPos = rect.bottom() - off;
+            else
+                tickPos = rect.top() + off;
+
             if ( ( tickPos <= maxpos ) && ( tickPos > minpos ) )
             {
                 painter->setPen( darkPen );
@@ -461,43 +916,7 @@
     }
 }
 
-//! Notify value change
-void QwtWheel::valueChange()
-{
-    QwtAbstractSlider::valueChange();
-    update();
-}
-
 /*!
-  \brief Determine the scrolling mode and direction corresponding
-         to a specified point
-  \param p point
-  \param scrollMode scrolling mode
-  \param direction direction
-*/
-void QwtWheel::getScrollMode( const QPoint &p, 
-    QwtAbstractSlider::ScrollMode &scrollMode, int &direction ) const
-{
-    if ( wheelRect().contains( p ) )
-        scrollMode = QwtAbstractSlider::ScrMouse;
-    else
-        scrollMode = QwtAbstractSlider::ScrNone;
-
-    direction = 0;
-}
-
-/*!
-  \brief Set the mass of the wheel
-
-  Assigning a mass turns the wheel into a flywheel.
-  \param mass The wheel's mass
-*/
-void QwtWheel::setMass( double mass )
-{
-    QwtAbstractSlider::setMass( mass );
-}
-
-/*!
   \brief Set the width of the wheel
 
   Corresponds to the wheel height for horizontal orientation,
@@ -531,15 +950,344 @@
 }
 
 /*!
-  \brief Return a minimum size hint
+  \return Minimum size hint
   \warning The return value is based on the wheel width.
 */
 QSize QwtWheel::minimumSizeHint() const
 {
     QSize sz( 3 * d_data->wheelWidth + 2 * d_data->borderWidth,
         d_data->wheelWidth + 2 * d_data->borderWidth );
-    if ( orientation() != Qt::Horizontal )
+    if ( d_data->orientation != Qt::Horizontal )
         sz.transpose();
 
     return sz;
 }
+
+/*!
+  \brief Set the step size of the counter
+
+  A value <= 0.0 disables stepping
+
+  \param stepSize Single step size
+  \sa singleStep(), setPageStepCount()
+*/
+void QwtWheel::setSingleStep( double stepSize )
+{
+    d_data->singleStep = qMax( stepSize, 0.0 );
+}
+
+/*!
+  \return Single step size
+  \sa setSingleStep()
+ */
+double QwtWheel::singleStep() const
+{
+    return d_data->singleStep;
+}
+
+/*!
+  \brief En/Disable step alignment
+
+  When step alignment is enabled value changes initiated by
+  user input ( mouse, keyboard, wheel ) are aligned to
+  the multiples of the single step.
+
+  \param on On/Off
+  \sa stepAlignment(), setSingleStep()
+ */
+void QwtWheel::setStepAlignment( bool on )
+{
+    if ( on != d_data->stepAlignment )
+    {
+        d_data->stepAlignment = on;
+    }
+}
+
+/*!
+  \return True, when the step alignment is enabled
+  \sa setStepAlignment(), singleStep()
+ */
+bool QwtWheel::stepAlignment() const
+{
+    return d_data->stepAlignment;
+}
+
+/*!
+  \brief Set the page step count  
+    
+  pageStepCount is a multiplicator for the single step size
+  that typically corresponds to the user pressing PageUp or PageDown.
+    
+  A value of 0 disables page stepping. 
+
+  The default value is 1.
+
+  \param count Multiplicator for the single step size
+  \sa pageStepCount(), setSingleStep()
+ */
+void QwtWheel::setPageStepCount( int count )
+{
+    d_data->pageStepCount = qMax( 0, count );
+}
+
+/*! 
+  \return Page step count
+  \sa setPageStepCount(), singleStep()
+ */
+int QwtWheel::pageStepCount() const
+{
+    return d_data->pageStepCount;
+}
+
+/*!
+  \brief Set the minimum and maximum values
+
+  The maximum is adjusted if necessary to ensure that the range remains valid.
+  The value might be modified to be inside of the range.
+
+  \param min Minimum value
+  \param max Maximum value
+
+  \sa minimum(), maximum()
+ */
+void QwtWheel::setRange( double min, double max )
+{
+    max = qMax( min, max );
+
+    if ( d_data->minimum == min && d_data->maximum == max )
+        return;
+
+    d_data->minimum = min;
+    d_data->maximum = max;
+
+    if ( d_data->value < min || d_data->value > max )
+    {
+        d_data->value = qBound( min, d_data->value, max );
+
+        update();
+        Q_EMIT valueChanged( d_data->value );
+    }
+}
+/*!
+  Set the minimum value of the range
+
+  \param value Minimum value
+  \sa setRange(), setMaximum(), minimum()
+
+  \note The maximum is adjusted if necessary to ensure that the range remains valid.
+*/
+void QwtWheel::setMinimum( double value )
+{
+    setRange( value, maximum() );
+}
+
+/*!
+  \return The minimum of the range
+  \sa setRange(), setMinimum(), maximum()
+*/
+double QwtWheel::minimum() const
+{
+    return d_data->minimum;
+}
+
+/*!
+  Set the maximum value of the range
+
+  \param value Maximum value
+  \sa setRange(), setMinimum(), maximum()
+*/
+void QwtWheel::setMaximum( double value )
+{
+    setRange( minimum(), value );
+}
+
+/*!
+  \return The maximum of the range
+  \sa setRange(), setMaximum(), minimum()
+*/
+double QwtWheel::maximum() const
+{
+    return d_data->maximum;
+}
+
+/*!
+  \brief Set a new value without adjusting to the step raster
+
+  \param value New value
+
+  \sa value(), valueChanged()
+  \warning The value is clipped when it lies outside the range.
+*/
+void QwtWheel::setValue( double value )
+{
+    stopFlying();
+    d_data->isScrolling = false;
+
+    value = qBound( d_data->minimum, value, d_data->maximum );
+
+    if ( d_data->value != value )
+    {
+        d_data->value = value;
+
+        update();
+        Q_EMIT valueChanged( d_data->value );
+    }
+}
+
+/*!
+  \return Current value of the wheel
+  \sa setValue(), valueChanged()
+ */
+double QwtWheel::value() const
+{
+    return d_data->value;
+}
+
+/*!
+  \brief En/Disable inverted appearance
+
+  An inverted wheel increases its values in the opposite direction.
+  The direction of an inverted horizontal wheel will be from right to left
+  an inverted vertical wheel will increase from bottom to top.
+  
+  \param on En/Disable inverted appearance
+  \sa isInverted()
+ 
+ */
+void QwtWheel::setInverted( bool on )
+{
+    if ( d_data->inverted != on )
+    {
+        d_data->inverted = on;
+        update();
+    }
+}
+
+/*!
+  \return True, when the wheel is inverted
+  \sa setInverted()
+ */
+bool QwtWheel::isInverted() const
+{
+    return d_data->inverted;
+}
+
+/*!
+  \brief En/Disable wrapping
+
+  If wrapping is true stepping up from maximum() value will take 
+  you to the minimum() value and vice versa. 
+
+  \param on En/Disable wrapping
+  \sa wrapping()
+ */
+void QwtWheel::setWrapping( bool on )
+{
+    d_data->wrapping = on;
+}
+
+/*!
+  \return True, when wrapping is set
+  \sa setWrapping()
+ */
+bool QwtWheel::wrapping() const
+{
+    return d_data->wrapping;
+}
+
+/*!
+  \brief Set the slider's mass for flywheel effect.
+
+  If the slider's mass is greater then 0, it will continue
+  to move after the mouse button has been released. Its speed
+  decreases with time at a rate depending on the slider's mass.
+  A large mass means that it will continue to move for a
+  long time.
+
+  Derived widgets may overload this function to make it public.
+
+  \param mass New mass in kg
+
+  \bug If the mass is smaller than 1g, it is set to zero.
+       The maximal mass is limited to 100kg.
+  \sa mass()
+*/
+void QwtWheel::setMass( double mass )
+{
+    if ( mass < 0.001 )
+    {
+        d_data->mass = 0.0;
+    }
+    else
+    {
+        d_data->mass = qMin( 100.0, mass );
+    }
+
+    if ( d_data->mass <= 0.0 )
+        stopFlying();
+}
+
+/*!
+  \return mass
+  \sa setMass()
+*/
+double QwtWheel::mass() const
+{
+    return d_data->mass;
+}
+
+//!  Stop the flying movement of the wheel
+void QwtWheel::stopFlying()
+{
+    if ( d_data->timerId != 0 )
+    {
+        killTimer( d_data->timerId );
+        d_data->timerId = 0;
+        d_data->speed = 0.0;
+    }
+}
+
+double QwtWheel::boundedValue( double value ) const
+{
+    const double range = d_data->maximum - d_data->minimum;
+    
+    if ( d_data->wrapping && range >= 0.0 )
+    {
+        if ( value < d_data->minimum )
+        {
+            value += ::ceil( ( d_data->minimum - value ) / range ) * range;
+        }       
+        else if ( value > d_data->maximum )
+        {
+            value -= ::ceil( ( value - d_data->maximum ) / range ) * range;
+        }
+    }
+    else
+    {
+        value = qBound( d_data->minimum, value, d_data->maximum );
+    }
+
+    return value;
+}
+
+double QwtWheel::alignedValue( double value ) const
+{
+    const double stepSize = d_data->singleStep;
+
+    if ( stepSize > 0.0 )
+    {
+        value = d_data->minimum +
+            qRound( ( value - d_data->minimum ) / stepSize ) * stepSize;
+
+        // correct rounding error at the border
+        if ( qFuzzyCompare( value, d_data->maximum ) )
+            value = d_data->maximum;
+            
+        // correct rounding error if value = 0
+        if ( qFuzzyCompare( value + 1.0, 1.0 ) )
+            value = 0.0;
+    }       
+
+    return value;
+}
+
Index: qwt_plot_renderer.cpp
===================================================================
--- qwt_plot_renderer.cpp	(revision 382)
+++ qwt_plot_renderer.cpp	(working copy)
@@ -10,7 +10,6 @@
 #include "qwt_plot_renderer.h"
 #include "qwt_plot.h"
 #include "qwt_painter.h"
-#include "qwt_plot_canvas.h"
 #include "qwt_plot_layout.h"
 #include "qwt_abstract_legend.h"
 #include "qwt_scale_widget.h"
@@ -34,11 +33,35 @@
 #endif
 #endif
 
+static QPainterPath qwtCanvasClip( 
+    const QWidget* canvas, const QRectF &canvasRect )
+{
+    // The clip region is calculated in integers
+    // To avoid too much rounding errors better
+    // calculate it in target device resolution
+
+    int x1 = qCeil( canvasRect.left() );
+    int x2 = qFloor( canvasRect.right() );
+    int y1 = qCeil( canvasRect.top() );
+    int y2 = qFloor( canvasRect.bottom() );
+
+    const QRect r( x1, y1, x2 - x1 - 1, y2 - y1 - 1 );
+
+    QPainterPath clipPath;
+
+    ( void ) QMetaObject::invokeMethod(
+        const_cast< QWidget *>( canvas ), "borderPath",
+        Qt::DirectConnection,
+        Q_RETURN_ARG( QPainterPath, clipPath ), Q_ARG( QRect, r ) );
+
+    return clipPath;
+}
+
 class QwtPlotRenderer::PrivateData
 {
 public:
     PrivateData():
-        discardFlags( QwtPlotRenderer::DiscardBackground ),
+        discardFlags( QwtPlotRenderer::DiscardNone ),
         layoutFlags( QwtPlotRenderer::DefaultLayout )
     {
     }
@@ -47,27 +70,6 @@
     QwtPlotRenderer::LayoutFlags layoutFlags;
 };
 
-static void qwtRenderBackground( QPainter *painter,
-    const QRectF &rect, const QWidget *widget )
-{
-    if ( widget->testAttribute( Qt::WA_StyledBackground ) )
-    {
-        QStyleOption opt;
-        opt.initFrom( widget );
-        opt.rect = rect.toAlignedRect();
-
-        widget->style()->drawPrimitive(
-            QStyle::PE_Widget, &opt, painter, widget);
-    }
-    else
-    {
-        const QBrush brush = 
-            widget->palette().brush( widget->backgroundRole() );
-
-        painter->fillRect( rect, brush );
-    }
-}
-
 /*! 
    Constructor
    \param parent Parent object
@@ -101,8 +103,7 @@
 }
 
 /*!
-  Check if a flag is set.
-
+  \return True, if flag is enabled.
   \param flag Flag to be tested
   \sa DiscardFlag, setDiscardFlag(), setDiscardFlags(), discardFlags()
 */
@@ -148,8 +149,7 @@
 }
 
 /*!
-  Check if a flag is set.
-
+  \return True, if flag is enabled.
   \param flag Flag to be tested
   \sa LayoutFlag, setLayoutFlag(), setLayoutFlags(), layoutFlags()
 */
@@ -181,8 +181,8 @@
 /*!
   Render a plot to a file
 
-  The format of the document will be autodetected from the
-  suffix of the filename.
+  The format of the document will be auto-detected from the
+  suffix of the file name.
 
   \param plot Plot widget
   \param fileName Path of the file, where the document will be stored
@@ -238,22 +238,40 @@
     const QRectF documentRect( 0.0, 0.0, size.width(), size.height() );
 
     const QString fmt = format.toLower();
-    if ( fmt == "pdf" || fmt == "ps" )
+    if ( fmt == "pdf" )
     {
 #ifndef QT_NO_PRINTER
         QPrinter printer;
+        printer.setColorMode( QPrinter::Color );
         printer.setFullPage( true );
         printer.setPaperSize( sizeMM, QPrinter::Millimeter );
         printer.setDocName( title );
         printer.setOutputFileName( fileName );
-        printer.setOutputFormat( ( format == "pdf" )
-            ? QPrinter::PdfFormat : QPrinter::PostScriptFormat );
+        printer.setOutputFormat( QPrinter::PdfFormat );
         printer.setResolution( resolution );
 
         QPainter painter( &printer );
         render( plot, &painter, documentRect );
 #endif
     }
+    else if ( fmt == "ps" )
+    {
+#if QT_VERSION < 0x050000
+#ifndef QT_NO_PRINTER
+        QPrinter printer;
+        printer.setColorMode( QPrinter::Color );
+        printer.setFullPage( true );
+        printer.setPaperSize( sizeMM, QPrinter::Millimeter );
+        printer.setDocName( title );
+        printer.setOutputFileName( fileName );
+        printer.setOutputFormat( QPrinter::PostScriptFormat );
+        printer.setResolution( resolution );
+
+        QPainter painter( &printer );
+        render( plot, &painter, documentRect );
+#endif
+#endif
+    }
     else if ( fmt == "svg" )
     {
 #ifndef QWT_NO_SVG
@@ -394,10 +412,12 @@
 {
     if ( painter == 0 || !painter->isActive() ||
             !plotRect.isValid() || plot->size().isNull() )
+    {
         return;
+    }
 
     if ( !( d_data->discardFlags & DiscardBackground ) )
-        qwtRenderBackground( painter, plotRect, plot );
+        QwtPainter::drawBackgound( painter, plotRect, plot );
 
     /*
       The layout engine uses the same methods as they are used
@@ -411,6 +431,15 @@
 
     QRectF layoutRect = transform.inverted().mapRect( plotRect );
 
+    if ( !( d_data->discardFlags & DiscardBackground ) )
+    {
+        // subtract the contents margins
+
+        int left, top, right, bottom;
+        plot->getContentsMargins( &left, &top, &right, &bottom );
+        layoutRect.adjust( left, top, -right, -bottom );
+    }
+
     QwtPlotLayout *layout = plot->plotLayout();
 
     int baseLineDists[QwtPlot::axisCnt];
@@ -464,9 +493,15 @@
 
     // Calculate the layout for the document.
 
-    QwtPlotLayout::Options layoutOptions = 
-        QwtPlotLayout::IgnoreScrollbars | QwtPlotLayout::IgnoreFrames;
+    QwtPlotLayout::Options layoutOptions = QwtPlotLayout::IgnoreScrollbars;
 
+    if ( ( d_data->layoutFlags & FrameWithScales ) ||
+        ( d_data->discardFlags & DiscardCanvasFrame ) )
+    {
+        layoutOptions |= QwtPlotLayout::IgnoreFrames;
+    } 
+
+
     if ( d_data->discardFlags & DiscardLegend )
         layoutOptions |= QwtPlotLayout::IgnoreLegend;
 
@@ -631,12 +666,7 @@
         && scaleWidget->colorBarWidth() > 0 )
     {
         scaleWidget->drawColorBar( painter, scaleWidget->colorBarRect( rect ) );
-
-        const int off = scaleWidget->colorBarWidth() + scaleWidget->spacing();
-        if ( scaleWidget->scaleDraw()->orientation() == Qt::Horizontal )
-            baseDist += off;
-        else
-            baseDist += off;
+        baseDist += scaleWidget->colorBarWidth() + scaleWidget->spacing();
     }
 
     painter->save();
@@ -716,62 +746,127 @@
     QPainter *painter, const QRectF &canvasRect, 
     const QwtScaleMap *map ) const
 {
-    painter->save();
+    const QWidget *canvas = plot->canvas();
 
-    QPainterPath clipPath;
-
     QRectF r = canvasRect.adjusted( 0.0, 0.0, -1.0, -1.0 );
 
     if ( d_data->layoutFlags & FrameWithScales )
     {
+        painter->save();
+
         r.adjust( -1.0, -1.0, 1.0, 1.0 );
         painter->setPen( QPen( Qt::black ) );
 
         if ( !( d_data->discardFlags & DiscardCanvasBackground ) )
         {
             const QBrush bgBrush =
-                plot->canvas()->palette().brush( plot->backgroundRole() );
+                canvas->palette().brush( plot->backgroundRole() );
             painter->setBrush( bgBrush );
         }
 
         QwtPainter::drawRect( painter, r );
+
+        painter->restore();
+        painter->save();
+
+        painter->setClipRect( canvasRect );
+        plot->drawItems( painter, canvasRect, map );
+
+        painter->restore();
     }
-    else
+    else if ( canvas->testAttribute( Qt::WA_StyledBackground ) )
     {
+        QPainterPath clipPath;
+
+        painter->save();
+
         if ( !( d_data->discardFlags & DiscardCanvasBackground ) )
         {
-            qwtRenderBackground( painter, r, plot->canvas() );
+            QwtPainter::drawBackgound( painter, r, canvas );
+            clipPath = qwtCanvasClip( canvas, canvasRect );
+        }
 
-            if ( plot->canvas()->testAttribute( Qt::WA_StyledBackground ) )
-            {
-                // The clip region is calculated in integers
-                // To avoid too much rounding errors better
-                // calculate it in target device resolution
-                // TODO ...
+        painter->restore();
+        painter->save();
 
-                int x1 = qCeil( canvasRect.left() );
-                int x2 = qFloor( canvasRect.right() );
-                int y1 = qCeil( canvasRect.top() );
-                int y2 = qFloor( canvasRect.bottom() );
+        if ( clipPath.isEmpty() )
+            painter->setClipRect( canvasRect );
+        else
+            painter->setClipPath( clipPath );
 
-                clipPath = plot->canvas()->borderPath( 
-                    QRect( x1, y1, x2 - x1 - 1, y2 - y1 - 1 ) );
-            }
-        }
+        plot->drawItems( painter, canvasRect, map );
+
+        painter->restore();
     }
+    else
+    {
+        QPainterPath clipPath;
 
-    painter->restore();
+        int frameWidth = 0;
 
-    painter->save();
+        if ( !( d_data->discardFlags & DiscardCanvasFrame ) )
+        {
+            const QVariant fw = canvas->property( "frameWidth" );
+            if ( fw.type() == QVariant::Int )
+                frameWidth = fw.toInt();
 
-    if ( clipPath.isEmpty() )
-        painter->setClipRect( canvasRect );
-    else
-        painter->setClipPath( clipPath );
+            clipPath = qwtCanvasClip( canvas, canvasRect );
+        }
 
-    plot->drawItems( painter, canvasRect, map );
+        QRectF innerRect = canvasRect.adjusted( 
+            frameWidth, frameWidth, -frameWidth, -frameWidth );
 
-    painter->restore();
+        painter->save();
+
+        if ( clipPath.isEmpty() )
+        {
+            painter->setClipRect( innerRect );
+        }
+        else
+        {
+            painter->setClipPath( clipPath );
+        }
+
+        if ( !( d_data->discardFlags & DiscardCanvasBackground ) )
+        {
+            QwtPainter::drawBackgound( painter, innerRect, canvas );
+        }
+
+        plot->drawItems( painter, innerRect, map );
+
+        painter->restore();
+
+        if ( frameWidth > 0 )
+        {
+            painter->save();
+
+            const int frameStyle =
+                canvas->property( "frameShadow" ).toInt() |
+                canvas->property( "frameShape" ).toInt();
+
+            const int frameWidth = canvas->property( "frameWidth" ).toInt();
+
+
+            const QVariant borderRadius = canvas->property( "borderRadius" );
+            if ( borderRadius.type() == QVariant::Double 
+                && borderRadius.toDouble() > 0.0 )
+            {
+                const double r = borderRadius.toDouble();
+
+                QwtPainter::drawRoundedFrame( painter, canvasRect,
+                    r, r, canvas->palette(), frameWidth, frameStyle );
+            }
+            else
+            {
+                const int midLineWidth = canvas->property( "midLineWidth" ).toInt();
+
+                QwtPainter::drawFrame( painter, canvasRect,
+                    canvas->palette(), canvas->foregroundRole(),
+                    frameWidth, midLineWidth, frameStyle );
+            }
+            painter->restore();
+        }
+    }
 }
 
 /*!
@@ -798,7 +893,7 @@
         {
             const int sDist = plot->axisWidget( axisId )->startBorderDist();
             const int eDist = plot->axisWidget( axisId )->endBorderDist();
-            const QRectF &scaleRect = plot->plotLayout()->scaleRect( axisId );
+            const QRectF scaleRect = plot->plotLayout()->scaleRect( axisId );
 
             if ( axisId == QwtPlot::xTop || axisId == QwtPlot::xBottom )
             {
@@ -813,7 +908,10 @@
         }
         else
         {
-            int margin = plot->plotLayout()->canvasMargin( axisId );
+            int margin = 0;
+            if ( !plot->plotLayout()->alignCanvasToScale( axisId ) )
+                margin = plot->plotLayout()->canvasMargin( axisId );
+
             if ( axisId == QwtPlot::yLeft || axisId == QwtPlot::yRight )
             {
                 from = canvasRect.bottom() - margin;
@@ -854,17 +952,16 @@
 /*!
    \brief Execute a file dialog and render the plot to the selected file
 
-   The document will be rendered in 85dpi for a size 30x20cm
-
    \param plot Plot widget
    \param documentName Default document name
+   \param sizeMM Size for the document in millimeters.
+   \param resolution Resolution in dots per Inch (dpi)
 
-   \note exportTo() is handy for testing, but usually an application
-         wants to configure the export individually 
-         using renderDocument() or even more low level methods
-         of QwtPlotRenderer.
+   \return True, when exporting was successful
+   \sa renderDocument()
 */
-bool QwtPlotRenderer::exportTo( QwtPlot *plot, const QString &documentName )
+bool QwtPlotRenderer::exportTo( QwtPlot *plot, const QString &documentName,
+     const QSizeF &sizeMM, int resolution )
 {       
     if ( plot == NULL )
         return false;
@@ -911,7 +1008,7 @@
     if ( fileName.isEmpty() )
         return false;
 
-    renderDocument( plot, fileName, QSizeF( 300, 200 ), 85 );
+    renderDocument( plot, fileName, sizeMM, resolution );
 
     return true;
 }   
Index: qwt_compass.cpp
===================================================================
--- qwt_compass.cpp	(revision 382)
+++ qwt_compass.cpp	(working copy)
@@ -17,6 +17,102 @@
 #include <qpixmap.h>
 #include <qevent.h>
 
+/*! 
+  \brief Constructor
+
+  Initializes a label map for multiples of 45 degrees
+ */
+QwtCompassScaleDraw::QwtCompassScaleDraw()
+{
+    enableComponent( QwtAbstractScaleDraw::Backbone, false );
+    enableComponent( QwtAbstractScaleDraw::Ticks, false );
+
+    d_labelMap.insert( 0.0, QString::fromLatin1( "N" ) );
+    d_labelMap.insert( 45.0, QString::fromLatin1( "NE" ) );
+    d_labelMap.insert( 90.0, QString::fromLatin1( "E" ) );
+    d_labelMap.insert( 135.0, QString::fromLatin1( "SE" ) );
+    d_labelMap.insert( 180.0, QString::fromLatin1( "S" ) );
+    d_labelMap.insert( 225.0, QString::fromLatin1( "SW" ) );
+    d_labelMap.insert( 270.0, QString::fromLatin1( "W" ) );
+    d_labelMap.insert( 315.0, QString::fromLatin1( "NW" ) );
+
+#if 0
+    d_labelMap.insert( 22.5, QString::fromLatin1( "NNE" ) );
+    d_labelMap.insert( 67.5, QString::fromLatin1( "NEE" ) );
+    d_labelMap.insert( 112.5, QString::fromLatin1( "SEE" ) );
+    d_labelMap.insert( 157.5, QString::fromLatin1( "SSE" ) );
+    d_labelMap.insert( 202.5, QString::fromLatin1( "SSW" ) );
+    d_labelMap.insert( 247.5, QString::fromLatin1( "SWW" ) );
+    d_labelMap.insert( 292.5, QString::fromLatin1( "NWW" ) );
+    d_labelMap.insert( 337.5, QString::fromLatin1( "NNW" ) );
+#endif
+}
+
+/*! 
+  \brief Constructor
+
+  \param map Value to label map
+ */
+QwtCompassScaleDraw::QwtCompassScaleDraw( const QMap<double, QString> &map ):
+    d_labelMap( map )
+{
+    enableComponent( QwtAbstractScaleDraw::Backbone, false );
+    enableComponent( QwtAbstractScaleDraw::Ticks, false );
+}
+
+/*!
+  \brief Set a map, mapping values to labels
+  \param map Value to label map
+
+  The values of the major ticks are found by looking into this
+  map. The default map consists of the labels N, NE, E, SE, S, SW, W, NW.
+
+  \warning The map will have no effect for values that are no major
+           tick values. Major ticks can be changed by QwtScaleDraw::setScale
+
+  \sa labelMap(), scaleDraw(), setScale()
+*/
+void QwtCompassScaleDraw::setLabelMap( const QMap<double, QString> &map )
+{
+    d_labelMap = map;
+}
+
+
+/*!
+  \return map, mapping values to labels
+  \sa setLabelMap()
+*/
+QMap<double, QString> QwtCompassScaleDraw::labelMap() const
+{
+    return d_labelMap;
+}
+
+/*!
+  Map a value to a corresponding label
+
+  \param value Value that will be mapped
+
+  label() looks in the labelMap() for a corresponding label for value
+  or returns an null text.
+
+  \return Label, or QString::null
+  \sa labelMap(), setLabelMap()
+*/
+
+QwtText QwtCompassScaleDraw::label( double value ) const
+{
+    if ( qFuzzyCompare( value + 1.0, 1.0 ) )
+        value = 0.0;
+
+    if ( value < 0.0 )
+        value += 360.0;
+
+    if ( d_labelMap.contains( value ) )
+        return d_labelMap[value];
+
+    return QwtText();
+}
+
 class QwtCompass::PrivateData
 {
 public:
@@ -31,7 +127,6 @@
     }
 
     QwtCompassRose *rose;
-    QMap<double, QString> labelMap;
 };
 
 /*!
@@ -46,47 +141,27 @@
 QwtCompass::QwtCompass( QWidget* parent ):
     QwtDial( parent )
 {
-    initCompass();
-}
-
-//!  Destructor
-QwtCompass::~QwtCompass()
-{
-    delete d_data;
-}
-
-void QwtCompass::initCompass()
-{
     d_data = new PrivateData;
 
-    // Only labels, no backbone, no ticks
-    setScaleComponents( QwtAbstractScaleDraw::Labels ); 
+    setScaleDraw( new QwtCompassScaleDraw() );
 
     setOrigin( 270.0 );
     setWrapping( true );
 
+    setScaleMaxMajor( 36 );
+    setScaleMaxMinor( 10 );
 
-    d_data->labelMap.insert( 0.0, QString::fromLatin1( "N" ) );
-    d_data->labelMap.insert( 45.0, QString::fromLatin1( "NE" ) );
-    d_data->labelMap.insert( 90.0, QString::fromLatin1( "E" ) );
-    d_data->labelMap.insert( 135.0, QString::fromLatin1( "SE" ) );
-    d_data->labelMap.insert( 180.0, QString::fromLatin1( "S" ) );
-    d_data->labelMap.insert( 225.0, QString::fromLatin1( "SW" ) );
-    d_data->labelMap.insert( 270.0, QString::fromLatin1( "W" ) );
-    d_data->labelMap.insert( 315.0, QString::fromLatin1( "NW" ) );
+    setScale( 0.0, 360.0 ); // degrees as default
+    setTotalSteps( 360 );
+}
 
-#if 0
-    d_data->labelMap.insert( 22.5, QString::fromLatin1( "NNE" ) );
-    d_data->labelMap.insert( 67.5, QString::fromLatin1( "NEE" ) );
-    d_data->labelMap.insert( 112.5, QString::fromLatin1( "SEE" ) );
-    d_data->labelMap.insert( 157.5, QString::fromLatin1( "SSE" ) );
-    d_data->labelMap.insert( 202.5, QString::fromLatin1( "SSW" ) );
-    d_data->labelMap.insert( 247.5, QString::fromLatin1( "SWW" ) );
-    d_data->labelMap.insert( 292.5, QString::fromLatin1( "NWW" ) );
-    d_data->labelMap.insert( 337.5, QString::fromLatin1( "NNW" ) );
-#endif
+//!  Destructor
+QwtCompass::~QwtCompass()
+{
+    delete d_data;
 }
 
+
 /*!
    Draw the contents of the scale
 
@@ -231,62 +306,3 @@
         QwtDial::keyPressEvent( kev );
     }
 }
-
-/*!
-  \return map, mapping values to labels
-  \sa setLabelMap()
-*/
-const QMap<double, QString> &QwtCompass::labelMap() const
-{
-    return d_data->labelMap;
-}
-
-/*!
-  \return map, mapping values to labels
-  \sa setLabelMap()
-*/
-QMap<double, QString> &QwtCompass::labelMap()
-{
-    return d_data->labelMap;
-}
-
-/*!
-  \brief Set a map, mapping values to labels
-  \param map value to label map
-
-  The values of the major ticks are found by looking into this
-  map. The default map consists of the labels N, NE, E, SE, S, SW, W, NW.
-
-  \warning The map will have no effect for values that are no major
-           tick values. Major ticks can be changed by QwtScaleDraw::setScale
-
-  \sa labelMap(), scaleDraw(), setScale()
-*/
-void QwtCompass::setLabelMap( const QMap<double, QString> &map )
-{
-    d_data->labelMap = map;
-}
-
-/*!
-  Map a value to a corresponding label
-  \param value Value that will be mapped
-  \return Label, or QString::null
-
-  label() looks in a map for a corresponding label for value
-  or return an null text.
-  \sa labelMap(), setLabelMap()
-*/
-
-QwtText QwtCompass::scaleLabel( double value ) const
-{
-    if ( qFuzzyCompare( value, 0.0 ) )
-        value = 0.0;
-
-    if ( value < 0.0 )
-        value += 360.0;
-
-    if ( d_data->labelMap.contains( value ) )
-        return d_data->labelMap[value];
-
-    return QwtText();
-}
Index: qwt_plot_zoomer.cpp
===================================================================
--- qwt_plot_zoomer.cpp	(revision 382)
+++ qwt_plot_zoomer.cpp	(working copy)
@@ -9,7 +9,6 @@
 
 #include "qwt_plot_zoomer.h"
 #include "qwt_plot.h"
-#include "qwt_plot_canvas.h"
 #include "qwt_scale_div.h"
 #include "qwt_picker_machine.h"
 #include <qalgorithms.h>
@@ -32,17 +31,17 @@
   enabled, it is set to QwtPlot::yLeft.
 
   The zoomer is initialized with a QwtPickerDragRectMachine,
-  the tracker mode is set to QwtPicker::ActiveOnly and the rubberband
+  the tracker mode is set to QwtPicker::ActiveOnly and the rubber band
   is set to QwtPicker::RectRubberBand
 
   \param canvas Plot canvas to observe, also the parent object
-  \param doReplot Call replot for the attached plot before initializing
+  \param doReplot Call QwtPlot::replot() for the attached plot before initializing
                   the zoomer with its scales. This might be necessary,
                   when the plot is in a state with pending scale changes.
 
   \sa QwtPlot::autoReplot(), QwtPlot::replot(), setZoomBase()
 */
-QwtPlotZoomer::QwtPlotZoomer( QwtPlotCanvas *canvas, bool doReplot ):
+QwtPlotZoomer::QwtPlotZoomer( QWidget *canvas, bool doReplot ):
     QwtPlotPicker( canvas )
 {
     if ( canvas )
@@ -53,13 +52,13 @@
   \brief Create a zoomer for a plot canvas.
 
   The zoomer is initialized with a QwtPickerDragRectMachine,
-  the tracker mode is set to QwtPicker::ActiveOnly and the rubberband
+  the tracker mode is set to QwtPicker::ActiveOnly and the rubber band
   is set to QwtPicker;;RectRubberBand
 
   \param xAxis X axis of the zoomer
   \param yAxis Y axis of the zoomer
   \param canvas Plot canvas to observe, also the parent object
-  \param doReplot Call replot for the attached plot before initializing
+  \param doReplot Call QwtPlot::replot() for the attached plot before initializing
                   the zoomer with its scales. This might be necessary,
                   when the plot is in a state with pending scale changes.
 
@@ -67,7 +66,7 @@
 */
 
 QwtPlotZoomer::QwtPlotZoomer( int xAxis, int yAxis,
-        QwtPlotCanvas *canvas, bool doReplot ):
+        QWidget *canvas, bool doReplot ):
     QwtPlotPicker( xAxis, yAxis, canvas )
 {
     if ( canvas )
@@ -140,8 +139,8 @@
 }
 
 /*!
-  Return the zoom stack. zoomStack()[0] is the zoom base,
-  zoomStack()[1] the first zoomed rectangle.
+  \return The zoom stack. zoomStack()[0] is the zoom base,
+          zoomStack()[1] the first zoomed rectangle.
 
   \sa setZoomStack(), zoomRectIndex()
 */
@@ -162,7 +161,7 @@
 /*!
   Reinitialized the zoom stack with scaleRect() as base.
 
-  \param doReplot Call replot for the attached plot before initializing
+  \param doReplot Call QwtPlot::replot() for the attached plot before initializing
                   the zoomer with its scales. This might be necessary,
                   when the plot is in a state with pending scale changes.
 
@@ -188,7 +187,7 @@
   \brief Set the initial size of the zoomer.
 
   base is united with the current scaleRect() and the zoom stack is
-  reinitalized with it as zoom base. plot is zoomed to scaleRect().
+  reinitialized with it as zoom base. plot is zoomed to scaleRect().
 
   \param base Zoom base
 
@@ -217,8 +216,7 @@
 }
 
 /*!
-  Rectangle at the current position on the zoom stack.
-
+  \return Rectangle at the current position on the zoom stack.
   \sa zoomRectIndex(), scaleRect().
 */
 QRectF QwtPlotZoomer::zoomRect() const
@@ -238,7 +236,7 @@
   \brief Zoom in
 
   Clears all rectangles above the current position of the
-  zoom stack and pushs the normalized rect on it.
+  zoom stack and pushes the normalized rectangle on it.
 
   \note If the maximal stack depth is reached, zoom is ignored.
   \note The zoomed signal is emitted.
@@ -274,7 +272,7 @@
   \brief Zoom in or out
 
   Activate a rectangle on the zoom stack with an offset relative
-  to the current position. Negative values of offest will zoom out,
+  to the current position. Negative values of offset will zoom out,
   positive zoom in. A value of 0 zooms out to the zoom base.
 
   \param offset Offset relative to the current position of the zoom stack.
@@ -343,7 +341,7 @@
 /*!
   Adjust the observed plot to zoomRect()
 
-  \note Initiates QwtPlot::replot
+  \note Initiates QwtPlot::replot()
 */
 
 void QwtPlotZoomer::rescale()
@@ -489,12 +487,12 @@
 /*!
   \brief Check and correct a selected rectangle
 
-  Reject rectangles with a hight or width < 2, otherwise
+  Reject rectangles with a height or width < 2, otherwise
   expand the selected rectangle to a minimum size of 11x11
   and accept it.
 
-  \return true If rect is accepted, or has been changed
-          to a accepted rectangle.
+  \return true If the rectangle is accepted, or has been changed
+          to an accepted one.
 */
 
 bool QwtPlotZoomer::accept( QPolygon &pa ) const
@@ -567,7 +565,11 @@
   Expand the selected rectangle to minZoomSize() and zoom in
   if accepted.
 
+  \param ok If true, complete the selection and emit selected signals
+            otherwise discard the selection.
+
   \sa accept(), minZoomSize()
+  \return True if the selection has been accepted, false otherwise
 */
 bool QwtPlotZoomer::end( bool ok )
 {
Index: qwt_symbol.h
===================================================================
--- qwt_symbol.h	(revision 382)
+++ qwt_symbol.h	(working copy)
@@ -94,14 +94,26 @@
         Path,
 
         /*!
+          The symbol is represented by a pixmap. The pixmap is centered
+          or aligned to its pin point.
+
+          \sa setPinPoint()
          */
         Pixmap,
 
         /*!
+          The symbol is represented by a graphic. The graphic is centered
+          or aligned to its pin point.
+
+          \sa setPinPoint()
          */
         Graphic,
 
         /*!
+          The symbol is represented by a SVG graphic. The graphic is centered
+          or aligned to its pin point.
+
+          \sa setPinPoint()
          */
         SvgDocument,
 
@@ -143,7 +155,7 @@
         Cache,
 
         /*! 
-           Use a cache wehn one of the following condiditions is true:
+           Use a cache when one of the following conditions is true:
 
            - The symbol is rendered with the software 
              renderer ( QPaintEngine::Raster )
@@ -176,6 +188,7 @@
     void setBrush( const QBrush& b );
     const QBrush& brush() const;
 
+    void setPen( const QColor &, qreal width = 0.0, Qt::PenStyle = Qt::SolidLine );
     void setPen( const QPen & );
     const QPen& pen() const;
 
Index: qwt_plot_seriesitem.h
===================================================================
--- qwt_plot_seriesitem.h	(revision 382)
+++ qwt_plot_seriesitem.h	(working copy)
@@ -41,7 +41,7 @@
       \param painter Painter
       \param xMap Maps x-values into pixel coordinates.
       \param yMap Maps y-values into pixel coordinates.
-      \param canvasRect Contents rect of the canvas
+      \param canvasRect Contents rectangle of the canvas
       \param from Index of the first point to be painted
       \param to Index of the last point to be painted. If to < 0 the
              curve will be painted to its last point.
Index: qwt_plot_canvas.h
===================================================================
--- qwt_plot_canvas.h	(revision 382)
+++ qwt_plot_canvas.h	(working copy)
@@ -12,9 +12,7 @@
 
 #include "qwt_global.h"
 #include <qframe.h>
-#include <qpen.h>
 #include <qpainterpath.h>
-#include <qbitmap.h>
 
 class QwtPlot;
 class QPixmap;
@@ -24,12 +22,14 @@
   
    Canvas is the widget where all plot items are displayed
 
-  \sa QwtPlot
+  \sa QwtPlot::setCanvas(), QwtPlotGLCanvas
 */
 class QWT_EXPORT QwtPlotCanvas : public QFrame
 {
     Q_OBJECT
 
+    Q_PROPERTY( double borderRadius READ borderRadius WRITE setBorderRadius )
+
 public:
 
     /*!
@@ -46,7 +46,7 @@
                  of the pixmap buffer when possible. 
 
           Using a backing store might improve the performance
-          significantly, when workin with widget overlays ( like rubberbands ).
+          significantly, when working with widget overlays ( like rubber bands ).
           Disabling the cache might improve the performance for
           incremental paints (using QwtPlotDirectPainter ).
 
@@ -80,10 +80,10 @@
           handle backgrounds with rounded corners - beside of padding.
 
           When HackStyledBackground is enabled the plot canvas tries
-          to seperate the background from the background border
-          by reverse engeneering to paint the background before and
+          to separate the background from the background border
+          by reverse engineering to paint the background before and
           the border after the plot items. In this order the border
-          gets prefectly antialiased and you can avoid some pixel
+          gets perfectly antialiased and you can avoid some pixel
           artifacts in the corners.
          */
         HackStyledBackground = 4,
@@ -125,7 +125,7 @@
         ItemFocusIndicator
     };
 
-    explicit QwtPlotCanvas( QwtPlot * );
+    explicit QwtPlotCanvas( QwtPlot * = NULL );
     virtual ~QwtPlotCanvas();
 
     QwtPlot *plot();
@@ -137,19 +137,19 @@
     void setBorderRadius( double );
     double borderRadius() const;
 
-    QPainterPath borderPath( const QRect &rect ) const;
-    QBitmap borderMask( const QSize & ) const;
-
     void setPaintAttribute( PaintAttribute, bool on = true );
     bool testPaintAttribute( PaintAttribute ) const;
 
     const QPixmap *backingStore() const;
     void invalidateBackingStore();
 
+    virtual bool event( QEvent * );
+
+    Q_INVOKABLE QPainterPath borderPath( const QRect & ) const;
+
+public Q_SLOTS:
     void replot();
 
-    virtual bool event( QEvent * );
-
 protected:
     virtual void paintEvent( QPaintEvent * );
     virtual void resizeEvent( QResizeEvent * );
Index: qwt_dial.h
===================================================================
--- qwt_dial.h	(revision 382)
+++ qwt_dial.h	(working copy)
@@ -12,34 +12,14 @@
 
 #include "qwt_global.h"
 #include "qwt_abstract_slider.h"
-#include "qwt_round_scale_draw.h"
+#include "qwt_abstract_scale_draw.h"
 #include <qframe.h>
 #include <qpalette.h>
 
 class QwtDialNeedle;
-class QwtDial;
+class QwtRoundScaleDraw;
 
 /*!
-  \brief A special scale draw made for QwtDial
-
-  \sa QwtDial, QwtCompass
-*/
-class QWT_EXPORT QwtDialScaleDraw: public QwtRoundScaleDraw
-{
-public:
-    explicit QwtDialScaleDraw( QwtDial * );
-
-    virtual QwtText label( double value ) const;
-
-    void setPenWidth( double );
-    double penWidth() const;
-
-private:
-    QwtDial *d_parent;
-    double d_penWidth;
-};
-
-/*!
   \brief QwtDial class provides a rounded range control.
 
   QwtDial is intended as base class for dial widgets like
@@ -51,34 +31,34 @@
   of the dial. Depending on Mode one of them is fixed and the
   other is rotating. If not isReadOnly() the
   dial can be rotated by dragging the mouse or using keyboard inputs
-  (see keyPressEvent()). A dial might be wrapping, what means
+  (see QwtAbstractSlider::keyPressEvent()). A dial might be wrapping, what means
   a rotation below/above one limit continues on the other limit (f.e compass).
   The scale might cover any arc of the dial, its values are related to
   the origin() of the dial.
 
-  Qwt is missing a set of good looking needles (QwtDialNeedle).
-  Contributions are very welcome.
+  Often dials have to be updated very often according to values from external
+  devices. For these high refresh rates QwtDial caches as much as possible.
+  For derived classes it might be necessary to clear these caches manually
+  according to attribute changes using invalidateCache().
 
   \sa QwtCompass, QwtAnalogClock, QwtDialNeedle
-  \note The examples/dials example shows different types of dials.
+  \note The controls and dials examples shows different types of dials.
+  \note QDial is more similar to QwtKnob than to QwtDial
 */
 
 class QWT_EXPORT QwtDial: public QwtAbstractSlider
 {
     Q_OBJECT
 
-    Q_ENUMS( Shadow )
-    Q_ENUMS( Mode )
-    Q_ENUMS( Direction )
+    Q_ENUMS( Shadow Mode Direction )
 
     Q_PROPERTY( int lineWidth READ lineWidth WRITE setLineWidth )
     Q_PROPERTY( Shadow frameShadow READ frameShadow WRITE setFrameShadow )
     Q_PROPERTY( Mode mode READ mode WRITE setMode )
     Q_PROPERTY( double origin READ origin WRITE setOrigin )
-    Q_PROPERTY( bool wrapping READ wrapping WRITE setWrapping )
-    Q_PROPERTY( Direction direction READ direction WRITE setDirection )
+    Q_PROPERTY( double minScaleArc READ minScaleArc WRITE setMinScaleArc )
+    Q_PROPERTY( double maxScaleArc READ maxScaleArc WRITE setMaxScaleArc )
 
-    friend class QwtDialScaleDraw;
 public:
 
     /*!
@@ -101,7 +81,7 @@
         Sunken = QFrame::Sunken
     };
 
-    //! Mode controlling wether the needle or the scale is rotating
+    //! Mode controlling whether the needle or the scale is rotating
     enum Mode
     {
         //! The needle is rotating
@@ -111,16 +91,6 @@
         RotateScale
     };
 
-    //! Direction of the dial
-    enum Direction
-    {
-        //! Clockwise
-        Clockwise,
-
-        //! Counter clockwise
-        CounterClockwise
-    };
-
     explicit QwtDial( QWidget *parent = NULL );
     virtual ~QwtDial();
 
@@ -133,80 +103,63 @@
     void setMode( Mode );
     Mode mode() const;
 
-    virtual void setWrapping( bool );
-    bool wrapping() const;
-
-    virtual void setScale( int maxMajIntv, int maxMinIntv, double step = 0.0 );
-
     void setScaleArc( double min, double max );
-    void setScaleComponents( QwtAbstractScaleDraw::ScaleComponents );
-    void setScaleTicks( int minLen, int medLen, int majLen, int penWidth = 1 );
 
+    void setMinScaleArc( double min );
     double minScaleArc() const;
+
+    void setMaxScaleArc( double min );
     double maxScaleArc() const;
 
     virtual void setOrigin( double );
     double origin() const;
 
-    void setDirection( Direction );
-    Direction direction() const;
-
-    virtual void setNeedle( QwtDialNeedle * );
+    void setNeedle( QwtDialNeedle * );
     const QwtDialNeedle *needle() const;
     QwtDialNeedle *needle();
 
-    QRectF boundingRect() const;
-    QRectF innerRect() const;
-    virtual QRectF scaleInnerRect() const;
+    QRect boundingRect() const;
+    QRect innerRect() const;
 
+    virtual QRect scaleInnerRect() const;
+
     virtual QSize sizeHint() const;
     virtual QSize minimumSizeHint() const;
 
-    virtual void setScaleDraw( QwtDialScaleDraw * );
+    void setScaleDraw( QwtRoundScaleDraw * );
 
-    QwtDialScaleDraw *scaleDraw();
-    const QwtDialScaleDraw *scaleDraw() const;
+    QwtRoundScaleDraw *scaleDraw();
+    const QwtRoundScaleDraw *scaleDraw() const;
 
 protected:
+    virtual void wheelEvent( QWheelEvent * );
     virtual void paintEvent( QPaintEvent * );
-    virtual void keyPressEvent( QKeyEvent * );
+    virtual void changeEvent( QEvent * );
 
     virtual void drawFrame( QPainter *p );
     virtual void drawContents( QPainter * ) const;
     virtual void drawFocusIndicator( QPainter * ) const;
 
-    virtual void drawScale( 
-        QPainter *, const QPointF &center,
-        double radius, double origin, 
-        double arcMin, double arcMax ) const;
+    void invalidateCache();
 
-    /*!
-      Draw the contents inside the scale
+    virtual void drawScale( QPainter *, 
+        const QPointF &center, double radius ) const;
 
-      Paints nothing.
-
-      \param painter Painter
-      \param center Center of the contents circle
-      \param radius Radius of the contents circle
-    */
     virtual void drawScaleContents( QPainter *painter, 
         const QPointF &center, double radius ) const;
 
     virtual void drawNeedle( QPainter *, const QPointF &,
         double radius, double direction, QPalette::ColorGroup ) const;
 
-    virtual QwtText scaleLabel( double ) const;
-    void updateScale();
+    virtual double scrolledTo( const QPoint & ) const;
+    virtual bool isScrollPosition( const QPoint & ) const;
 
-    virtual void rangeChange();
-    virtual void valueChange();
+    virtual void sliderChange();
+    virtual void scaleChange();
 
-    virtual double getValue( const QPoint & );
-    virtual void getScrollMode( const QPoint &,
-        QwtAbstractSlider::ScrollMode &, int &direction ) const;
-
 private:
-    void initDial();
+    void setAngleRange( double angle, double span );
+    void drawNeedle( QPainter * ) const;
 
     class PrivateData;
     PrivateData *d_data;
Index: qwt_analog_clock.h
===================================================================
--- qwt_analog_clock.h	(revision 382)
+++ qwt_analog_clock.h	(working copy)
@@ -21,7 +21,8 @@
   \image html analogclock.png
 
   \par Example
-  \verbatim #include <qwt_analog_clock.h>
+  \code 
+  #include <qwt_analog_clock.h>
 
   QwtAnalogClock *clock = new QwtAnalogClock(...);
   clock->scaleDraw()->setPenWidth(3);
@@ -34,11 +35,8 @@
   timer->connect(timer, SIGNAL(timeout()), clock, SLOT(setCurrentTime()));
   timer->start(1000);
 
-  \endverbatim
+  \endcode
 
-  Qwt is missing a set of good looking hands.
-  Contributions are very welcome.
-
   \note The examples/dials example shows how to use QwtAnalogClock.
 */
 
@@ -69,17 +67,16 @@
     explicit QwtAnalogClock( QWidget* parent = NULL );
     virtual ~QwtAnalogClock();
 
-    virtual void setHand( Hand, QwtDialNeedle * );
+    void setHand( Hand, QwtDialNeedle * );
+
     const QwtDialNeedle *hand( Hand ) const;
     QwtDialNeedle *hand( Hand );
 
 public Q_SLOTS:
     void setCurrentTime();
-    void setTime( const QTime & = QTime::currentTime() );
+    void setTime( const QTime & );
 
 protected:
-    virtual QwtText scaleLabel( double ) const;
-
     virtual void drawNeedle( QPainter *, const QPointF &,
         double radius, double direction, QPalette::ColorGroup ) const;
 
@@ -87,8 +84,8 @@
         double radius, double direction, QPalette::ColorGroup ) const;
 
 private:
-    virtual void setNeedle( QwtDialNeedle * );
-    void initClock();
+    // use setHand instead
+    void setNeedle( QwtDialNeedle * );
 
     QwtDialNeedle *d_hand[NHands];
 };
Index: qwt_plot_curve.cpp
===================================================================
--- qwt_plot_curve.cpp	(revision 382)
+++ qwt_plot_curve.cpp	(working copy)
@@ -14,7 +14,6 @@
 #include "qwt_painter.h"
 #include "qwt_scale_map.h"
 #include "qwt_plot.h"
-#include "qwt_plot_canvas.h"
 #include "qwt_curve_fitter.h"
 #include "qwt_symbol.h"
 #include "qwt_point_mapper.h"
@@ -157,7 +156,7 @@
 }
 
 /*!
-    \brief Return the current paint attributes
+    \return True, when attribute is enabled
     \sa setPaintAttribute()
 */
 bool QwtPlotCurve::testPaintAttribute( PaintAttribute attribute ) const
@@ -174,21 +173,21 @@
 */
 void QwtPlotCurve::setLegendAttribute( LegendAttribute attribute, bool on )
 {
-    if ( on != ( d_data->legendAttributes & attribute ) )
+    if ( on != testLegendAttribute( attribute ) )
     {
-
         if ( on )
             d_data->legendAttributes |= attribute;
         else
             d_data->legendAttributes &= ~attribute;
 
         qwtUpdateLegendIconSize( this );
+        legendChanged();
     }
 }
 
 /*!
-    \brief Return the current paint attributes
-    \sa setLegendAttribute()
+  \return True, when attribute is enabled
+  \sa setLegendAttribute()
 */
 bool QwtPlotCurve::testLegendAttribute( LegendAttribute attribute ) const
 {
@@ -213,8 +212,8 @@
 }
 
 /*!
-    Return the current style
-    \sa setStyle()
+  \return Style of the curve
+  \sa setStyle()
 */
 QwtPlotCurve::CurveStyle QwtPlotCurve::style() const
 {
@@ -222,12 +221,16 @@
 }
 
 /*!
-  Assign a symbol
+  \brief Assign a symbol
 
+  The curve will take the ownership of the symbol, hence the previously
+  set symbol will be delete by setting a new one. If \p symbol is 
+  \c NULL no symbol will be drawn.
+
   \param symbol Symbol
   \sa symbol()
 */
-void QwtPlotCurve::setSymbol( const QwtSymbol *symbol )
+void QwtPlotCurve::setSymbol( QwtSymbol *symbol )
 {
     if ( symbol != d_data->symbol )
     {
@@ -251,6 +254,24 @@
 }
 
 /*!
+  Build and assign a pen
+
+  In Qt5 the default pen width is 1.0 ( 0.0 in Qt4 ) what makes it
+  non cosmetic ( see QPen::isCosmetic() ). This method has been introduced
+  to hide this incompatibility.
+
+  \param color Pen color
+  \param width Pen width
+  \param style Pen style
+
+  \sa pen(), brush()
+ */
+void QwtPlotCurve::setPen( const QColor &color, qreal width, Qt::PenStyle style )
+{
+    setPen( QPen( color, width, style ) );
+}
+
+/*!
   Assign a pen
 
   \param pen New pen
@@ -317,7 +338,7 @@
   \param painter Painter
   \param xMap Maps x-values into pixel coordinates.
   \param yMap Maps y-values into pixel coordinates.
-  \param canvasRect Contents rect of the canvas
+  \param canvasRect Contents rectangle of the canvas
   \param from Index of the first point to be painted
   \param to Index of the last point to be painted. If to < 0 the
          curve will be painted to its last point.
@@ -367,7 +388,7 @@
   \param style curve style, see QwtPlotCurve::CurveStyle
   \param xMap x map
   \param yMap y map
-  \param canvasRect Contents rect of the canvas
+  \param canvasRect Contents rectangle of the canvas
   \param from index of the first point to be painted
   \param to index of the last point to be painted
   \sa draw(), drawDots(), drawLines(), drawSteps(), drawSticks()
@@ -412,7 +433,7 @@
   \param painter Painter
   \param xMap x map
   \param yMap y map
-  \param canvasRect Contents rect of the canvas
+  \param canvasRect Contents rectangle of the canvas
   \param from index of the first point to be painted
   \param to index of the last point to be painted
 
@@ -438,22 +459,24 @@
         clipRect = canvasRect.adjusted(-pw, -pw, pw, pw);
     }
 
-    // The raster paint engine is significantly faster
+    bool doIntegers = false;
+
+#if QT_VERSION < 0x040800
+
+    // For Qt <= 4.7 the raster paint engine is significantly faster
     // for rendering QPolygon than for QPolygonF. So let's
-    // see if we can use them.
+    // see if we can use it.
 
-    bool doIntegers = false;
-
-    if ( doAlign && !testRenderHint( QwtPlotItem::RenderFloats )
-        && !QwtPainter::isX11GraphicsSystem() )
+    if ( painter->paintEngine()->type() == QPaintEngine::Raster )
     {
         // In case of filling or fitting performance doesn't count
         // because both operations are much more expensive
-        // then drawing the polyline itsself
+        // then drawing the polyline itself
 
         if ( !doFit && !doFill )
             doIntegers = true; 
     }
+#endif
 
     const bool noDuplicates = d_data->paintAttributes & FilterPoints;
 
@@ -512,7 +535,7 @@
   \param painter Painter
   \param xMap x map
   \param yMap y map
-  \param canvasRect Contents rect of the canvas
+  \param canvasRect Contents rectangle of the canvas
   \param from index of the first point to be painted
   \param to index of the last point to be painted
 
@@ -565,7 +588,7 @@
   \param painter Painter
   \param xMap x map
   \param yMap y map
-  \param canvasRect Contents rect of the canvas
+  \param canvasRect Contents rectangle of the canvas
   \param from index of the first point to be painted
   \param to index of the last point to be painted
 
@@ -612,7 +635,9 @@
     else if ( d_data->paintAttributes & ImageBuffer )
     {
         const QImage image = mapper.toImage( xMap, yMap,
-            data(), from, to, color.rgba() );
+            data(), from, to, d_data->pen, 
+            painter->testRenderHint( QPainter::Antialiasing ),
+            renderThreadCount() );
 
         painter->drawImage( canvasRect.toAlignedRect(), image );
     }
@@ -638,7 +663,7 @@
     }
     else
     {
-        if ( doAlign && !testRenderHint( QwtPlotItem::RenderFloats ) )
+        if ( doAlign )
         {
             const QPolygon points = mapper.toPoints(
                 xMap, yMap, data(), from, to ); 
@@ -663,7 +688,7 @@
   \param painter Painter
   \param xMap x map
   \param yMap y map
-  \param canvasRect Contents rect of the canvas
+  \param canvasRect Contents rectangle of the canvas
   \param from index of the first point to be painted
   \param to index of the last point to be painted
 
@@ -808,7 +833,7 @@
   \param painter Painter
   \param xMap x map
   \param yMap y map
-  \param canvasRect Contents rect of the canvas
+  \param canvasRect Contents rectangle of the canvas
   \param polygon Polygon - will be modified !
 
   \sa setBrush(), setBaseline(), setStyle()
@@ -863,11 +888,8 @@
     
     if ( orientation() == Qt::Vertical )
     {
-        if ( yMap.transformation()->type() == QwtScaleTransformation::Log10 )
-        {
-            if ( baseline < QwtScaleMap::LogMin )
-                baseline = QwtScaleMap::LogMin;
-        }
+        if ( yMap.transformation() )
+            baseline = yMap.transformation()->bounded( baseline );
 
         double refY = yMap.transform( baseline );
         if ( doAlign )
@@ -878,11 +900,8 @@
     }
     else
     {
-        if ( xMap.transformation()->type() == QwtScaleTransformation::Log10 )
-        {
-            if ( baseline < QwtScaleMap::LogMin )
-                baseline = QwtScaleMap::LogMin;
-        }
+        if ( xMap.transformation() )
+            baseline = xMap.transformation()->bounded( baseline );
 
         double refX = xMap.transform( baseline );
         if ( doAlign )
@@ -900,7 +919,7 @@
   \param symbol Curve symbol
   \param xMap x map
   \param yMap y map
-  \param canvasRect Contents rect of the canvas
+  \param canvasRect Contents rectangle of the canvas
   \param from Index of the first point to be painted
   \param to Index of the last point to be painted
 
@@ -970,7 +989,7 @@
 
   \param pos Position, where to look for the closest curve point
   \param dist If dist != NULL, closestPoint() returns the distance between
-              the position and the clostest curve point
+              the position and the closest curve point
   \return Index of the closest curve point, or -1 if none can be found
           ( f.e when the curve has no points )
   \note closestPoint() implements a dumb algorithm, that iterates
@@ -1012,7 +1031,7 @@
 }
 
 /*!
-    \return Icon representing the curve on the legend
+   \return Icon representing the curve on the legend
 
    \param index Index of the legend entry 
                 ( ignored as there is only one )
@@ -1089,15 +1108,32 @@
 }
 
 /*!
-  Initialize data with an array of points (explicitly shared).
+  Initialize data with an array of points.
 
   \param samples Vector of points
+  \note QVector is implicitly shared
+  \note QPolygonF is derived from QVector<QPointF>
 */
 void QwtPlotCurve::setSamples( const QVector<QPointF> &samples )
 {
     setData( new QwtPointSeriesData( samples ) );
 }
 
+/*!
+  Assign a series of points
+
+  setSamples() is just a wrapper for setData() without any additional
+  value - beside that it is easier to find for the developer.
+
+  \param data Data
+  \warning The item takes ownership of the data object, deleting
+           it when its not used anymore.
+*/
+void QwtPlotCurve::setSamples( QwtSeriesData<QPointF> *data )
+{
+    setData( data );
+}
+
 #ifndef QWT_NO_COMPAT
 
 /*!
Index: qwt_plot_rasteritem.h
===================================================================
--- qwt_plot_rasteritem.h	(revision 382)
+++ qwt_plot_rasteritem.h	(working copy)
@@ -98,9 +98,6 @@
 
     void invalidateCache();
 
-    void setRenderThreadCount( uint numThreads );
-    uint renderThreadCount() const;
-
     virtual void draw( QPainter *p,
         const QwtScaleMap &xMap, const QwtScaleMap &yMap,
         const QRectF &rect ) const;
@@ -124,6 +121,8 @@
       \param yMap Y-Scale Map
       \param area Requested area for the image in scale coordinates
       \param imageSize Requested size of the image
+   
+      \return Rendered image
      */
     virtual QImage renderImage( const QwtScaleMap &xMap,
         const QwtScaleMap &yMap, const QRectF &area,
Index: qwt_panner.cpp
===================================================================
--- qwt_panner.cpp	(revision 382)
+++ qwt_panner.cpp	(working copy)
@@ -9,6 +9,7 @@
 
 #include "qwt_panner.h"
 #include "qwt_picker.h"
+#include "qwt_painter.h"
 #include <qpainter.h>
 #include <qpixmap.h>
 #include <qevent.h>
@@ -35,9 +36,9 @@
 public:
     PrivateData():
         button( Qt::LeftButton ),
-        buttonState( Qt::NoButton ),
+        buttonModifiers( Qt::NoModifier ),
         abortKey( Qt::Key_Escape ),
-        abortKeyState( Qt::NoButton ),
+        abortKeyModifiers( Qt::NoModifier ),
 #ifndef QT_NO_CURSOR
         cursor( NULL ),
         restoreCursor( NULL ),
@@ -56,10 +57,11 @@
 #endif
     }
 
-    int button;
-    int buttonState;
+    Qt::MouseButton button;
+    Qt::KeyboardModifiers  buttonModifiers;
+
     int abortKey;
-    int abortKeyState;
+    Qt::KeyboardModifiers abortKeyModifiers;
 
     QPoint initialPos;
     QPoint pos;
@@ -101,40 +103,44 @@
 }
 
 /*!
-   Change the mouse button
-   The defaults are Qt::LeftButton and Qt::NoButton
+   Change the mouse button and modifiers used for panning
+   The defaults are Qt::LeftButton and Qt::NoModifier
 */
-void QwtPanner::setMouseButton( int button, int buttonState )
+void QwtPanner::setMouseButton( Qt::MouseButton button,
+    Qt::KeyboardModifiers modifiers )
 {
     d_data->button = button;
-    d_data->buttonState = buttonState;
+    d_data->buttonModifiers = modifiers;
 }
 
-//! Get the mouse button
-void QwtPanner::getMouseButton( int &button, int &buttonState ) const
+//! Get mouse button and modifiers used for panning
+void QwtPanner::getMouseButton( Qt::MouseButton &button,
+    Qt::KeyboardModifiers &modifiers ) const
 {
     button = d_data->button;
-    buttonState = d_data->buttonState;
+    modifiers = d_data->buttonModifiers;
 }
 
 /*!
    Change the abort key
-   The defaults are Qt::Key_Escape and Qt::NoButton
+   The defaults are Qt::Key_Escape and Qt::NoModifiers
 
    \param key Key ( See Qt::Keycode )
-   \param state State
+   \param modifiers Keyboard modifiers
 */
-void QwtPanner::setAbortKey( int key, int state )
+void QwtPanner::setAbortKey( int key, 
+    Qt::KeyboardModifiers modifiers )
 {
     d_data->abortKey = key;
-    d_data->abortKeyState = state;
+    d_data->abortKeyModifiers = modifiers;
 }
 
-//! Get the abort key
-void QwtPanner::getAbortKey( int &key, int &state ) const
+//! Get the abort key and modifiers
+void QwtPanner::getAbortKey( int &key, 
+    Qt::KeyboardModifiers &modifiers ) const
 {
     key = d_data->abortKey;
-    state = d_data->abortKeyState;
+    modifiers = d_data->abortKeyModifiers;
 }
 
 /*!
@@ -218,7 +224,7 @@
 }
 
 /*!
-   Return true if a orientatio is enabled
+   \return True if an orientation is enabled
    \sa orientations(), setOrientations()
 */
 bool QwtPanner::isOrientationEnabled( Qt::Orientation o ) const
@@ -252,7 +258,7 @@
     r.moveCenter( QPoint( r.center().x() + dx, r.center().y() + dy ) );
 
     QPixmap pm( size() );
-    pm.fill( parentWidget(), 0, 0 );
+    QwtPainter::fillPixmap( parentWidget(), pm );
 
     QPainter painter( &pm );
 
@@ -293,20 +299,29 @@
 
 /*!
   Grab the widget into a pixmap.
+  \return Grabbed pixmap
 */
 QPixmap QwtPanner::grab() const
 {
+#if QT_VERSION >= 0x050000
+    return parentWidget()->grab( parentWidget()->rect() );
+#else
     return QPixmap::grabWidget( parentWidget() );
+#endif
 }
 
 /*!
   \brief Event filter
 
-  When isEnabled() the mouse events of the observed widget are filtered.
+  When isEnabled() is true mouse events of the
+  observed widget are filtered.
 
   \param object Object to be filtered
   \param event Event
 
+  \return Always false, beside for paint events for the
+          parent widget.
+
   \sa widgetMousePressEvent(), widgetMouseReleaseEvent(),
       widgetMouseMoveEvent()
 */
@@ -363,19 +378,16 @@
 */
 void QwtPanner::widgetMousePressEvent( QMouseEvent *mouseEvent )
 {
-    if ( mouseEvent->button() != d_data->button )
+    if ( ( mouseEvent->button() != d_data->button )
+        || ( mouseEvent->modifiers() != d_data->buttonModifiers ) )
+    {
         return;
+    }
 
     QWidget *w = parentWidget();
     if ( w == NULL )
         return;
 
-    if ( ( mouseEvent->modifiers() & Qt::KeyboardModifierMask ) !=
-        ( int )( d_data->buttonState & Qt::KeyboardModifierMask ) )
-    {
-        return;
-    }
-
 #ifndef QT_NO_CURSOR
     showCursor( true );
 #endif
@@ -467,19 +479,15 @@
 */
 void QwtPanner::widgetKeyPressEvent( QKeyEvent *keyEvent )
 {
-    if ( keyEvent->key() == d_data->abortKey )
+    if ( ( keyEvent->key() == d_data->abortKey )
+        && ( keyEvent->modifiers() == d_data->abortKeyModifiers ) )
     {
-        const bool matched =
-            ( keyEvent->modifiers() & Qt::KeyboardModifierMask ) ==
-                ( int )( d_data->abortKeyState & Qt::KeyboardModifierMask );
-        if ( matched )
-        {
-            hide();
+        hide();
+
 #ifndef QT_NO_CURSOR
-            showCursor( false );
+        showCursor( false );
 #endif
-            d_data->pixmap = QPixmap();
-        }
+        d_data->pixmap = QPixmap();
     }
 }
 
Index: qwt_plot_marker.h
===================================================================
--- qwt_plot_marker.h	(revision 382)
+++ qwt_plot_marker.h	(working copy)
@@ -28,7 +28,7 @@
   a symbol, a label or any combination of them, which can
   be drawn around a center point inside a bounding rectangle.
 
-  The QwtPlotMarker::setSymbol() member assigns a symbol to the marker.
+  The setSymbol() member assigns a symbol to the marker.
   The symbol is drawn at the specified point.
 
   With setLabel(), a label can be assigned to the marker.
@@ -39,6 +39,10 @@
   the marker, which means, for example, that the label would be printed
   left above the center point if the alignment was set to 
   Qt::AlignLeft | Qt::AlignTop.
+
+  \note QwtPlotTextLabel is intended to align a text label
+        according to the geometry of canvas 
+        ( unrelated to plot coordinates )
 */
 
 class QWT_EXPORT QwtPlotMarker: public QwtPlotItem
@@ -83,6 +87,7 @@
     void setLineStyle( LineStyle st );
     LineStyle lineStyle() const;
 
+    void setLinePen( const QColor &, qreal width = 0.0, Qt::PenStyle = Qt::SolidLine );
     void setLinePen( const QPen &p );
     const QPen &linePen() const;
 
Index: qwt_scale_map.cpp
===================================================================
--- qwt_scale_map.cpp	(revision 382)
+++ qwt_scale_map.cpp	(working copy)
@@ -8,93 +8,11 @@
  *****************************************************************************/
 
 #include "qwt_scale_map.h"
+#include "qwt_math.h"
 #include <qrect.h>
-#include <qalgorithms.h>
-#include <qmath.h>
 #include <qdebug.h>
 
-#if QT_VERSION < 0x040601
-#define qExp(x) ::exp(x)
-#endif
-
-//! Smallest allowed value for logarithmic scales: 1.0e-150
-QT_STATIC_CONST_IMPL double QwtScaleMap::LogMin = 1.0e-150;
-
-//! Largest allowed value for logarithmic scales: 1.0e150
-QT_STATIC_CONST_IMPL double QwtScaleMap::LogMax = 1.0e150;
-
-//! Constructor for a linear transformation
-QwtScaleTransformation::QwtScaleTransformation( Type type ):
-    d_type( type )
-{
-}
-
-//! Destructor
-QwtScaleTransformation::~QwtScaleTransformation()
-{
-}
-
-//! Create a clone of the transformation
-QwtScaleTransformation *QwtScaleTransformation::copy() const
-{
-    return new QwtScaleTransformation( d_type );
-}
-
 /*!
-  \brief Transform a value from the coordinate system of a scale
-         into the coordinate system of the paint device
-
-  \param s  Value related to the coordinate system of the scale
-  \param s1 First border of the coordinate system of the scale
-  \param s2 Second border of the coordinate system of the scale
-  \param p1 First border of the coordinate system of the paint device
-  \param p2 Second border of the coordinate system of the paint device
-  \return
-  <dl>
-  <dt>linear mapping:<dd>p1 + (p2 - p1) / (s2 - s1) * (s - s1);</dd>
-  </dl>
-  <dl>
-  <dt>log10 mapping: <dd>p1 + (p2 - p1) / log(s2 / s1) * log(s / s1);</dd>
-  </dl>
-*/
-
-double QwtScaleTransformation::xForm(
-    double s, double s1, double s2, double p1, double p2 ) const
-{
-    if ( d_type == Log10 )
-        return p1 + ( p2 - p1 ) / log( s2 / s1 ) * log( s / s1 );
-    else
-        return p1 + ( p2 - p1 ) / ( s2 - s1 ) * ( s - s1 );
-}
-
-/*!
-  \brief Transform a value from the coordinate system of the paint device
-         into the coordinate system of a scale.
-
-  \param p Value related to the coordinate system of the paint device 
-  \param p1 First border of the coordinate system of the paint device
-  \param p2 Second border of the coordinate system of the paint device
-  \param s1 First border of the coordinate system of the scale
-  \param s2 Second border of the coordinate system of the scale
-  \return
-  <dl>
-  <dt>linear mapping:<dd>s1 + ( s2 - s1 ) / ( p2 - p1 ) * ( p - p1 );</dd>
-  </dl>
-  <dl>
-  <dt>log10 mapping:<dd>exp((p - p1) / (p2 - p1) * log(s2 / s1)) * s1;</dd>
-  </dl>
-*/
-
-double QwtScaleTransformation::invXForm( double p, double p1, double p2,
-    double s1, double s2 ) const
-{
-    if ( d_type == Log10 )
-        return qExp( ( p - p1 ) / ( p2 - p1 ) * log( s2 / s1 ) ) * s1;
-    else
-        return s1 + ( s2 - s1 ) / ( p2 - p1 ) * ( p - p1 );
-}
-
-/*!
   \brief Constructor
 
   The scale and paint device intervals are both set to [0,1].
@@ -105,10 +23,9 @@
     d_p1( 0.0 ),
     d_p2( 1.0 ),
     d_cnv( 1.0 ),
-    d_cnvInv( 1.0 )
+    d_ts1( 0.0 ),
+    d_transform( NULL )
 {
-    d_transformation = new QwtScaleTransformation(
-        QwtScaleTransformation::Linear );
 }
 
 //! Copy constructor
@@ -118,9 +35,11 @@
     d_p1( other.d_p1 ),
     d_p2( other.d_p2 ),
     d_cnv( other.d_cnv ),
-    d_cnvInv( other.d_cnvInv )
+    d_ts1( other.d_ts1 ),
+    d_transform( NULL )
 {
-    d_transformation = other.d_transformation->copy();
+    if ( other.d_transform )
+        d_transform = other.d_transform->copy();
 }
 
 /*!
@@ -128,7 +47,7 @@
 */
 QwtScaleMap::~QwtScaleMap()
 {
-    delete d_transformation;
+    delete d_transform;
 }
 
 //! Assignment operator
@@ -139,64 +58,56 @@
     d_p1 = other.d_p1;
     d_p2 = other.d_p2;
     d_cnv = other.d_cnv;
-    d_cnvInv = other.d_cnvInv;
+    d_ts1 = other.d_ts1;
 
-    delete d_transformation;
-    d_transformation = other.d_transformation->copy();
+    delete d_transform;
+    d_transform = NULL;
 
+    if ( other.d_transform )
+        d_transform = other.d_transform->copy();
+
     return *this;
 }
 
 /*!
    Initialize the map with a transformation
 */
-void QwtScaleMap::setTransformation(
-    QwtScaleTransformation *transformation )
+void QwtScaleMap::setTransformation( QwtTransform *transform )
 {
-    if ( transformation == NULL )
-        return;
-
-    if ( transformation != d_transformation )
+    if ( transform != d_transform )
     {
-        delete d_transformation;
-        d_transformation = transformation;
+        delete d_transform;
+        d_transform = transform;
     }
 
     setScaleInterval( d_s1, d_s2 );
 }
 
 //! Get the transformation
-const QwtScaleTransformation *QwtScaleMap::transformation() const
+const QwtTransform *QwtScaleMap::transformation() const
 {
-    return d_transformation;
+    return d_transform;
 }
 
 /*!
   \brief Specify the borders of the scale interval
   \param s1 first border
   \param s2 second border
-  \warning logarithmic scales might be aligned to [LogMin, LogMax]
+  \warning scales might be aligned to 
+           transformation depending boundaries
 */
 void QwtScaleMap::setScaleInterval( double s1, double s2 )
 {
-    if ( d_transformation->type() == QwtScaleTransformation::Log10 )
-    {
-        if ( s1 < LogMin )
-            s1 = LogMin;
-        else if ( s1 > LogMax )
-            s1 = LogMax;
-
-        if ( s2 < LogMin )
-            s2 = LogMin;
-        else if ( s2 > LogMax )
-            s2 = LogMax;
-    }
-
     d_s1 = s1;
     d_s2 = s2;
 
-    if ( d_transformation->type() != QwtScaleTransformation::Other )
-        newFactor();
+    if ( d_transform )
+    {
+        d_s1 = d_transform->bounded( d_s1 );
+        d_s2 = d_transform->bounded( d_s2 );
+    }
+
+    updateFactor();
 }
 
 /*!
@@ -209,40 +120,23 @@
     d_p1 = p1;
     d_p2 = p2;
 
-    if ( d_transformation->type() != QwtScaleTransformation::Other )
-        newFactor();
+    updateFactor();
 }
 
-/*!
-  \brief Re-calculate the conversion factor.
-*/
-void QwtScaleMap::newFactor()
+void QwtScaleMap::updateFactor()
 {
-    d_cnv = 0.0;
-    d_cnvInv = 0.0;
+    d_ts1 = d_s1;
+    double ts2 = d_s2;
 
-    switch ( d_transformation->type() )
+    if ( d_transform )
     {
-        case QwtScaleTransformation::Linear:
-        {
-            if ( d_s2 != d_s1 )
-                d_cnv = ( d_p2 - d_p1 ) / ( d_s2 - d_s1 );
-
-            if ( d_p2 != d_p1 )
-            {
-                d_cnvInv = ( d_s2 - d_s1 ) / ( d_p2 - d_p1 );
-            }
-
-            break;
-        }
-        case QwtScaleTransformation::Log10:
-        {
-            if ( d_s1 != 0 )
-                d_cnv = ( d_p2 - d_p1 ) / log( d_s2 / d_s1 );
-            break;
-        }
-        default:;
+        d_ts1 = d_transform->transform( d_ts1 );
+        ts2 = d_transform->transform( ts2 );
     }
+
+    d_cnv = 1.0;
+    if ( d_ts1 != ts2 )
+        d_cnv = ( d_p2 - d_p1 ) / ( ts2 - d_ts1 );
 }
 
 /*!
@@ -343,7 +237,7 @@
 QDebug operator<<( QDebug debug, const QwtScaleMap &map )
 {
     debug.nospace() << "QwtScaleMap("
-        << static_cast<int>( map.transformation()->type() )
+        << map.transformation()
         << ", s:" << map.s1() << "->" << map.s2()
         << ", p:" << map.p1() << "->" << map.p2()
         << ")";
Index: qwt_double_range.cpp
===================================================================
--- qwt_double_range.cpp	(revision 382)
+++ qwt_double_range.cpp	(working copy)
@@ -1,410 +0,0 @@
-/* -*- mode: C++ ; c-file-style: "stroustrup" -*- *****************************
- * Qwt Widget Library
- * Copyright (C) 1997   Josef Wilgen
- * Copyright (C) 2002   Uwe Rathmann
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the Qwt License, Version 1.0
- *****************************************************************************/
-
-#include "qwt_double_range.h"
-#include "qwt_math.h"
-
-#if QT_VERSION < 0x040601
-#define qFabs(x) ::fabs(x)
-#endif
-
-class QwtDoubleRange::PrivateData
-{       
-public: 
-    PrivateData():
-        minValue( 0.0 ),
-        maxValue( 0.0 ),
-        step( 1.0 ),
-        pageSize( 1 ),
-        isValid( false ),
-        value( 0.0 ),
-        exactValue( 0.0 ),
-        exactPrevValue( 0.0 ),
-        prevValue( 0.0 ),
-        periodic( false )
-    {
-    }
-
-    double minValue;
-    double maxValue;
-    double step;
-    int pageSize;
-
-    bool isValid;
-    double value;
-    double exactValue;
-    double exactPrevValue;
-    double prevValue;
-
-    bool periodic;
-};
-
-/*!
-  The range is initialized to [0.0, 100.0], the
-  step size to 1.0, and the value to 0.0.
-*/
-QwtDoubleRange::QwtDoubleRange()
-{
-    d_data = new PrivateData();
-}
-
-//! Destroys the QwtDoubleRange
-QwtDoubleRange::~QwtDoubleRange()
-{
-    delete d_data;
-}
-
-//! Set the value to be valid/invalid
-void QwtDoubleRange::setValid( bool isValid )
-{
-    if ( isValid != d_data->isValid )
-    {
-        d_data->isValid = isValid;
-        valueChange();
-    }
-}
-
-//! Indicates if the value is valid
-bool QwtDoubleRange::isValid() const
-{
-    return d_data->isValid;
-}
-
-void QwtDoubleRange::setNewValue( double value, bool align )
-{
-    d_data->prevValue = d_data->value;
-
-    const double vmin = qMin( d_data->minValue, d_data->maxValue );
-    const double vmax = qMax( d_data->minValue, d_data->maxValue );
-
-    if ( value < vmin )
-    {
-        if ( d_data->periodic && vmin != vmax )
-        {
-            d_data->value = value + 
-                ::ceil( ( vmin - value ) / ( vmax - vmin ) ) * ( vmax - vmin );
-        }
-        else
-            d_data->value = vmin;
-    }
-    else if ( value > vmax )
-    {
-        if ( ( d_data->periodic ) && ( vmin != vmax ) )
-        {
-            d_data->value = value - 
-                ::ceil( ( value - vmax ) / ( vmax - vmin ) ) * ( vmax - vmin );
-        }
-        else
-            d_data->value = vmax;
-    }
-    else
-    {
-        d_data->value = value;
-    }
-
-    d_data->exactPrevValue = d_data->exactValue;
-    d_data->exactValue = d_data->value;
-
-    if ( align )
-    {
-        if ( d_data->step != 0.0 )
-        {
-            d_data->value = d_data->minValue +
-                qRound( ( d_data->value - d_data->minValue ) / d_data->step ) * d_data->step;
-        }
-        else
-            d_data->value = d_data->minValue;
-
-        const double minEps = 1.0e-10;
-        // correct rounding error at the border
-        if ( qFabs( d_data->value - d_data->maxValue ) < minEps * qAbs( d_data->step ) )
-            d_data->value = d_data->maxValue;
-
-        // correct rounding error if value = 0
-        if ( qFabs( d_data->value ) < minEps * qAbs( d_data->step ) )
-            d_data->value = 0.0;
-    }
-
-    if ( !d_data->isValid || d_data->prevValue != d_data->value )
-    {
-        d_data->isValid = true;
-        valueChange();
-    }
-}
-
-/*!
-  \brief  Adjust the value to the closest point in the step raster.
-  \param x value
-  \warning The value is clipped when it lies outside the range.
-  When the range is QwtDoubleRange::periodic, it will
-  be mapped to a point in the interval such that
-  \verbatim new value := x + n * (max. value - min. value)\endverbatim
-  with an integer number n.
-*/
-void QwtDoubleRange::fitValue( double x )
-{
-    setNewValue( x, true );
-}
-
-
-/*!
-  \brief Set a new value without adjusting to the step raster
-  \param x new value
-  \warning The value is clipped when it lies outside the range.
-  When the range is QwtDoubleRange::periodic, it will
-  be mapped to a point in the interval such that
-  \verbatim new value := x + n * (max. value - min. value)\endverbatim
-  with an integer number n.
-*/
-void QwtDoubleRange::setValue( double x )
-{
-    setNewValue( x, false );
-}
-
-/*!
-  \brief Specify  range and step size
-
-  \param vmin   lower boundary of the interval
-  \param vmax   higher boundary of the interval
-  \param vstep  step width
-  \param pageSize  page size in steps
-  \warning
-  \li A change of the range changes the value if it lies outside the
-      new range. The current value
-      will *not* be adjusted to the new step raster.
-  \li vmax < vmin is allowed.
-  \li If the step size is left out or set to zero, it will be
-      set to 1/100 of the interval length.
-  \li If the step size has an absurd value, it will be corrected
-      to a better one.
-*/
-void QwtDoubleRange::setRange( 
-    double vmin, double vmax, double vstep, int pageSize )
-{
-    const bool rchg = ( d_data->maxValue != vmax || d_data->minValue != vmin );
-
-    if ( rchg )
-    {
-        d_data->minValue = vmin;
-        d_data->maxValue = vmax;
-    }
-
-    // look if the step width has an acceptable
-    // value or otherwise change it.
-    setStep( vstep );
-
-    // limit page size
-    const int max = 
-        int( qAbs( ( d_data->maxValue - d_data->minValue ) / d_data->step ) );
-    d_data->pageSize = qBound( 0, pageSize, max );
-
-    // If the value lies out of the range, it
-    // will be changed. Note that it will not be adjusted to
-    // the new step width.
-    setNewValue( d_data->value, false );
-
-    // call notifier after the step width has been
-    // adjusted.
-    if ( rchg )
-        rangeChange();
-}
-
-/*!
-  \brief Change the step raster
-  \param vstep new step width
-  \warning The value will \e not be adjusted to the new step raster.
-*/
-void QwtDoubleRange::setStep( double vstep )
-{
-    const double intv = d_data->maxValue - d_data->minValue;
-
-    double newStep;
-    if ( vstep == 0.0 )
-    {
-        const double defaultRelStep = 1.0e-2;
-        newStep = intv * defaultRelStep;
-    }
-    else
-    {
-        if ( ( intv > 0.0 && vstep < 0.0 ) || ( intv < 0.0 && vstep > 0.0 ) )
-            newStep = -vstep;
-        else
-            newStep = vstep;
-
-        const double minRelStep = 1.0e-10;
-        if ( qFabs( newStep ) < qFabs( minRelStep * intv ) )
-            newStep = minRelStep * intv;
-    }
-
-    if ( newStep != d_data->step )
-    {
-        d_data->step = newStep;
-        stepChange();
-    }
-}
-
-
-/*!
-  \brief Make the range periodic
-
-  When the range is periodic, the value will be set to a point
-  inside the interval such that
-
-  \verbatim point = value + n * width \endverbatim
-
-  if the user tries to set a new value which is outside the range.
-  If the range is nonperiodic (the default), values outside the
-  range will be clipped.
-
-  \param tf true for a periodic range
-*/
-void QwtDoubleRange::setPeriodic( bool tf )
-{
-    d_data->periodic = tf;
-}
-
-/*!
-  \brief Increment the value by a specified number of steps
-  \param nSteps Number of steps to increment
-  \warning As a result of this operation, the new value will always be
-       adjusted to the step raster.
-*/
-void QwtDoubleRange::incValue( int nSteps )
-{
-    if ( isValid() )
-        setNewValue( d_data->value + double( nSteps ) * d_data->step, true );
-}
-
-/*!
-  \brief Increment the value by a specified number of pages
-  \param nPages Number of pages to increment.
-        A negative number decrements the value.
-  \warning The Page size is specified in the constructor.
-*/
-void QwtDoubleRange::incPages( int nPages )
-{
-    if ( isValid() )
-    {
-        const double off = d_data->step * d_data->pageSize * nPages; 
-        setNewValue( d_data->value + off, true );
-    }
-}
-
-/*!
-  \brief Notify a change of value
-
-  This virtual function is called whenever the value changes.
-  The default implementation does nothing.
-*/
-void QwtDoubleRange::valueChange()
-{
-}
-
-
-/*!
-  \brief Notify a change of the range
-
-  This virtual function is called whenever the range changes.
-  The default implementation does nothing.
-*/
-void QwtDoubleRange::rangeChange()
-{
-}
-
-
-/*!
-  \brief Notify a change of the step size
-
-  This virtual function is called whenever the step size changes.
-  The default implementation does nothing.
-*/
-void QwtDoubleRange::stepChange()
-{
-}
-
-/*!
-  \return the step size
-  \sa setStep(), setRange()
-*/
-double QwtDoubleRange::step() const
-{
-    return qAbs( d_data->step );
-}
-
-/*!
-  \brief Returns the value of the second border of the range
-
-  maxValue returns the value which has been specified
-  as the second parameter in  QwtDoubleRange::setRange.
-
-  \sa setRange()
-*/
-double QwtDoubleRange::maxValue() const
-{
-    return d_data->maxValue;
-}
-
-/*!
-  \brief Returns the value at the first border of the range
-
-  minValue returns the value which has been specified
-  as the first parameter in  setRange().
-
-  \sa setRange()
-*/
-double QwtDoubleRange::minValue() const
-{
-    return d_data->minValue;
-}
-
-/*!
-  \brief Returns true if the range is periodic
-  \sa setPeriodic()
-*/
-bool QwtDoubleRange::periodic() const
-{
-    return d_data->periodic;
-}
-
-//! Returns the page size in steps.
-int QwtDoubleRange::pageSize() const
-{
-    return d_data->pageSize;
-}
-
-//! Returns the current value.
-double QwtDoubleRange::value() const
-{
-    return d_data->value;
-}
-
-/*!
-  \brief Returns the exact value
-
-  The exact value is the value which QwtDoubleRange::value would return
-  if the value were not adjusted to the step raster. It differs from
-  the current value only if fitValue() or incValue() have been used before. 
-  This function is intended for internal use in derived classes.
-*/
-double QwtDoubleRange::exactValue() const
-{
-    return d_data->exactValue;
-}
-
-//! Returns the exact previous value
-double QwtDoubleRange::exactPrevValue() const
-{
-    return d_data->exactPrevValue;
-}
-
-//! Returns the previous value
-double QwtDoubleRange::prevValue() const
-{
-    return d_data->prevValue;
-}
Index: qwt_null_paintdevice.h
===================================================================
--- qwt_null_paintdevice.h	(revision 382)
+++ qwt_null_paintdevice.h	(working copy)
@@ -18,11 +18,11 @@
   \brief A null paint device doing nothing
 
   Sometimes important layout/rendering geometries are not 
-  available or changable from the public Qt class interface. 
+  available or changeable from the public Qt class interface. 
   ( f.e hidden in the style implementation ).
 
   QwtNullPaintDevice can be used to manipulate or filter out 
-  these informations by analyzing the stream of paint primitives.
+  this information by analyzing the stream of paint primitives.
 
   F.e. QwtNullPaintDevice is used by QwtPlotCanvas to identify
   styled backgrounds with rounded corners.
@@ -112,6 +112,7 @@
     virtual void updateState( const QPaintEngineState &state );
 
 protected:
+    //! \return Size needed to implement metric()
     virtual QSize sizeMetrics() const = 0;
 
 private:
Index: qwt_spline.cpp
===================================================================
--- qwt_spline.cpp	(revision 382)
+++ qwt_spline.cpp	(working copy)
@@ -68,7 +68,7 @@
 
 /*!
    Copy constructor
-   \param other Spline used for initilization
+   \param other Spline used for initialization
 */
 QwtSpline::QwtSpline( const QwtSpline& other )
 {
@@ -77,7 +77,8 @@
 
 /*!
    Assignment operator
-   \param other Spline used for initilization
+   \param other Spline used for initialization
+   \return *this
 */
 QwtSpline &QwtSpline::operator=( const QwtSpline & other )
 {
@@ -152,7 +153,7 @@
 }
 
 /*!
-   Return points passed by setPoints
+   \return Points, that have been by setPoints()
 */
 QPolygonF QwtSpline::points() const
 {
@@ -196,6 +197,9 @@
 /*!
   Calculate the interpolated function value corresponding
   to a given argument x.
+
+  \param x Coordinate
+  \return Interpolated coordinate
 */
 double QwtSpline::value( double x ) const
 {
Index: qwt_point_polar.h
===================================================================
--- qwt_point_polar.h	(revision 382)
+++ qwt_point_polar.h	(working copy)
@@ -60,7 +60,7 @@
 
 /*!
     Constructs a null point, with a radius and azimuth set to 0.0.
-    \sa QPointF::isNull
+    \sa QPointF::isNull()
 */
 inline QwtPointPolar::QwtPointPolar():
     d_azimuth( 0.0 ),
Index: qwt_abstract_scale_draw.h
===================================================================
--- qwt_abstract_scale_draw.h	(revision 382)
+++ qwt_abstract_scale_draw.h	(working copy)
@@ -17,7 +17,7 @@
 class QPalette;
 class QPainter;
 class QFont;
-class QwtScaleTransformation;
+class QwtTransform;
 class QwtScaleMap;
 
 /*!
@@ -26,8 +26,7 @@
   QwtAbstractScaleDraw can be used to draw linear or logarithmic scales.
 
   After a scale division has been specified as a QwtScaleDiv object
-  using QwtAbstractScaleDraw::setScaleDiv(const QwtScaleDiv &s),
-  the scale can be drawn with the QwtAbstractScaleDraw::draw() member.
+  using setScaleDiv(), the scale can be drawn with the draw() member.
 */
 class QWT_EXPORT QwtAbstractScaleDraw
 {
@@ -58,7 +57,7 @@
     void setScaleDiv( const QwtScaleDiv &s );
     const QwtScaleDiv& scaleDiv() const;
 
-    void setTransformation( QwtScaleTransformation * );
+    void setTransformation( QwtTransform * );
     const QwtScaleMap &scaleMap() const;
     QwtScaleMap &scaleMap();
 
@@ -82,13 +81,16 @@
     /*!
       Calculate the extent
 
-      The extent is the distcance from the baseline to the outermost
+      The extent is the distance from the baseline to the outermost
       pixel of the scale draw in opposite to its orientation.
       It is at least minimumExtent() pixels.
 
+      \param font Font used for drawing the tick labels
+      \return Number of pixels
+
       \sa setMinimumExtent(), minimumExtent()
     */
-    virtual double extent( const QFont & ) const = 0;
+    virtual double extent( const QFont &font ) const = 0;
 
     void setMinimumExtent( double );
     double minimumExtent() const;
@@ -99,7 +101,7 @@
 
        \param painter Painter
        \param value Value of the tick
-       \param len Lenght of the tick
+       \param len Length of the tick
 
        \sa drawBackbone(), drawLabel()
     */
Index: qwt_scale_widget.h
===================================================================
--- qwt_scale_widget.h	(revision 382)
+++ qwt_scale_widget.h	(working copy)
@@ -19,7 +19,7 @@
 #include <qstring.h>
 
 class QPainter;
-class QwtScaleTransformation;
+class QwtTransform;
 class QwtScaleDiv;
 class QwtColorMap;
 
@@ -53,7 +53,7 @@
     virtual ~QwtScaleWidget();
 
 Q_SIGNALS:
-    //! Signal emitted, whenever the scale divison changes
+    //! Signal emitted, whenever the scale division changes
     void scaleDivChanged();
 
 public:
@@ -79,7 +79,8 @@
     void setSpacing( int td );
     int spacing() const;
 
-    void setScaleDiv( QwtScaleTransformation *, const QwtScaleDiv &sd );
+    void setScaleDiv( const QwtScaleDiv &sd );
+    void setTransformation( QwtTransform * );
 
     void setScaleDraw( QwtScaleDraw * );
     const QwtScaleDraw *scaleDraw() const;
Index: qwt_plot_histogram.h
===================================================================
--- qwt_plot_histogram.h	(revision 382)
+++ qwt_plot_histogram.h	(working copy)
@@ -32,6 +32,8 @@
         terms "image histogram" and "color histogram" to avoid confusions.
         While "image histograms" can be displayed by a QwtPlotCurve there
         is no applicable plot item for a "color histogram" yet.
+
+  \sa QwtPlotBarChart, QwtPlotMultiBarChart
 */
 
 class QWT_EXPORT QwtPlotHistogram: 
@@ -80,6 +82,7 @@
 
     virtual int rtti() const;
 
+    void setPen( const QColor &, qreal width = 0.0, Qt::PenStyle = Qt::SolidLine );
     void setPen( const QPen & );
     const QPen &pen() const;
 
@@ -87,6 +90,7 @@
     const QBrush &brush() const;
 
     void setSamples( const QVector<QwtIntervalSample> & );
+    void setSamples( QwtSeriesData<QwtIntervalSample> * );
 
     void setBaseline( double reference );
     double baseline() const;
Index: qwt_painter_command.cpp
===================================================================
--- qwt_painter_command.cpp	(revision 382)
+++ qwt_painter_command.cpp	(working copy)
@@ -9,17 +9,28 @@
 
 #include "qwt_painter_command.h"
 
+//! Construct an invalid command
 QwtPainterCommand::QwtPainterCommand():
     d_type( Invalid )
 {
 }
 
+//! Copy constructor
 QwtPainterCommand::QwtPainterCommand( const QPainterPath &path ):
     d_type( Path )
 {
     d_path = new QPainterPath( path );
 }
 
+/*!
+  Constructor for Pixmap paint operation
+
+  \param rect Target rectangle
+  \param pixmap Pixmap
+  \param subRect Rectangle inside the pixmap
+
+  \sa QPainter::drawPixmap()
+ */
 QwtPainterCommand::QwtPainterCommand( const QRectF &rect,
         const QPixmap &pixmap, const QRectF& subRect ):
     d_type( Pixmap )
@@ -30,6 +41,16 @@
     d_pixmapData->subRect = subRect;
 }
 
+/*!
+  Constructor for Image paint operation
+
+  \param rect Target rectangle
+  \param image Image
+  \param subRect Rectangle inside the image
+  \param flags Conversion flags
+
+  \sa QPainter::drawImage()
+ */
 QwtPainterCommand::QwtPainterCommand( const QRectF &rect,
         const QImage &image, const QRectF& subRect,
         Qt::ImageConversionFlags flags ):
@@ -42,6 +63,10 @@
     d_imageData->flags = flags;
 }
 
+/*! 
+  Constructor for State paint operation
+  \param state Paint engine state
+ */  
 QwtPainterCommand::QwtPainterCommand( const QPaintEngineState &state ):
     d_type( State )
 {
@@ -95,16 +120,28 @@
         d_stateData->opacity = state.opacity();
 }
 
+/*!
+  Copy constructor
+  \param other Command to be copied
+  
+ */
 QwtPainterCommand::QwtPainterCommand(const QwtPainterCommand &other)
 {
     copy( other );
 }
 
+//! Destructor
 QwtPainterCommand::~QwtPainterCommand()
 {
     reset();
 }
 
+/*!
+  Assignment operator
+
+  \param other Command to be copied
+  \return Modified command
+ */
 QwtPainterCommand &QwtPainterCommand::operator=(const QwtPainterCommand &other)
 {
     reset();
@@ -175,21 +212,25 @@
     d_type = Invalid;
 }
 
+//! \return Painter path to be painted
 QPainterPath *QwtPainterCommand::path() 
 {
     return d_path;
 }
 
+//! \return Attributes how to paint a QPixmap
 QwtPainterCommand::PixmapData* QwtPainterCommand::pixmapData() 
 {
     return d_pixmapData;
 }
 
+//! \return Attributes how to paint a QImage
 QwtPainterCommand::ImageData* QwtPainterCommand::imageData() 
 {
     return d_imageData;
 }
 
+//! \return Attributes of a state change
 QwtPainterCommand::StateData* QwtPainterCommand::stateData() 
 {
     return d_stateData;
Index: qwt_curve_fitter.cpp
===================================================================
--- qwt_curve_fitter.cpp	(revision 382)
+++ qwt_curve_fitter.cpp	(working copy)
@@ -246,11 +246,13 @@
 {
 public:
     PrivateData():
-        tolerance( 1.0 )
+        tolerance( 1.0 ),
+        chunkSize( 0 )
     {
     }
 
     double tolerance;
+    uint chunkSize;
 };
 
 class QwtWeedingCurveFitter::Line
@@ -287,7 +289,7 @@
 /*!
  Assign the tolerance
 
- The tolerance is the maximum distance, that is accaptable
+ The tolerance is the maximum distance, that is acceptable
  between the original curve and the smoothed curve.
 
  Increasing the tolerance will reduce the number of the
@@ -312,11 +314,63 @@
 }
 
 /*!
+ Limit the number of points passed to a run of the algorithm
+
+ The runtime of the Douglas Peucker algorithm increases non linear
+ with the number of points. For a chunk size > 0 the polygon
+ is split into pieces passed to the algorithm one by one.
+
+ \param numPoints Maximum for the number of points passed to the algorithm
+
+ \sa chunkSize()
+*/
+void QwtWeedingCurveFitter::setChunkSize( uint numPoints )
+{
+    if ( numPoints > 0 )
+        numPoints = qMax( numPoints, 3U );
+
+    d_data->chunkSize = numPoints;
+}
+
+/*!
+  
+  \return Maximum for the number of points passed to a run 
+          of the algorithm - or 0, when unlimited
+  \sa setChunkSize()
+*/
+uint QwtWeedingCurveFitter::chunkSize() const
+{
+    return d_data->chunkSize;
+}
+
+/*!
   \param points Series of data points
   \return Curve points
 */
 QPolygonF QwtWeedingCurveFitter::fitCurve( const QPolygonF &points ) const
 {
+    QPolygonF fittedPoints;
+
+    if ( d_data->chunkSize == 0 )
+    {
+        fittedPoints = simplify( points );
+    }
+    else
+    {
+        for ( int i = 0; i < points.size(); i += d_data->chunkSize )
+        {
+            const QPolygonF p = points.mid( i, d_data->chunkSize );
+            fittedPoints += simplify( p );
+        }
+    }
+
+    return fittedPoints;
+}
+
+QPolygonF QwtWeedingCurveFitter::simplify( const QPolygonF &points ) const
+{
+    const double toleranceSqr = d_data->tolerance * d_data->tolerance;
+
     QStack<Line> stack;
     stack.reserve( 500 );
 
@@ -325,8 +379,6 @@
 
     QVector<bool> usePoint( nPoints, false );
 
-    double distToSegment;
-
     stack.push( Line( 0, nPoints - 1 ) );
 
     while ( !stack.isEmpty() )
@@ -342,45 +394,43 @@
         const double unitVecX = ( vecLength != 0.0 ) ? vecX / vecLength : 0.0;
         const double unitVecY = ( vecLength != 0.0 ) ? vecY / vecLength : 0.0;
 
-        double maxDist = 0.0;
+        double maxDistSqr = 0.0;
         int nVertexIndexMaxDistance = r.from + 1;
         for ( int i = r.from + 1; i < r.to; i++ )
         {
             //compare to anchor
             const double fromVecX = p[i].x() - p[r.from].x();
             const double fromVecY = p[i].y() - p[r.from].y();
-            const double fromVecLength =
-                qSqrt( fromVecX * fromVecX + fromVecY * fromVecY );
 
+            double distToSegmentSqr;
             if ( fromVecX * unitVecX + fromVecY * unitVecY < 0.0 )
             {
-                distToSegment = fromVecLength;
+                distToSegmentSqr = fromVecX * fromVecX + fromVecY * fromVecY;
             }
-            if ( fromVecX * unitVecX + fromVecY * unitVecY < 0.0 )
-            {
-                distToSegment = fromVecLength;
-            }
             else
             {
                 const double toVecX = p[i].x() - p[r.to].x();
                 const double toVecY = p[i].y() - p[r.to].y();
-                const double toVecLength = qSqrt( toVecX * toVecX + toVecY * toVecY );
+                const double toVecLength = toVecX * toVecX + toVecY * toVecY;
+
                 const double s = toVecX * ( -unitVecX ) + toVecY * ( -unitVecY );
                 if ( s < 0.0 )
-                    distToSegment = toVecLength;
+                {
+                    distToSegmentSqr = toVecLength;
+                }
                 else
                 {
-                    distToSegment = qSqrt( qFabs( toVecLength * toVecLength - s * s ) );
+                    distToSegmentSqr = qFabs( toVecLength - s * s );
                 }
             }
 
-            if ( maxDist < distToSegment )
+            if ( maxDistSqr < distToSegmentSqr )
             {
-                maxDist = distToSegment;
+                maxDistSqr = distToSegmentSqr;
                 nVertexIndexMaxDistance = i;
             }
         }
-        if ( maxDist <= d_data->tolerance )
+        if ( maxDistSqr <= toleranceSqr )
         {
             usePoint[r.from] = true;
             usePoint[r.to] = true;
@@ -392,14 +442,12 @@
         }
     }
 
-    int cnt = 0;
-
-    QPolygonF stripped( nPoints );
+    QPolygonF stripped;
     for ( int i = 0; i < nPoints; i++ )
     {
         if ( usePoint[i] )
-            stripped[cnt++] = p[i];
+            stripped += p[i];
     }
-    stripped.resize( cnt );
+
     return stripped;
 }
Index: qwt_legend_label.h
===================================================================
--- qwt_legend_label.h	(revision 382)
+++ qwt_legend_label.h	(working copy)
@@ -19,7 +19,7 @@
 class QwtLegendData;
 
 /*!
-  \brief A widget representing something on a QwtLegend().
+  \brief A widget representing something on a QwtLegend.
 */
 class QWT_EXPORT QwtLegendLabel: public QwtTextLabel
 {
@@ -56,7 +56,7 @@
     //! Signal, when the legend item has been pressed
     void pressed();
 
-    //! Signal, when the legend item has been relased
+    //! Signal, when the legend item has been released
     void released();
 
     //! Signal, when the legend item has been toggled
Index: qwt_plot_axis.cpp
===================================================================
--- qwt_plot_axis.cpp	(revision 382)
+++ qwt_plot_axis.cpp	(working copy)
@@ -55,13 +55,21 @@
     d_axisData[xTop]->scaleWidget->setObjectName( "QwtPlotAxisXTop" );
     d_axisData[xBottom]->scaleWidget->setObjectName( "QwtPlotAxisXBottom" );
 
+#if 1
+    // better find the font sizes from the application font
     QFont fscl( fontInfo().family(), 10 );
     QFont fttl( fontInfo().family(), 12, QFont::Bold );
+#endif
 
     for ( axisId = 0; axisId < axisCnt; axisId++ )
     {
         AxisData &d = *d_axisData[axisId];
 
+        d.scaleEngine = new QwtLinearScaleEngine;
+
+        d.scaleWidget->setTransformation( 
+            d.scaleEngine->transformation() );
+
         d.scaleWidget->setFont( fscl );
         d.scaleWidget->setMargin( 2 );
 
@@ -78,7 +86,6 @@
         d.maxMinor = 5;
         d.maxMajor = 8;
 
-        d.scaleEngine = new QwtLinearScaleEngine;
 
         d.isValid = false;
     }
@@ -100,8 +107,8 @@
 }
 
 /*!
-  \return specified axis, or NULL if axisId is invalid.
-  \param axisId axis index
+  \return Scale widget of the specified axis, or NULL if axisId is invalid.
+  \param axisId Axis index
 */
 const QwtScaleWidget *QwtPlot::axisWidget( int axisId ) const
 {
@@ -112,8 +119,8 @@
 }
 
 /*!
-  \return specified axis, or NULL if axisId is invalid.
-  \param axisId axis index
+  \return Scale widget of the specified axis, or NULL if axisId is invalid.
+  \param axisId Axis index
 */
 QwtScaleWidget *QwtPlot::axisWidget( int axisId )
 {
@@ -124,9 +131,9 @@
 }
 
 /*!
-   Change the scale engine for an axis
+  Change the scale engine for an axis
 
-  \param axisId axis index
+  \param axisId Axis index
   \param scaleEngine Scale engine
 
   \sa axisScaleEngine()
@@ -140,6 +147,9 @@
         delete d.scaleEngine;
         d.scaleEngine = scaleEngine;
 
+        d_axisData[axisId]->scaleWidget->setTransformation( 
+            scaleEngine->transformation() );
+
         d.isValid = false;
 
         autoRefresh();
@@ -147,7 +157,7 @@
 }
 
 /*!
-  \param axisId axis index
+  \param axisId Axis index
   \return Scale engine for a specific axis
 */
 QwtScaleEngine *QwtPlot::axisScaleEngine( int axisId )
@@ -159,7 +169,7 @@
 }
 
 /*!
-  \param axisId axis index
+  \param axisId Axis index
   \return Scale engine for a specific axis
 */
 const QwtScaleEngine *QwtPlot::axisScaleEngine( int axisId ) const
@@ -170,8 +180,8 @@
         return NULL;
 }
 /*!
-  \return \c true if autoscaling is enabled
-  \param axisId axis index
+  \return \c True, if autoscaling is enabled
+  \param axisId Axis index
 */
 bool QwtPlot::axisAutoScale( int axisId ) const
 {
@@ -183,8 +193,8 @@
 }
 
 /*!
-  \return \c true if a specified axis is enabled
-  \param axisId axis index
+  \return \c True, if a specified axis is enabled
+  \param axisId Axis index
 */
 bool QwtPlot::axisEnabled( int axisId ) const
 {
@@ -195,8 +205,8 @@
 }
 
 /*!
-  \return the font of the scale labels for a specified axis
-  \param axisId axis index
+  \return The font of the scale labels for a specified axis
+  \param axisId Axis index
 */
 QFont QwtPlot::axisFont( int axisId ) const
 {
@@ -208,9 +218,9 @@
 }
 
 /*!
-  \return the maximum number of major ticks for a specified axis
-  \param axisId axis index
-  \sa setAxisMaxMajor()
+  \return The maximum number of major ticks for a specified axis
+  \param axisId Axis index
+  \sa setAxisMaxMajor(), QwtScaleEngine::divideScale()
 */
 int QwtPlot::axisMaxMajor( int axisId ) const
 {
@@ -222,8 +232,8 @@
 
 /*!
   \return the maximum number of minor ticks for a specified axis
-  \param axisId axis index
-  \sa setAxisMaxMinor()
+  \param axisId Axis index
+  \sa setAxisMaxMinor(), QwtScaleEngine::divideScale()
 */
 int QwtPlot::axisMaxMinor( int axisId ) const
 {
@@ -239,10 +249,10 @@
   axisScaleDiv(axisId).lowerBound(), axisScaleDiv(axisId).upperBound()
   are the current limits of the axis scale.
 
-  \param axisId axis index
+  \param axisId Axis index
   \return Scale division
 
-  \sa QwtScaleDiv, setAxisScaleDiv()
+  \sa QwtScaleDiv, setAxisScaleDiv(), QwtScaleEngine::divideScale()
 */
 const QwtScaleDiv &QwtPlot::axisScaleDiv( int axisId ) const
 {
@@ -250,10 +260,10 @@
 }
 
 /*!
-  \returns the scale draw of a specified axis
-  \param axisId axis index
-  \return specified scaleDraw for axis, or NULL if axis is invalid.
-  \sa QwtScaleDraw
+  \brief Return the scale draw of a specified axis
+
+  \param axisId Axis index
+  \return Specified scaleDraw for axis, or NULL if axis is invalid.
 */
 const QwtScaleDraw *QwtPlot::axisScaleDraw( int axisId ) const
 {
@@ -264,10 +274,10 @@
 }
 
 /*!
-  \returns the scale draw of a specified axis
-  \param axisId axis index
-  \return specified scaleDraw for axis, or NULL if axis is invalid.
-  \sa QwtScaleDraw
+  \brief Return the scale draw of a specified axis
+
+  \param axisId Axis index
+  \return Specified scaleDraw for axis, or NULL if axis is invalid.
 */
 QwtScaleDraw *QwtPlot::axisScaleDraw( int axisId )
 {
@@ -278,14 +288,14 @@
 }
 
 /*!
-   Return the step size parameter, that has been set
-   in setAxisScale. This doesn't need to be the step size
-   of the current scale.
+  \brief Return the step size parameter that has been set in setAxisScale. 
 
-  \param axisId axis index
+  This doesn't need to be the step size of the current scale.
+
+  \param axisId Axis index
   \return step size parameter value
 
-   \sa setAxisScale()
+   \sa setAxisScale(), QwtScaleEngine::divideScale()
 */
 double QwtPlot::axisStepSize( int axisId ) const
 {
@@ -300,7 +310,7 @@
 
   This is only a convenience function for axisScaleDiv( axisId )->interval();
   
-  \param axisId axis index
+  \param axisId Axis index
   \return Scale interval
 
   \sa QwtScaleDiv, axisScaleDiv()
@@ -314,8 +324,8 @@
 }
 
 /*!
-  \return the title of a specified axis
-  \param axisId axis index
+  \return Title of a specified axis
+  \param axisId Axis index
 */
 QwtText QwtPlot::axisTitle( int axisId ) const
 {
@@ -334,7 +344,8 @@
   into values works as normal.
 
   Only xBottom and yLeft are enabled by default.
-  \param axisId axis index
+
+  \param axisId Axis index
   \param tf \c true (enabled) or \c false (disabled)
 */
 void QwtPlot::enableAxis( int axisId, bool tf )
@@ -349,8 +360,12 @@
 /*!
   Transform the x or y coordinate of a position in the
   drawing region into a value.
-  \param axisId axis index
+
+  \param axisId Axis index
   \param pos position
+
+  \return Position as axis coordinate
+
   \warning The position can be an x or a y coordinate,
            depending on the specified axis.
 */
@@ -365,9 +380,10 @@
 
 /*!
   \brief Transform a value into a coordinate in the plotting region
-  \param axisId axis index
+
+  \param axisId Axis index
   \param value value
-  \return X or y coordinate in the plotting region corresponding
+  \return X or Y coordinate in the plotting region corresponding
           to the value.
 */
 double QwtPlot::transform( int axisId, double value ) const
@@ -380,15 +396,16 @@
 
 /*!
   \brief Change the font of an axis
-  \param axisId axis index
-  \param f font
+
+  \param axisId Axis index
+  \param font Font
   \warning This function changes the font of the tick labels,
            not of the axis title.
 */
-void QwtPlot::setAxisFont( int axisId, const QFont &f )
+void QwtPlot::setAxisFont( int axisId, const QFont &font )
 {
     if ( axisValid( axisId ) )
-        axisWidget( axisId )->setFont( f );
+        axisWidget( axisId )->setFont( font );
 }
 
 /*!
@@ -397,7 +414,7 @@
   This member function is used to switch back to autoscaling mode
   after a fixed scale has been set. Autoscaling is enabled by default.
 
-  \param axisId axis index
+  \param axisId Axis index
   \param on On/Off
   \sa setAxisScale(), setAxisScaleDiv(), updateAxes()
 
@@ -415,12 +432,18 @@
 
 /*!
   \brief Disable autoscaling and specify a fixed scale for a selected axis.
-  \param axisId axis index
-  \param min
-  \param max minimum and maximum of the scale
+
+  In updateAxes() the scale engine calculates a scale division from the 
+  specified parameters, that will be assigned to the scale widget. So 
+  updates of the scale widget usually happen delayed with the next replot.
+
+  \param axisId Axis index
+  \param min Minimum of the scale
+  \param max Maximum of the scale
   \param stepSize Major step size. If <code>step == 0</code>, the step size is
-            calculated automatically using the maxMajor setting.
-  \sa setAxisMaxMajor(), setAxisAutoScale(), axisStepSize()
+                  calculated automatically using the maxMajor setting.
+
+  \sa setAxisMaxMajor(), setAxisAutoScale(), axisStepSize(), QwtScaleEngine::divideScale()
 */
 void QwtPlot::setAxisScale( int axisId, double min, double max, double stepSize )
 {
@@ -441,8 +464,14 @@
 
 /*!
   \brief Disable autoscaling and specify a fixed scale for a selected axis.
-  \param axisId axis index
+
+  The scale division will be stored locally only until the next call
+  of updateAxes(). So updates of the scale widget usually happen delayed with 
+  the next replot.
+
+  \param axisId Axis index
   \param scaleDiv Scale division
+
   \sa setAxisScale(), setAxisAutoScale()
 */
 void QwtPlot::setAxisScaleDiv( int axisId, const QwtScaleDiv &scaleDiv )
@@ -461,9 +490,10 @@
 
 /*!
   \brief Set a scale draw
-  \param axisId axis index
-  \param scaleDraw object responsible for drawing scales.
 
+  \param axisId Axis index
+  \param scaleDraw Object responsible for drawing scales.
+
   By passing scaleDraw it is possible to extend QwtScaleDraw
   functionality and let it take place in QwtPlot. Please note
   that scaleDraw has to be created with new and will be deleted
@@ -485,8 +515,10 @@
 
 /*!
   Change the alignment of the tick labels
-  \param axisId axis index
+
+  \param axisId Axis index
   \param alignment Or'd Qt::AlignmentFlags see <qnamespace.h>
+
   \sa QwtScaleDraw::setLabelAlignment()
 */
 void QwtPlot::setAxisLabelAlignment( int axisId, Qt::Alignment alignment )
@@ -497,9 +529,11 @@
 
 /*!
   Rotate all tick labels
-  \param axisId axis index
+
+  \param axisId Axis index
   \param rotation Angle in degrees. When changing the label rotation,
                   the label alignment might be adjusted too.
+
   \sa QwtScaleDraw::setLabelRotation(), setAxisLabelAlignment()
 */
 void QwtPlot::setAxisLabelRotation( int axisId, double rotation )
@@ -511,8 +545,9 @@
 /*!
   Set the maximum number of minor scale intervals for a specified axis
 
-  \param axisId axis index
-  \param maxMinor maximum number of minor steps
+  \param axisId Axis index
+  \param maxMinor Maximum number of minor steps
+
   \sa axisMaxMinor()
 */
 void QwtPlot::setAxisMaxMinor( int axisId, int maxMinor )
@@ -534,8 +569,9 @@
 /*!
   Set the maximum number of major scale intervals for a specified axis
 
-  \param axisId axis index
-  \param maxMajor maximum number of major steps
+  \param axisId Axis index
+  \param maxMajor Maximum number of major steps
+
   \sa axisMaxMajor()
 */
 void QwtPlot::setAxisMaxMajor( int axisId, int maxMajor )
@@ -556,7 +592,8 @@
 
 /*!
   \brief Change the title of a specified axis
-  \param axisId axis index
+
+  \param axisId Axis index
   \param title axis title
 */
 void QwtPlot::setAxisTitle( int axisId, const QString &title )
@@ -567,8 +604,9 @@
 
 /*!
   \brief Change the title of a specified axis
-  \param axisId axis index
-  \param title axis title
+
+  \param axisId Axis index
+  \param title Axis title
 */
 void QwtPlot::setAxisTitle( int axisId, const QwtText &title )
 {
@@ -576,7 +614,30 @@
         axisWidget( axisId )->setTitle( title );
 }
 
-//! Rebuild the scales
+/*! 
+  \brief Rebuild the axes scales
+
+  In case of autoscaling the boundaries of a scale are calculated 
+  from the bounding rectangles of all plot items, having the 
+  QwtPlotItem::AutoScale flag enabled ( QwtScaleEngine::autoScale() ). 
+  Then a scale division is calculated ( QwtScaleEngine::didvideScale() ) 
+  and assigned to scale widget.
+
+  When the scale boundaries have been assigned with setAxisScale() a 
+  scale division is calculated ( QwtScaleEngine::didvideScale() )
+  for this interval and assigned to the scale widget.
+
+  When the scale has been set explicitly by setAxisScaleDiv() the 
+  locally stored scale division gets assigned to the scale widget.
+
+  The scale widget indicates modifications by emitting a 
+  QwtScaleWidget::scaleDivChanged() signal.
+
+  updateAxes() is usually called by replot(). 
+
+  \sa setAxisAutoScale(), setAxisScale(), setAxisScaleDiv(), replot()
+      QwtPlotItem::boundingRect()
+ */
 void QwtPlot::updateAxes()
 {
     // Find bounding interval of the item data
@@ -600,8 +661,12 @@
         if ( axisAutoScale( item->xAxis() ) || axisAutoScale( item->yAxis() ) )
         {
             const QRectF rect = item->boundingRect();
-            intv[item->xAxis()] |= QwtInterval( rect.left(), rect.right() );
-            intv[item->yAxis()] |= QwtInterval( rect.top(), rect.bottom() );
+
+            if ( rect.width() >= 0.0 )
+                intv[item->xAxis()] |= QwtInterval( rect.left(), rect.right() );
+
+            if ( rect.height() >= 0.0 )
+                intv[item->yAxis()] |= QwtInterval( rect.top(), rect.bottom() );
         }
     }
 
@@ -634,8 +699,7 @@
         }
 
         QwtScaleWidget *scaleWidget = axisWidget( axisId );
-        scaleWidget->setScaleDiv(
-            d.scaleEngine->transformation(), d.scaleDiv );
+        scaleWidget->setScaleDiv( d.scaleDiv );
 
         int startDist, endDist;
         scaleWidget->getBorderDistHint( startDist, endDist );
Index: qwt_legend.h
===================================================================
--- qwt_legend.h	(revision 382)
+++ qwt_legend.h	(working copy)
@@ -12,6 +12,7 @@
 
 #include "qwt_global.h"
 #include "qwt_abstract_legend.h"
+#include <qvariant.h>
 
 class QScrollBar;
 
@@ -22,7 +23,7 @@
   items might be any type of widget, but in general they will be
   a QwtLegendLabel.
 
-  \sa QwtLegendLabel, QwtPlotItem QwtPlot
+  \sa QwtLegendLabel, QwtPlotItem, QwtPlot
 */
 
 class QWT_EXPORT QwtLegend : public QwtAbstractLegend
@@ -42,9 +43,11 @@
     QWidget *contentsWidget();
     const QWidget *contentsWidget() const;
 
-    QWidget * legendWidget( const QwtPlotItem *item ) const;
-    QList<QWidget *> legendWidgets( const QwtPlotItem *item ) const;
+    QWidget *legendWidget( const QVariant &  ) const;
+    QList<QWidget *> legendWidgets( const QVariant & ) const;
 
+    QVariant itemInfo( const QWidget * ) const;
+
     virtual bool eventFilter( QObject *, QEvent * );
 
     virtual QSize sizeHint() const;
@@ -67,33 +70,33 @@
       A signal which is emitted when the user has clicked on
       a legend label, which is in QwtLegendData::Clickable mode.
 
-      \param plotItem Corresponding plot item of the
+      \param itemInfo Info for the item item of the
                       selected legend item
       \param index Index of the legend label in the list of widgets
                    that are associated with the plot item
 
       \note clicks are disabled as default
-      \sa setDefaultItemMode(), defaultItemMode()
+      \sa setDefaultItemMode(), defaultItemMode(), QwtPlot::itemToInfo()
      */
-    void clicked( QwtPlotItem *plotItem, int index );
+    void clicked( const QVariant &itemInfo, int index );
 
     /*!
       A signal which is emitted when the user has clicked on
       a legend label, which is in QwtLegendData::Checkable mode
 
-      \param plotItem Corresponding plot item of the
+      \param itemInfo Info for the item of the
                       selected legend label
       \param index Index of the legend label in the list of widgets
                    that are associated with the plot item
       \param on True when the legend label is checked
 
       \note clicks are disabled as default
-      \sa setDefaultItemMode(), defaultItemMode()
+      \sa setDefaultItemMode(), defaultItemMode(), QwtPlot::itemToInfo()
      */
-    void checked( QwtPlotItem *plotItem, bool on, int index );
+    void checked( const QVariant &itemInfo, bool on, int index );
 
 public Q_SLOTS:
-    virtual void updateLegend( const QwtPlotItem *, 
+    virtual void updateLegend( const QVariant &,
         const QList<QwtLegendData> & );
 
 protected Q_SLOTS:
@@ -104,10 +107,8 @@
     virtual QWidget *createWidget( const QwtLegendData & ) const;
     virtual void updateWidget( QWidget *widget, const QwtLegendData &data );
 
-    virtual void layoutContents();
-
 private:
-    void updateLayout();
+    void updateTabOrder();
 
     class PrivateData;
     PrivateData *d_data;
Index: qwt_thermo.h
===================================================================
--- qwt_thermo.h	(revision 382)
+++ qwt_thermo.h	(working copy)
@@ -13,7 +13,6 @@
 #include "qwt_global.h"
 #include "qwt_abstract_scale.h"
 #include "qwt_interval.h"
-#include <qwidget.h>
 
 class QwtScaleDraw;
 class QwtColorMap;
@@ -43,95 +42,72 @@
     For the axis of the scale
   - QPalette::Text
     For the labels of the scale
-
-  By default, the scale and range run over the same interval of values.
-  QwtAbstractScale::setScale() changes the interval of the scale and allows
-  easy conversion between physical units.
-
-  The example shows how to make the scale indicate in degrees Fahrenheit and
-  to set the value in degrees Kelvin:
-\code
-#include <qapplication.h>
-#include <qwt_thermo.h>
-
-double Kelvin2Fahrenheit(double kelvin)
-{
-    // see http://en.wikipedia.org/wiki/Kelvin
-    return 1.8*kelvin - 459.67;
-}
-
-int main(int argc, char **argv)
-{
-    const double minKelvin = 0.0;
-    const double maxKelvin = 500.0;
-
-    QApplication a(argc, argv);
-    QwtThermo t;
-    t.setRange(minKelvin, maxKelvin);
-    t.setScale(Kelvin2Fahrenheit(minKelvin), Kelvin2Fahrenheit(maxKelvin));
-    // set the value in Kelvin but the scale displays in Fahrenheit
-    // 273.15 Kelvin = 0 Celsius = 32 Fahrenheit
-    t.setValue(273.15);
-    a.setMainWidget(&t);
-    t.show();
-    return a.exec();
-}
-\endcode
-
-  \todo Improve the support for a logarithmic range and/or scale.
 */
-class QWT_EXPORT QwtThermo: public QWidget, public QwtAbstractScale
+class QWT_EXPORT QwtThermo: public QwtAbstractScale
 {
     Q_OBJECT
 
     Q_ENUMS( ScalePos )
+    Q_ENUMS( OriginMode )
 
+    Q_PROPERTY( Qt::Orientation orientation
+        READ orientation WRITE setOrientation )
+    Q_PROPERTY( ScalePosition scalePosition 
+        READ scalePosition WRITE setScalePosition )
+    Q_PROPERTY( OriginMode originMode READ originMode WRITE setOriginMode )
+
     Q_PROPERTY( bool alarmEnabled READ alarmEnabled WRITE setAlarmEnabled )
     Q_PROPERTY( double alarmLevel READ alarmLevel WRITE setAlarmLevel )
-    Q_PROPERTY( ScalePos scalePosition READ scalePosition
-        WRITE setScalePosition )
+    Q_PROPERTY( double origin READ origin WRITE setOrigin )
     Q_PROPERTY( int spacing READ spacing WRITE setSpacing )
     Q_PROPERTY( int borderWidth READ borderWidth WRITE setBorderWidth )
-    Q_PROPERTY( double maxValue READ maxValue WRITE setMaxValue )
-    Q_PROPERTY( double minValue READ minValue WRITE setMinValue )
     Q_PROPERTY( int pipeWidth READ pipeWidth WRITE setPipeWidth )
     Q_PROPERTY( double value READ value WRITE setValue )
 
 public:
-    /*!
-      Scale position. QwtThermo tries to enforce valid combinations of its
-      orientation and scale position:
 
-      - Qt::Horizonal combines with NoScale, TopScale and BottomScale
-      - Qt::Vertical combines with NoScale, LeftScale and RightScale
-
-      \sa setOrientation(), setScalePosition()
-    */
-    enum ScalePos
+    /*!
+      Position of the scale
+      \sa setScalePosition(), setOrientation()
+     */
+    enum ScalePosition
     {
-        //! No scale
+        //! The slider has no scale
         NoScale,
 
-        //! The scale is left of the pipe
-        LeftScale,
+        //! The scale is right of a vertical or below of a horizontal slider
+        LeadingScale,
 
-        //! The scale is right of the pipe
-        RightScale,
+        //! The scale is left of a vertical or above of a horizontal slider
+        TrailingScale
+    };
 
-        //! The scale is above the pipe
-        TopScale,
+    /*!
+      Origin mode. This property specifies where the beginning of the liquid
+      is placed.
 
-        //! The scale is below the pipe
-        BottomScale
+      \sa setOriginMode(), setOrigin()
+    */
+    enum OriginMode
+    {
+        //! The origin is the minimum of the scale
+        OriginMinimum,
+
+        //! The origin is the maximum of the scale
+        OriginMaximum,
+
+        //! The origin is specified using the origin() property
+        OriginCustom
     };
 
     explicit QwtThermo( QWidget *parent = NULL );
     virtual ~QwtThermo();
 
-    void setOrientation( Qt::Orientation, ScalePos );
+    void setOrientation( Qt::Orientation );
+    Qt::Orientation orientation() const;
 
-    void setScalePosition( ScalePos s );
-    ScalePos scalePosition() const;
+    void setScalePosition( ScalePosition );
+    ScalePosition scalePosition() const;
 
     void setSpacing( int );
     int spacing() const;
@@ -139,11 +115,17 @@
     void setBorderWidth( int w );
     int borderWidth() const;
 
+    void setOriginMode( OriginMode );
+    OriginMode originMode() const;
+
+    void setOrigin( double );
+    double origin() const;
+
     void setFillBrush( const QBrush &b );
-    const QBrush &fillBrush() const;
+    QBrush fillBrush() const;
 
     void setAlarmBrush( const QBrush &b );
-    const QBrush &alarmBrush() const;
+    QBrush alarmBrush() const;
 
     void setAlarmLevel( double v );
     double alarmLevel() const;
@@ -161,16 +143,8 @@
     void setRangeFlags( QwtInterval::BorderFlags );
     QwtInterval::BorderFlags rangeFlags() const;
 
-    void setMaxValue( double v );
-    double maxValue() const;
-
-    void setMinValue( double v );
-    double minValue() const;
-
     double value() const;
 
-    void setRange( double vmin, double vmax, bool lg = false );
-
     virtual QSize sizeHint() const;
     virtual QSize minimumSizeHint() const;
 
@@ -191,6 +165,8 @@
     QwtScaleDraw *scaleDraw();
 
     QRect pipeRect() const;
+    QRect fillRect( const QRect & ) const;
+    QRect alarmRect( const QRect & ) const;
 
 private:
     void layoutThermo( bool );
Index: qwt_plot_magnifier.h
===================================================================
--- qwt_plot_magnifier.h	(revision 382)
+++ qwt_plot_magnifier.h	(working copy)
@@ -13,7 +13,6 @@
 #include "qwt_global.h"
 #include "qwt_magnifier.h"
 
-class QwtPlotCanvas;
 class QwtPlot;
 
 /*!
@@ -32,14 +31,14 @@
     Q_OBJECT
 
 public:
-    explicit QwtPlotMagnifier( QwtPlotCanvas * );
+    explicit QwtPlotMagnifier( QWidget * );
     virtual ~QwtPlotMagnifier();
 
     void setAxisEnabled( int axis, bool on );
     bool isAxisEnabled( int axis ) const;
 
-    QwtPlotCanvas *canvas();
-    const QwtPlotCanvas *canvas() const;
+    QWidget *canvas();
+    const QWidget *canvas() const;
 
     QwtPlot *plot();
     const QwtPlot *plot() const;
Index: qwt_sampling_thread.h
===================================================================
--- qwt_sampling_thread.h	(revision 382)
+++ qwt_sampling_thread.h	(working copy)
@@ -7,11 +7,11 @@
 /*!
   \brief A thread collecting samples at regular intervals.
 
-  Contiounous signals are converted into a discrete signal by
+  Continuous signals are converted into a discrete signal by
   collecting samples at regular intervals. A discrete signal
   can be displayed by a QwtPlotSeriesItem on a QwtPlot widget.
 
-  QwtSamplingThread starts a thread calling perodically sample(),
+  QwtSamplingThread starts a thread calling periodically sample(),
   to collect and store ( or emit ) a single sample.
 
   \sa QwtPlotCurve, QwtPlotSeriesItem
@@ -38,7 +38,7 @@
     /*!
        Collect a sample
 
-       \param elapsed Time since the thread was started in miliseconds
+       \param elapsed Time since the thread was started in milliseconds
      */
     virtual void sample( double elapsed ) = 0;
 
Index: qwt_samples.h
===================================================================
--- qwt_samples.h	(revision 382)
+++ qwt_samples.h	(working copy)
@@ -124,7 +124,7 @@
     return !( *this == other );
 }
 
-// \return All values of the set added
+//! \return All values of the set added
 inline double QwtSetSample::added() const
 {
     double y = 0.0;
@@ -218,6 +218,7 @@
 
    For valid samples the limits of this interval are always low/high.
 
+   \return Bounding interval
    \sa isValid()
  */
 inline QwtInterval QwtOHLCSample::boundingInterval() const
Index: qwt_scale_draw.h
===================================================================
--- qwt_scale_draw.h	(revision 382)
+++ qwt_scale_draw.h	(working copy)
@@ -28,7 +28,6 @@
   using QwtAbstractScaleDraw::setScaleDiv(const QwtScaleDiv &s),
   the scale can be drawn with the QwtAbstractScaleDraw::draw() member.
 */
-
 class QWT_EXPORT QwtScaleDraw: public QwtAbstractScaleDraw
 {
 public:
@@ -107,6 +106,10 @@
 
 /*!
    Move the position of the scale
+
+   \param x X coordinate
+   \param y Y coordinate
+
    \sa move(const QPointF &)
 */
 inline void QwtScaleDraw::move( double x, double y )
Index: qwt_compass.h
===================================================================
--- qwt_compass.h	(revision 382)
+++ qwt_compass.h	(working copy)
@@ -12,12 +12,38 @@
 
 #include "qwt_global.h"
 #include "qwt_dial.h"
+#include "qwt_round_scale_draw.h"
 #include <qstring.h>
 #include <qmap.h>
 
 class QwtCompassRose;
 
 /*!
+  \brief A special scale draw made for QwtCompass
+
+  QwtCompassScaleDraw maps values to strings using
+  a special map, that can be modified by the application
+
+  The default map consists of the labels N, NE, E, SE, S, SW, W, NW.
+
+  \sa QwtCompass
+*/
+class QWT_EXPORT QwtCompassScaleDraw: public QwtRoundScaleDraw
+{
+public:
+    explicit QwtCompassScaleDraw();
+    explicit QwtCompassScaleDraw( const QMap<double, QString> &map );
+
+    void setLabelMap( const QMap<double, QString> &map );
+    QMap<double, QString> labelMap() const;
+
+    virtual QwtText label( double value ) const;
+
+private:
+    QMap<double, QString> d_labelMap;
+};
+
+/*!
   \brief A Compass Widget
 
   QwtCompass is a widget to display and enter directions. It consists
@@ -40,13 +66,7 @@
     const QwtCompassRose *rose() const;
     QwtCompassRose *rose();
 
-    const QMap<double, QString> &labelMap() const;
-    QMap<double, QString> &labelMap();
-    void setLabelMap( const QMap<double, QString> &map );
-
 protected:
-    virtual QwtText scaleLabel( double value ) const;
-
     virtual void drawRose( QPainter *, const QPointF &center,
         double radius, double north, QPalette::ColorGroup ) const;
 
@@ -56,8 +76,6 @@
     virtual void keyPressEvent( QKeyEvent * );
 
 private:
-    void initCompass();
-
     class PrivateData;
     PrivateData *d_data;
 };
Index: qwt_scale_engine.cpp
===================================================================
--- qwt_scale_engine.cpp	(revision 382)
+++ qwt_scale_engine.cpp	(working copy)
@@ -19,14 +19,94 @@
 #define qExp(x) ::exp(x)
 #endif
 
+static inline double qwtLog( double base, double value )
+{
+    return log( value ) / log( base );
+}
+
+static inline QwtInterval qwtLogInterval( double base, const QwtInterval &interval )
+{
+    return QwtInterval( qwtLog( base, interval.minValue() ),
+            qwtLog( base, interval.maxValue() ) );
+}
+
+static inline QwtInterval qwtPowInterval( double base, const QwtInterval &interval ) 
+{
+    return QwtInterval( qPow( base, interval.minValue() ),
+            qPow( base, interval.maxValue() ) );
+}
+
+
+#if 1
+
+// this version often doesn't find the best ticks: f.e for 15: 5, 10
+static double qwtStepSize( double intervalSize, int maxSteps, uint base )
+{
+    const double minStep = 
+        QwtScaleArithmetic::divideInterval( intervalSize, maxSteps, base );
+
+    if ( minStep != 0.0 )
+    {
+        // # ticks per interval
+        const int numTicks = qCeil( qAbs( intervalSize / minStep ) ) - 1;
+
+        // Do the minor steps fit into the interval?
+        if ( qwtFuzzyCompare( ( numTicks +  1 ) * qAbs( minStep ),
+            qAbs( intervalSize ), intervalSize ) > 0 )
+        {
+            // The minor steps doesn't fit into the interval
+            return 0.5 * intervalSize;
+        }
+    }
+
+    return minStep;
+}
+
+#else
+
+static double qwtStepSize( double intervalSize, int maxSteps, uint base )
+{
+    if ( maxSteps <= 0 )
+        return 0.0;
+
+    if ( maxSteps > 2 )
+    {
+        for ( int numSteps = maxSteps; numSteps > 1; numSteps-- )
+        {
+            const double stepSize = intervalSize / numSteps;
+
+            const double p = ::floor( ::log( stepSize ) / ::log( base ) );
+            const double fraction = qPow( base, p );
+
+            for ( uint n = base; n > 1; n /= 2 )
+            {
+                if ( qFuzzyCompare( stepSize, n * fraction ) )
+                    return stepSize;
+
+                if ( n == 3 && ( base % 2 ) == 0 )
+                {
+                    if ( qFuzzyCompare( stepSize, 2 * fraction ) )
+                        return stepSize;
+                }
+            }
+        }
+    }
+
+    return intervalSize * 0.5;
+}
+
+#endif
+
 static const double _eps = 1.0e-6;
 
 /*!
   Ceil a value, relative to an interval
 
-  \param value Value to ceil
+  \param value Value to be ceiled
   \param intervalSize Interval size
 
+  \return Rounded value
+
   \sa floorEps()
 */
 double QwtScaleArithmetic::ceilEps( double value,
@@ -41,9 +121,10 @@
 /*!
   Floor a value, relative to an interval
 
-  \param value Value to floor
+  \param value Value to be floored
   \param intervalSize Interval size
 
+  \return Rounded value
   \sa floorEps()
 */
 double QwtScaleArithmetic::floorEps( double value, double intervalSize )
@@ -72,59 +153,38 @@
 }
 
 /*!
-  Find the smallest value out of {1,2,5}*10^n with an integer number n
-  which is greater than or equal to x
+  Calculate a step size for a given interval
 
-  \param x Input value
-*/
-double QwtScaleArithmetic::ceil125( double x )
+  \param intervalSize Interval size
+  \param numSteps Number of steps
+  \param base Base for the division ( usually 10 )
+
+  \return Calculated step size
+ */
+double QwtScaleArithmetic::divideInterval( 
+    double intervalSize, int numSteps, uint base ) 
 {
-    if ( x == 0.0 )
+    if ( numSteps <= 0 )
         return 0.0;
 
-    const double sign = ( x > 0 ) ? 1.0 : -1.0;
-    const double lx = ::log10( qFabs( x ) );
-    const double p10 = ::floor( lx );
+    const double v = QwtScaleArithmetic::divideEps( intervalSize, numSteps );
+    if ( v == 0.0 )
+        return 0.0;
 
-    double fr = qPow( 10.0, lx - p10 );
-    if ( fr <= 1.0 )
-        fr = 1.0;
-    else if ( fr <= 2.0 )
-        fr = 2.0;
-    else if ( fr <= 5.0 )
-        fr = 5.0;
-    else
-        fr = 10.0;
+    const double lx = qwtLog( base, qFabs( v ) );
+    const double p = ::floor( lx );
 
-    return sign * fr * qPow( 10.0, p10 );
-}
+    const double fraction = qPow( base, lx - p );
 
-/*!
-  \brief Find the largest value out of {1,2,5}*10^n with an integer number n
-  which is smaller than or equal to x
+    uint n = base;
+    while ( ( n > 1 ) && ( fraction <= n / 2 ) )
+        n /= 2;
 
-  \param x Input value
-*/
-double QwtScaleArithmetic::floor125( double x )
-{
-    if ( x == 0.0 )
-        return 0.0;
+    double stepSize = n * qPow( base, p );
+    if ( v < 0 )
+        stepSize = -stepSize;
 
-    double sign = ( x > 0 ) ? 1.0 : -1.0;
-    const double lx = ::log10( qFabs( x ) );
-    const double p10 = ::floor( lx );
-
-    double fr = qPow( 10.0, lx - p10 );
-    if ( fr >= 10.0 )
-        fr = 10.0;
-    else if ( fr >= 5.0 )
-        fr = 5.0;
-    else if ( fr >= 2.0 )
-        fr = 2.0;
-    else
-        fr = 1.0;
-
-    return sign * fr * qPow( 10.0, p10 );
+    return stepSize;
 }
 
 class QwtScaleEngine::PrivateData
@@ -134,23 +194,39 @@
         attributes( QwtScaleEngine::NoAttribute ),
         lowerMargin( 0.0 ),
         upperMargin( 0.0 ),
-        referenceValue( 0.0 )
+        referenceValue( 0.0 ),
+        base( 10 ),
+        transform( NULL )
     {
     }
 
-    QwtScaleEngine::Attributes attributes;       // scale attributes
+    ~PrivateData()
+    {
+        delete transform;
+    }
 
-    double lowerMargin;      // margins
+    QwtScaleEngine::Attributes attributes;
+
+    double lowerMargin;
     double upperMargin;
 
-    double referenceValue; // reference value
+    double referenceValue;
 
+    uint base;
+
+    QwtTransform* transform;
 };
 
-//! Constructor
-QwtScaleEngine::QwtScaleEngine()
+/*!
+  Constructor
+
+  \param base Base of the scale engine
+  \sa setBase()
+ */
+QwtScaleEngine::QwtScaleEngine( uint base )
 {
     d_data = new PrivateData;
+    setBase( base );
 }
 
 
@@ -161,6 +237,45 @@
 }
 
 /*!
+   Assign a transformation
+
+   \param transform Transformation
+
+   The transformation object is used as factory for clones
+   that are returned by transformation()
+
+   The scale engine takes ownership of the transformation.
+
+   \sa QwtTransform::copy(), transformation()
+
+ */
+void QwtScaleEngine::setTransformation( QwtTransform *transform )
+{
+    if ( transform != d_data->transform )
+    {
+        delete d_data->transform;
+        d_data->transform = transform;
+    }
+}
+
+/*!
+   Create and return a clone of the transformation 
+   of the engine. When the engine has no special transformation
+   NULL is returned, indicating no transformation.
+
+   \return A clone of the transfomation
+   \sa setTransformation()
+ */
+QwtTransform *QwtScaleEngine::transformation() const
+{
+    QwtTransform *transform = NULL;
+    if ( d_data->transform )
+        transform = d_data->transform->copy();
+
+    return transform;
+}
+
+/*!
     \return the margin at the lower end of the scale
     The default margin is 0.
 
@@ -193,7 +308,7 @@
   the enclosed intervals and the boundaries of the scale.
 
   \warning
-  \li QwtLog10ScaleEngine measures the margins in decades.
+  \li QwtLogScaleEngine measures the margins in decades.
 
   \sa upperMargin(), lowerMargin()
 */
@@ -215,11 +330,8 @@
 double QwtScaleEngine::divideInterval(
     double intervalSize, int numSteps ) const
 {
-    if ( numSteps <= 0 )
-        return 0.0;
-
-    double v = QwtScaleArithmetic::divideEps( intervalSize, numSteps );
-    return QwtScaleArithmetic::ceil125( v );
+    return QwtScaleArithmetic::divideInterval( 
+        intervalSize, numSteps, d_data->base );
 }
 
 /*!
@@ -228,7 +340,7 @@
   \param interval Interval
   \param value Value
 
-  \sa QwtScaleArithmetic::compareEps()
+  \return True, when the value is inside the interval
 */
 bool QwtScaleEngine::contains(
     const QwtInterval &interval, double value ) const
@@ -275,23 +387,26 @@
 }
 
 /*!
-  \brief Build an interval for a value
+  \brief Build an interval around a value
 
   In case of v == 0.0 the interval is [-0.5, 0.5],
   otherwide it is [0.5 * v, 1.5 * v]
+
+  \param value Initial value
+  \return Calculated interval
 */
 
-QwtInterval QwtScaleEngine::buildInterval( double v ) const
+QwtInterval QwtScaleEngine::buildInterval( double value ) const
 {
-    const double delta = ( v == 0.0 ) ? 0.5 : qAbs( 0.5 * v );
+    const double delta = ( value == 0.0 ) ? 0.5 : qAbs( 0.5 * value );
 
-    if ( DBL_MAX - delta < v )
+    if ( DBL_MAX - delta < value )
         return QwtInterval( DBL_MAX - delta, DBL_MAX );
 
-    if ( -DBL_MAX + delta > v )
+    if ( -DBL_MAX + delta > value )
         return QwtInterval( -DBL_MAX, -DBL_MAX + delta );
 
-    return QwtInterval( v - delta, v + delta );
+    return QwtInterval( value - delta, value + delta );
 }
 
 /*!
@@ -311,7 +426,7 @@
 }
 
 /*!
-  Check if a attribute is set.
+  \return True, if attribute is enabled.
 
   \param attribute Attribute to be tested
   \sa Attribute, setAttribute()
@@ -333,7 +448,7 @@
 }
 
 /*!
-  Return the scale attributes
+  \return Scale attributes
   \sa Attribute, setAttributes(), testAttribute()
 */
 QwtScaleEngine::Attributes QwtScaleEngine::attributes() const
@@ -356,8 +471,8 @@
 }
 
 /*!
- \return the reference value
- \sa setReference(), setAttribute()
+  \return the reference value
+  \sa setReference(), setAttribute()
 */
 double QwtScaleEngine::reference() const
 {
@@ -365,22 +480,56 @@
 }
 
 /*!
-  Return a transformation, for linear scales
-*/
-QwtScaleTransformation *QwtLinearScaleEngine::transformation() const
+  Set the base of the scale engine
+
+  While a base of 10 is what 99.9% of all applications need
+  certain scales might need a different base: f.e 2
+
+  The default setting is 10
+
+  \param base Base of the engine
+
+  \sa base()
+ */
+void QwtScaleEngine::setBase( uint base )
+{ 
+    d_data->base = qMax( base, 2U );
+}
+
+/*!
+  \return base Base of the scale engine
+  \sa setBase()
+ */
+uint QwtScaleEngine::base() const
 {
-    return new QwtScaleTransformation( QwtScaleTransformation::Linear );
+    return d_data->base;
 }
 
 /*!
-    Align and divide an interval
+  Constructor
 
-   \param maxNumSteps Max. number of steps
-   \param x1 First limit of the interval (In/Out)
-   \param x2 Second limit of the interval (In/Out)
-   \param stepSize Step size (Out)
+  \param base Base of the scale engine
+  \sa setBase()
+ */
+QwtLinearScaleEngine::QwtLinearScaleEngine( uint base ):
+    QwtScaleEngine( base )
+{
+}
 
-   \sa setAttribute()
+//! Destructor
+QwtLinearScaleEngine::~QwtLinearScaleEngine()
+{
+}
+
+/*!
+  Align and divide an interval
+
+  \param maxNumSteps Max. number of steps
+  \param x1 First limit of the interval (In/Out)
+  \param x2 Second limit of the interval (In/Out)
+  \param stepSize Step size (Out)
+
+  \sa setAttribute()
 */
 void QwtLinearScaleEngine::autoScale( int maxNumSteps,
     double &x1, double &x2, double &stepSize ) const
@@ -400,7 +549,8 @@
     if ( interval.width() == 0.0 )
         interval = buildInterval( interval.minValue() );
 
-    stepSize = divideInterval( interval.width(), qMax( maxNumSteps, 1 ) );
+    stepSize = QwtScaleArithmetic::divideInterval( 
+        interval.width(), qMax( maxNumSteps, 1 ), base() );
 
     if ( !testAttribute( QwtScaleEngine::Floating ) )
         interval = align( interval, stepSize );
@@ -416,19 +566,19 @@
 }
 
 /*!
-   \brief Calculate a scale division
+   \brief Calculate a scale division for an interval
 
    \param x1 First interval limit
    \param x2 Second interval limit
-   \param maxMajSteps Maximum for the number of major steps
-   \param maxMinSteps Maximum number of minor steps
-   \param stepSize Step size. If stepSize == 0, the scaleEngine
+   \param maxMajorSteps Maximum for the number of major steps
+   \param maxMinorSteps Maximum number of minor steps
+   \param stepSize Step size. If stepSize == 0, the engine
                    calculates one.
 
-   \sa QwtScaleEngine::stepSize(), QwtScaleEngine::subDivide()
+   \return Calculated scale division
 */
 QwtScaleDiv QwtLinearScaleEngine::divideScale( double x1, double x2,
-    int maxMajSteps, int maxMinSteps, double stepSize ) const
+    int maxMajorSteps, int maxMinorSteps, double stepSize ) const
 {
     QwtInterval interval = QwtInterval( x1, x2 ).normalized();
     if ( interval.width() <= 0 )
@@ -437,10 +587,11 @@
     stepSize = qAbs( stepSize );
     if ( stepSize == 0.0 )
     {
-        if ( maxMajSteps < 1 )
-            maxMajSteps = 1;
+        if ( maxMajorSteps < 1 )
+            maxMajorSteps = 1;
 
-        stepSize = divideInterval( interval.width(), maxMajSteps );
+        stepSize = QwtScaleArithmetic::divideInterval( 
+            interval.width(), maxMajorSteps, base() );
     }
 
     QwtScaleDiv scaleDiv;
@@ -448,7 +599,7 @@
     if ( stepSize != 0.0 )
     {
         QList<double> ticks[QwtScaleDiv::NTickTypes];
-        buildTicks( interval, stepSize, maxMinSteps, ticks );
+        buildTicks( interval, stepSize, maxMinorSteps, ticks );
 
         scaleDiv = QwtScaleDiv( interval, ticks );
     }
@@ -464,13 +615,13 @@
 
    \param interval Interval
    \param stepSize Step size
-   \param maxMinSteps Maximum number of minor steps
+   \param maxMinorSteps Maximum number of minor steps
    \param ticks Arrays to be filled with the calculated ticks
 
    \sa buildMajorTicks(), buildMinorTicks
 */
 void QwtLinearScaleEngine::buildTicks(
-    const QwtInterval& interval, double stepSize, int maxMinSteps,
+    const QwtInterval& interval, double stepSize, int maxMinorSteps,
     QList<double> ticks[QwtScaleDiv::NTickTypes] ) const
 {
     const QwtInterval boundingInterval = align( interval, stepSize );
@@ -478,9 +629,9 @@
     ticks[QwtScaleDiv::MajorTick] =
         buildMajorTicks( boundingInterval, stepSize );
 
-    if ( maxMinSteps > 0 )
+    if ( maxMinorSteps > 0 )
     {
-        buildMinorTicks( ticks[QwtScaleDiv::MajorTick], maxMinSteps, stepSize,
+        buildMinorTicks( ticks[QwtScaleDiv::MajorTick], maxMinorSteps, stepSize,
             ticks[QwtScaleDiv::MinorTick], ticks[QwtScaleDiv::MediumTick] );
     }
 
@@ -528,7 +679,7 @@
    \brief Calculate minor/medium ticks for major ticks
 
    \param majorTicks Major ticks
-   \param maxMinSteps Maximum number of minor steps
+   \param maxMinorSteps Maximum number of minor steps
    \param stepSize Step size
    \param minorTicks Array to be filled with the calculated minor ticks
    \param mediumTicks Array to be filled with the calculated medium ticks
@@ -536,25 +687,17 @@
 */
 void QwtLinearScaleEngine::buildMinorTicks(
     const QList<double>& majorTicks,
-    int maxMinSteps, double stepSize,
+    int maxMinorSteps, double stepSize,
     QList<double> &minorTicks,
     QList<double> &mediumTicks ) const
 {
-    double minStep = divideInterval( stepSize, maxMinSteps );
+    double minStep = qwtStepSize( stepSize, maxMinorSteps, base() );
     if ( minStep == 0.0 )
         return;
 
     // # ticks per interval
-    int numTicks = qCeil( qAbs( stepSize / minStep ) ) - 1;
+    const int numTicks = qCeil( qAbs( stepSize / minStep ) ) - 1;
 
-    // Do the minor steps fit into the interval?
-    if ( qwtFuzzyCompare( ( numTicks +  1 ) * qAbs( minStep ),
-        qAbs( stepSize ), stepSize ) > 0 )
-    {
-        numTicks = 1;
-        minStep = stepSize * 0.5;
-    }
-
     int medIndex = -1;
     if ( numTicks % 2 )
         medIndex = numTicks / 2;
@@ -615,13 +758,22 @@
 }
 
 /*!
-  Return a transformation, for logarithmic (base 10) scales
-*/
-QwtScaleTransformation *QwtLog10ScaleEngine::transformation() const
+  Constructor
+
+  \param base Base of the scale engine
+  \sa setBase()
+ */
+QwtLogScaleEngine::QwtLogScaleEngine( uint base ):
+    QwtScaleEngine( base )
 {
-    return new QwtScaleTransformation( QwtScaleTransformation::Log10 );
+    setTransformation( new QwtLogTransform() );
 }
 
+//! Destructor
+QwtLogScaleEngine::~QwtLogScaleEngine()
+{
+}
+
 /*!
     Align and divide an interval
 
@@ -632,18 +784,20 @@
 
    \sa QwtScaleEngine::setAttribute()
 */
-void QwtLog10ScaleEngine::autoScale( int maxNumSteps,
+void QwtLogScaleEngine::autoScale( int maxNumSteps,
     double &x1, double &x2, double &stepSize ) const
 {
     if ( x1 > x2 )
         qSwap( x1, x2 );
 
-    QwtInterval interval( x1 / qPow( 10.0, lowerMargin() ),
-        x2 * qPow( 10.0, upperMargin() ) );
+    const double logBase = base();
 
-    if ( interval.maxValue() / interval.minValue() < 10.0 )
+    QwtInterval interval( x1 / qPow( logBase, lowerMargin() ),
+        x2 * qPow( logBase, upperMargin() ) );
+
+    if ( interval.maxValue() / interval.minValue() < logBase )
     {
-        // scale width is less than one decade -> build linear scale
+        // scale width is less than one step -> try to build a linear scale
 
         QwtLinearScaleEngine linearScaler;
         linearScaler.setAttributes( attributes() );
@@ -652,12 +806,19 @@
 
         linearScaler.autoScale( maxNumSteps, x1, x2, stepSize );
 
-        if ( stepSize < 0.0 )
-            stepSize = -::log10( qAbs( stepSize ) );
-        else
-            stepSize = ::log10( stepSize );
+        QwtInterval linearInterval = QwtInterval( x1, x2 ).normalized();
+        linearInterval = linearInterval.limited( LOG_MIN, LOG_MAX );
 
-        return;
+        if ( linearInterval.maxValue() / linearInterval.minValue() < logBase )
+        {
+            // the aligned scale is still less than one step
+            if ( stepSize < 0.0 )
+                stepSize = -qwtLog( logBase, qAbs( stepSize ) );
+            else
+                stepSize = qwtLog( logBase, stepSize );
+
+            return;
+        }
     }
 
     double logRef = 1.0;
@@ -679,7 +840,8 @@
     if ( interval.width() == 0.0 )
         interval = buildInterval( interval.minValue() );
 
-    stepSize = divideInterval( log10( interval ).width(), qMax( maxNumSteps, 1 ) );
+    stepSize = divideInterval( qwtLogInterval( logBase, interval ).width(), 
+        qMax( maxNumSteps, 1 ) );
     if ( stepSize < 1.0 )
         stepSize = 1.0;
 
@@ -697,19 +859,19 @@
 }
 
 /*!
-   \brief Calculate a scale division
+   \brief Calculate a scale division for an interval
 
    \param x1 First interval limit
    \param x2 Second interval limit
-   \param maxMajSteps Maximum for the number of major steps
-   \param maxMinSteps Maximum number of minor steps
-   \param stepSize Step size. If stepSize == 0, the scaleEngine
+   \param maxMajorSteps Maximum for the number of major steps
+   \param maxMinorSteps Maximum number of minor steps
+   \param stepSize Step size. If stepSize == 0, the engine
                    calculates one.
 
-   \sa QwtScaleEngine::stepSize(), QwtLog10ScaleEngine::subDivide()
+   \return Calculated scale division
 */
-QwtScaleDiv QwtLog10ScaleEngine::divideScale( double x1, double x2,
-    int maxMajSteps, int maxMinSteps, double stepSize ) const
+QwtScaleDiv QwtLogScaleEngine::divideScale( double x1, double x2,
+    int maxMajorSteps, int maxMinorSteps, double stepSize ) const
 {
     QwtInterval interval = QwtInterval( x1, x2 ).normalized();
     interval = interval.limited( LOG_MIN, LOG_MAX );
@@ -717,7 +879,9 @@
     if ( interval.width() <= 0 )
         return QwtScaleDiv();
 
-    if ( interval.maxValue() / interval.minValue() < 10.0 )
+    const double logBase = base();
+
+    if ( interval.maxValue() / interval.minValue() < logBase )
     {
         // scale width is less than one decade -> build linear scale
 
@@ -729,22 +893,23 @@
         if ( stepSize != 0.0 )
         {
             if ( stepSize < 0.0 )
-                stepSize = -qPow( 10.0, -stepSize );
+                stepSize = -qPow( logBase, -stepSize );
             else
-                stepSize = qPow( 10.0, stepSize );
+                stepSize = qPow( logBase, stepSize );
         }
 
         return linearScaler.divideScale( x1, x2,
-            maxMajSteps, maxMinSteps, stepSize );
+            maxMajorSteps, maxMinorSteps, stepSize );
     }
 
     stepSize = qAbs( stepSize );
     if ( stepSize == 0.0 )
     {
-        if ( maxMajSteps < 1 )
-            maxMajSteps = 1;
+        if ( maxMajorSteps < 1 )
+            maxMajorSteps = 1;
 
-        stepSize = divideInterval( log10( interval ).width(), maxMajSteps );
+        stepSize = divideInterval( 
+            qwtLogInterval( logBase, interval ).width(), maxMajorSteps );
         if ( stepSize < 1.0 )
             stepSize = 1.0; // major step must be >= 1 decade
     }
@@ -753,7 +918,7 @@
     if ( stepSize != 0.0 )
     {
         QList<double> ticks[QwtScaleDiv::NTickTypes];
-        buildTicks( interval, stepSize, maxMinSteps, ticks );
+        buildTicks( interval, stepSize, maxMinorSteps, ticks );
 
         scaleDiv = QwtScaleDiv( interval, ticks );
     }
@@ -768,14 +933,14 @@
    \brief Calculate ticks for an interval
 
    \param interval Interval
-   \param maxMinSteps Maximum number of minor steps
+   \param maxMinorSteps Maximum number of minor steps
    \param stepSize Step size
    \param ticks Arrays to be filled with the calculated ticks
 
    \sa buildMajorTicks(), buildMinorTicks
 */
-void QwtLog10ScaleEngine::buildTicks(
-    const QwtInterval& interval, double stepSize, int maxMinSteps,
+void QwtLogScaleEngine::buildTicks(
+    const QwtInterval& interval, double stepSize, int maxMinorSteps,
     QList<double> ticks[QwtScaleDiv::NTickTypes] ) const
 {
     const QwtInterval boundingInterval = align( interval, stepSize );
@@ -783,10 +948,10 @@
     ticks[QwtScaleDiv::MajorTick] =
         buildMajorTicks( boundingInterval, stepSize );
 
-    if ( maxMinSteps > 0 )
+    if ( maxMinorSteps > 0 )
     {
-        ticks[QwtScaleDiv::MinorTick] = buildMinorTicks(
-            ticks[QwtScaleDiv::MajorTick], maxMinSteps, stepSize );
+        buildMinorTicks( ticks[QwtScaleDiv::MajorTick], maxMinorSteps, stepSize,
+            ticks[QwtScaleDiv::MinorTick], ticks[QwtScaleDiv::MediumTick] );
     }
 
     for ( int i = 0; i < QwtScaleDiv::NTickTypes; i++ )
@@ -801,10 +966,10 @@
 
    \return Calculated ticks
 */
-QList<double> QwtLog10ScaleEngine::buildMajorTicks(
+QList<double> QwtLogScaleEngine::buildMajorTicks(
     const QwtInterval &interval, double stepSize ) const
 {
-    double width = log10( interval ).width();
+    double width = qwtLogInterval( base(), interval ).width();
 
     int numTicks = qRound( width / stepSize ) + 1;
     if ( numTicks > 10000 )
@@ -830,93 +995,98 @@
    \brief Calculate minor/medium ticks for major ticks
 
    \param majorTicks Major ticks
-   \param maxMinSteps Maximum number of minor steps
+   \param maxMinorSteps Maximum number of minor steps
    \param stepSize Step size
+   \param minorTicks Array to be filled with the calculated minor ticks
+   \param mediumTicks Array to be filled with the calculated medium ticks
 */
-QList<double> QwtLog10ScaleEngine::buildMinorTicks(
+void QwtLogScaleEngine::buildMinorTicks(
     const QList<double> &majorTicks,
-    int maxMinSteps, double stepSize ) const
+    int maxMinorSteps, double stepSize,
+    QList<double> &minorTicks,
+    QList<double> &mediumTicks ) const
 {
-    if ( stepSize < 1.1 )          // major step width is one decade
+    const double logBase = base();
+
+    if ( stepSize < 1.1 )          // major step width is one base
     {
-        if ( maxMinSteps < 1 )
-            return QList<double>();
+        double minStep = divideInterval( stepSize, maxMinorSteps + 1 );
+        if ( minStep == 0.0 )
+            return;
+        
+        const int numSteps = qRound( stepSize / minStep ); 
 
-        int k0, kstep, kmax;
+        int mediumTickIndex = -1;
+        if ( ( numSteps > 2 ) && ( numSteps % 2 == 0 ) )
+            mediumTickIndex = numSteps / 2;
 
-        if ( maxMinSteps >= 8 )
+        for ( int i = 0; i < majorTicks.count() - 1; i++ )
         {
-            k0 = 2;
-            kmax = 9;
-            kstep = 1;
-        }
-        else if ( maxMinSteps >= 4 )
-        {
-            k0 = 2;
-            kmax = 8;
-            kstep = 2;
-        }
-        else if ( maxMinSteps >= 2 )
-        {
-            k0 = 2;
-            kmax = 5;
-            kstep = 3;
-        }
-        else
-        {
-            k0 = 5;
-            kmax = 5;
-            kstep = 1;
-        }
+            const double v = majorTicks[i];
+            const double s = logBase / numSteps;
 
-        QList<double> minorTicks;
-
-        for ( int i = 0; i < majorTicks.count(); i++ )
-        {
-            const double v = majorTicks[i];
-            for ( int k = k0; k <= kmax; k += kstep )
-                minorTicks += v * double( k );
+            if ( s >= 1.0 )
+            {
+                for ( int j = 2; j < numSteps; j++ )
+                {
+                    minorTicks += v * j * s;
+                }
+            }
+            else
+            {
+                for ( int j = 1; j < numSteps; j++ )
+                {
+                    const double tick = v + j * v * ( logBase - 1 ) / numSteps;
+                    if ( j == mediumTickIndex )
+                        mediumTicks += tick;
+                    else
+                        minorTicks += tick;
+                }
+            }
         }
-
-        return minorTicks;
     }
-    else  // major step > one decade
+    else
     {
-        double minStep = divideInterval( stepSize, maxMinSteps );
+        double minStep = divideInterval( stepSize, maxMinorSteps );
         if ( minStep == 0.0 )
-            return QList<double>();
+            return;
 
         if ( minStep < 1.0 )
             minStep = 1.0;
 
         // # subticks per interval
-        int nMin = qRound( stepSize / minStep ) - 1;
+        int numTicks = qRound( stepSize / minStep ) - 1;
 
         // Do the minor steps fit into the interval?
-
-        if ( qwtFuzzyCompare( ( nMin +  1 ) * minStep,
-            qAbs( stepSize ), stepSize ) > 0 )
+        if ( qwtFuzzyCompare( ( numTicks +  1 ) * minStep,
+            stepSize, stepSize ) > 0 )
         {
-            nMin = 0;
+            numTicks = 0;
         }
 
-        if ( nMin < 1 )
-            return QList<double>();      // no subticks
+        if ( numTicks < 1 )
+            return; 
 
-        // substep factor = 10^substeps
-        const qreal minFactor = qMax( qPow( 10.0, minStep ), qreal( 10.0 ) );
+        int mediumTickIndex = -1;
+        if ( ( numTicks > 2 ) && ( numTicks % 2 ) )
+            mediumTickIndex = numTicks / 2;
 
-        QList<double> minorTicks;
+        // substep factor = base^substeps
+        const qreal minFactor = qMax( qPow( logBase, minStep ), qreal( logBase ) );
+
         for ( int i = 0; i < majorTicks.count(); i++ )
         {
-            double val = majorTicks[i];
-            for ( int k = 0; k < nMin; k++ )
+            double tick = majorTicks[i];
+            for ( int j = 0; j < numTicks; j++ )
             {
-                val *= minFactor;
-                minorTicks += val;
+                tick *= minFactor;
+
+                if ( j == mediumTickIndex )
+                    mediumTicks += tick;
+                else
+                    minorTicks += tick;
             }
         }
-        return minorTicks;
     }
 }
 
@@ -931,10 +1101,10 @@
 
   \return Aligned interval
 */
-QwtInterval QwtLog10ScaleEngine::align(
+QwtInterval QwtLogScaleEngine::align(
     const QwtInterval &interval, double stepSize ) const
 {
-    const QwtInterval intv = log10( interval );
+    const QwtInterval intv = qwtLogInterval( base(), interval );
 
     double x1 = QwtScaleArithmetic::floorEps( intv.minValue(), stepSize );
     if ( qwtFuzzyCompare( interval.minValue(), x1, stepSize ) == 0 )
@@ -944,24 +1114,5 @@
     if ( qwtFuzzyCompare( interval.maxValue(), x2, stepSize ) == 0 )
         x2 = interval.maxValue();
 
-    return pow10( QwtInterval( x1, x2 ) );
+    return qwtPowInterval( base(), QwtInterval( x1, x2 ) );
 }
-
-/*!
-  Return the interval [log10(interval.minValue(), log10(interval.maxValue]
-*/
-
-QwtInterval QwtLog10ScaleEngine::log10( const QwtInterval &interval ) const
-{
-    return QwtInterval( ::log10( interval.minValue() ),
-            ::log10( interval.maxValue() ) );
-}
-
-/*!
-  Return the interval [pow10(interval.minValue(), pow10(interval.maxValue]
-*/
-QwtInterval QwtLog10ScaleEngine::pow10( const QwtInterval &interval ) const
-{
-    return QwtInterval( qPow( 10.0, interval.minValue() ),
-            qPow( 10.0, interval.maxValue() ) );
-}
Index: qwt_picker.cpp
===================================================================
--- qwt_picker.cpp	(revision 382)
+++ qwt_picker.cpp	(working copy)
@@ -11,6 +11,7 @@
 #include "qwt_picker_machine.h"
 #include "qwt_painter.h"
 #include "qwt_math.h"
+#include "qwt_widget_overlay.h"
 #include <qapplication.h>
 #include <qevent.h>
 #include <qpainter.h>
@@ -21,36 +22,89 @@
 #include <qpaintengine.h>
 #include <qmath.h>
 
-class QwtPicker::PickerWidget: public QWidget
+static inline QRegion qwtMaskRegion( const QRect &r, int penWidth )
 {
-public:
-    enum Type
+    const int pw = qMax( penWidth, 1 );
+    const int pw2 = penWidth / 2;
+
+    int x1 = r.left() - pw2;
+    int x2 = r.right() + 1 + pw2 + ( pw % 2 );
+
+    int y1 = r.top() - pw2;
+    int y2 = r.bottom() + 1 + pw2 + ( pw % 2 );
+
+    QRegion region;
+
+    region += QRect( x1, y1, x2 - x1, pw );
+    region += QRect( x1, y1, pw, y2 - y1 );
+    region += QRect( x1, y2 - pw, x2 - x1, pw );
+    region += QRect( x2 - pw, y1, pw, y2 - y1 );
+
+    return region;
+}
+
+static inline QRegion qwtMaskRegion( const QLine &l, int penWidth )
+{
+    const int pw = qMax( penWidth, 1 );
+    const int pw2 = penWidth / 2;
+
+    QRegion region;
+
+    if ( l.x1() == l.x2() )
     {
-        RubberBand,
-        Text
-    };
+        region += QRect( l.x1() - pw2, l.y1(), 
+            pw, l.y2() ).normalized();
+    }
+    else if ( l.y1() == l.y2() )
+    {
+        region += QRect( l.x1(), l.y1() - pw2, 
+            l.x2(), pw ).normalized();
+    }
 
-    PickerWidget( QwtPicker *, QWidget *, Type );
-    void updateMask();
+    return region;
+}
 
-    /*
-       For a tracker text with a background we can use the background
-       rect as mask. Also for "regular" Qt widgets >= 4.3.0 we
-       don't need to mask the text anymore.
-     */
-    bool d_hasTextMask;
+class QwtPickerRubberband: public QwtWidgetOverlay
+{
+public:
+    QwtPickerRubberband( QwtPicker *, QWidget * );
 
 protected:
-    virtual void paintEvent( QPaintEvent * );
-    virtual void resizeEvent( QResizeEvent * );
+    virtual void drawOverlay( QPainter * ) const;
+    virtual QRegion maskHint() const;
 
     QwtPicker *d_picker;
-    Type d_type;
 };
 
+class QwtPickerTracker: public QwtWidgetOverlay
+{                                  
+public:
+    QwtPickerTracker( QwtPicker *, QWidget * );
+    
+protected:
+    virtual void drawOverlay( QPainter * ) const;
+    virtual QRegion maskHint() const;
+    
+    QwtPicker *d_picker;
+};  
+
+
 class QwtPicker::PrivateData
 {
 public:
+    PrivateData():
+        enabled( false ),
+        stateMachine( NULL ),
+        resizeMode( QwtPicker::Stretch ),
+        rubberBand( QwtPicker::NoRubberBand ),
+        trackerMode( QwtPicker::AlwaysOff ),
+        isActive( false ),
+        trackerPosition( -1, -1 ),
+        mouseTracking( false ),
+        openGL( false )
+    {
+    }
+        
     bool enabled;
 
     QwtPickerMachine *stateMachine;
@@ -70,145 +124,55 @@
 
     bool mouseTracking; // used to save previous value
 
-    /*
-      On X11 the widget below the picker widgets gets paint events
-      with a region that is the bounding rect of the mask, if it is complex.
-      In case of (f.e) a CrossRubberBand and a text this creates complete
-      repaints of the widget. So we better use two different widgets.
-     */
+    QPointer< QwtPickerRubberband > rubberBandOverlay;
+    QPointer< QwtPickerTracker> trackerOverlay;
 
-    QPointer<PickerWidget> rubberBandWidget;
-    QPointer<PickerWidget> trackerWidget;
+    bool openGL;
 };
 
-QwtPicker::PickerWidget::PickerWidget(
-        QwtPicker *picker, QWidget *parent, Type type ):
-    QWidget( parent ),
-    d_hasTextMask( false ),
-    d_picker( picker ),
-    d_type( type )
+QwtPickerRubberband::QwtPickerRubberband(
+        QwtPicker *picker, QWidget *parent ):
+    QwtWidgetOverlay( parent ),
+    d_picker( picker )
 {
-    setAttribute( Qt::WA_TransparentForMouseEvents );
-    setAttribute( Qt::WA_NoSystemBackground );
-    setFocusPolicy( Qt::NoFocus );
+    setMaskMode( QwtWidgetOverlay::MaskHint );
 }
 
-void QwtPicker::PickerWidget::updateMask()
+QRegion QwtPickerRubberband::maskHint() const
 {
-    QRegion mask;
+    return d_picker->rubberBandMask();
+}
 
-    if ( d_type == RubberBand )
-    {
-        QBitmap bm( width(), height() );
-        bm.fill( Qt::color0 );
+void QwtPickerRubberband::drawOverlay( QPainter *painter ) const
+{
+    painter->setPen( d_picker->rubberBandPen() );
+    d_picker->drawRubberBand( painter );
+}
 
-        QPainter painter( &bm );
-        QPen pen = d_picker->rubberBandPen();
-        pen.setColor( Qt::color1 );
-        painter.setPen( pen );
-
-        d_picker->drawRubberBand( &painter );
-
-        mask = QRegion( bm );
-    }
-    if ( d_type == Text )
-    {
-        d_hasTextMask = parentWidget()->testAttribute( Qt::WA_PaintOnScreen );
-
-        if ( d_hasTextMask )
-        {
-            const QwtText label = d_picker->trackerText(
-                d_picker->trackerPosition() );
-
-            if ( label.testPaintAttribute( QwtText::PaintBackground )
-                && label.backgroundBrush().style() != Qt::NoBrush )
-            {
-                if ( label.backgroundBrush().color().alpha() > 0 )
-                {
-                    // We don't need a text mask, when we have a background
-                    d_hasTextMask = false;
-                }
-            }
-        }
-
-        if ( d_hasTextMask )
-        {
-            QBitmap bm( width(), height() );
-            bm.fill( Qt::color0 );
-
-            QPainter painter( &bm );
-            painter.setFont( font() );
-
-            QPen pen = d_picker->trackerPen();
-            pen.setColor( Qt::color1 );
-            painter.setPen( pen );
-
-            d_picker->drawTracker( &painter );
-
-            mask = QRegion( bm );
-        }
-        else
-        {
-            mask = d_picker->trackerRect( font() );
-        }
-    }
-
-    QWidget *w = parentWidget();
-    if ( w && !w->testAttribute( Qt::WA_PaintOnScreen ) )
-    {
-        // The parent widget gets an update for its complete rectangle
-        // when the mask is changed in visible state.
-        // With this hide/show we only get an update for the
-        // previous mask.
-
-        hide();
-    }
-    setMask( mask );
-    setVisible( !mask.isEmpty() );
+QwtPickerTracker::QwtPickerTracker(
+        QwtPicker *picker, QWidget *parent ):
+    QwtWidgetOverlay( parent ),
+    d_picker( picker )
+{
+    setMaskMode( QwtWidgetOverlay::MaskHint );
 }
 
-void QwtPicker::PickerWidget::paintEvent( QPaintEvent *e )
+QRegion QwtPickerTracker::maskHint() const
 {
-    QPainter painter( this );
-    painter.setClipRegion( e->region() );
-
-    if ( d_type == RubberBand )
-    {
-        painter.setPen( d_picker->rubberBandPen() );
-        d_picker->drawRubberBand( &painter );
-    }
-
-    if ( d_type == Text )
-    {
-        /*
-           If we have a text mask we simply fill the region of
-           the mask. This gives better results for antialiased fonts.
-         */
-        if ( d_hasTextMask )
-        {
-            painter.fillRect( e->rect(), 
-                QBrush( d_picker->trackerPen().color() ) );
-        }
-        else
-        {
-            painter.setPen( d_picker->trackerPen() );
-            d_picker->drawTracker( &painter );
-        }
-    }
+    return d_picker->trackerRect( font() );
 }
 
-void QwtPicker::PickerWidget::resizeEvent( QResizeEvent *event )
+void QwtPickerTracker::drawOverlay( QPainter *painter ) const
 {
-    QWidget::resizeEvent( event );
-    if ( isVisible() )
-        updateMask();
+    painter->setPen( d_picker->trackerPen() );
+    d_picker->drawTracker( painter );
 }
 
 /*!
   Constructor
 
   Creates an picker that is enabled, but without a state machine.
-  rubberband and tracker are disabled.
+  rubber band and tracker are disabled.
 
   \param parent Parent widget, that will be observed
  */
@@ -222,7 +186,7 @@
 /*!
   Constructor
 
-  \param rubberBand Rubberband style
+  \param rubberBand Rubber band style
   \param trackerMode Tracker mode
   \param parent Parent widget, that will be observed
  */
@@ -237,40 +201,34 @@
 QwtPicker::~QwtPicker()
 {
     setMouseTracking( false );
+
     delete d_data->stateMachine;
-    delete d_data->rubberBandWidget;
-    delete d_data->trackerWidget;
+    delete d_data->rubberBandOverlay;
+    delete d_data->trackerOverlay;
+
     delete d_data;
 }
 
-//! Init the picker, used by the constructors
+//! Initialize the picker - used by the constructors
 void QwtPicker::init( QWidget *parent,
     RubberBand rubberBand, DisplayMode trackerMode )
 {
     d_data = new PrivateData;
 
-    d_data->rubberBandWidget = NULL;
-    d_data->trackerWidget = NULL;
-
     d_data->rubberBand = rubberBand;
-    d_data->enabled = false;
-    d_data->resizeMode = Stretch;
-    d_data->trackerMode = AlwaysOff;
-    d_data->isActive = false;
-    d_data->trackerPosition = QPoint( -1, -1 );
-    d_data->mouseTracking = false;
 
-    d_data->stateMachine = NULL;
-
     if ( parent )
     {
         if ( parent->focusPolicy() == Qt::NoFocus )
             parent->setFocusPolicy( Qt::WheelFocus );
 
+        d_data->openGL = parent->inherits( "QGLWidget" );
         d_data->trackerFont = parent->font();
         d_data->mouseTracking = parent->hasMouseTracking();
+
         setEnabled( true );
     }
+
     setTrackerMode( trackerMode );
 }
 
@@ -333,9 +291,9 @@
 }
 
 /*!
-  Set the rubberband style
+  Set the rubber band style
 
-  \param rubberBand Rubberband style
+  \param rubberBand Rubber band style
          The default value is NoRubberBand.
 
   \sa rubberBand(), RubberBand, setRubberBandPen()
@@ -346,7 +304,7 @@
 }
 
 /*!
-  \return Rubberband style
+  \return Rubber band style
   \sa setRubberBand(), RubberBand, rubberBandPen()
 */
 QwtPicker::RubberBand QwtPicker::rubberBand() const
@@ -507,7 +465,7 @@
 /*!
   Set the pen for the rubberband
 
-  \param pen Rubberband pen
+  \param pen Rubber band pen
   \sa rubberBandPen(), setRubberBand()
 */
 void QwtPicker::setRubberBandPen( const QPen &pen )
@@ -520,7 +478,7 @@
 }
 
 /*!
-  \return Rubberband pen
+  \return Rubber band pen
   \sa setRubberBandPen(), rubberBand()
 */
 QPen QwtPicker::rubberBandPen() const
@@ -560,10 +518,120 @@
 }
 
 /*!
-   Draw a rubberband, depending on rubberBand()
+  Calculate the mask for the rubber band overlay
 
-   \param painter Painter, initialized with clip rect
+  \return Region for the mask
+  \sa QWidget::setMask()
+ */
+QRegion QwtPicker::rubberBandMask() const
+{
+    QRegion mask;
 
+    if ( !isActive() || rubberBand() == NoRubberBand ||
+        rubberBandPen().style() == Qt::NoPen )
+    {
+        return mask;
+    }
+
+    const QPolygon pa = adjustedPoints( d_data->pickedPoints );
+
+    QwtPickerMachine::SelectionType selectionType =
+        QwtPickerMachine::NoSelection;
+
+    if ( d_data->stateMachine )
+        selectionType = d_data->stateMachine->selectionType();
+
+    switch ( selectionType )
+    {
+        case QwtPickerMachine::NoSelection:
+        case QwtPickerMachine::PointSelection:
+        {
+            if ( pa.count() < 1 )
+                return mask;
+
+            const QPoint pos = pa[0];
+            const int pw = rubberBandPen().width();
+
+            const QRect pRect = pickArea().boundingRect().toRect();
+            switch ( rubberBand() )
+            {
+                case VLineRubberBand:
+                {
+                    mask += qwtMaskRegion( QLine( pos.x(), pRect.top(), 
+                        pos.x(), pRect.bottom() ), pw );
+                    break;
+                }
+                case HLineRubberBand:
+                {
+                    mask += qwtMaskRegion( QLine( pRect.left(), pos.y(), 
+                        pRect.right(), pos.y() ), pw );
+                    break;
+                }
+                case CrossRubberBand:
+                {
+                    mask += qwtMaskRegion( QLine( pos.x(), pRect.top(), 
+                        pos.x(), pRect.bottom() ), pw );
+                    mask += qwtMaskRegion( QLine( pRect.left(), pos.y(), 
+                        pRect.right(), pos.y() ), pw );
+                    break;
+                }
+                default:
+                    break;
+            }
+            break;
+        }
+        case QwtPickerMachine::RectSelection:
+        {
+            if ( pa.count() < 2 )
+                return mask;
+
+            const int pw = rubberBandPen().width();
+
+            switch ( rubberBand() )
+            {
+                case RectRubberBand:
+                {
+                    const QRect r = QRect( pa.first(), pa.last() );
+                    mask = qwtMaskRegion( r.normalized(), pw );
+                    break;
+                }
+                case EllipseRubberBand:
+                {
+                    const QRect r = QRect( pa.first(), pa.last() );
+                    mask += r.adjusted( -pw, -pw, pw, pw );
+                    break;
+                }
+                default:
+                    break;
+            }
+            break;
+        }
+        case QwtPickerMachine::PolygonSelection:
+        {
+            const int pw = rubberBandPen().width();
+            if ( pw <= 1 )
+            {
+                // because of the join style we better
+                // return a mask for a pen width <= 1 only
+
+                const int off = 2 * pw;
+                const QRect r = pa.boundingRect();
+                mask += r.adjusted( -off, -off, off, off );
+            }
+            break;
+        }
+        default:
+            break;
+    }
+
+    return mask;
+}
+
+/*!
+   Draw a rubber band, depending on rubberBand()
+
+   \param painter Painter, initialized with a clip region
+
    \sa rubberBand(), RubberBand
 */
 
@@ -597,21 +665,25 @@
             switch ( rubberBand() )
             {
                 case VLineRubberBand:
+                {
                     QwtPainter::drawLine( painter, pos.x(),
                         pRect.top(), pos.x(), pRect.bottom() );
                     break;
-
+                }
                 case HLineRubberBand:
+                {
                     QwtPainter::drawLine( painter, pRect.left(),
                         pos.y(), pRect.right(), pos.y() );
                     break;
-
+                }
                 case CrossRubberBand:
+                {
                     QwtPainter::drawLine( painter, pos.x(),
                         pRect.top(), pos.x(), pRect.bottom() );
                     QwtPainter::drawLine( painter, pRect.left(),
                         pos.y(), pRect.right(), pos.y() );
                     break;
+                }
                 default:
                     break;
             }
@@ -622,18 +694,19 @@
             if ( pa.count() < 2 )
                 return;
 
-            const QPoint p1 = pa[0];
-            const QPoint p2 = pa[int( pa.count() - 1 )];
-
-            const QRect rect = QRect( p1, p2 ).normalized();
+            const QRect rect = QRect( pa.first(), pa.last() ).normalized();
             switch ( rubberBand() )
             {
                 case EllipseRubberBand:
+                {
                     QwtPainter::drawEllipse( painter, rect );
                     break;
+                }
                 case RectRubberBand:
+                {
                     QwtPainter::drawRect( painter, rect );
                     break;
+                }
                 default:
                     break;
             }
@@ -701,6 +774,9 @@
     }
     return adjusted;
 }\endverbatim\n
+
+  \param points Selected points
+  \return Selected points unmodified
 */
 QPolygon QwtPicker::adjustedPoints( const QPolygon &points ) const
 {
@@ -796,14 +872,16 @@
 /*!
   \brief Event filter
 
-  When isEnabled() == true all events of the observed widget are filtered.
+  When isEnabled() is true all events of the observed widget are filtered.
   Mouse and keyboard events are translated into widgetMouse- and widgetKey-
   and widgetWheel-events. Paint and Resize events are handled to keep
-  rubberband and tracker up to date.
+  rubber band and tracker up to date.
 
   \param object Object to be filtered
   \param event Event
 
+  \return Always false.
+
   \sa widgetEnterEvent(), widgetLeaveEvent(),
       widgetMousePressEvent(), widgetMouseReleaseEvent(),
       widgetMouseDoubleClickEvent(), widgetMouseMoveEvent(),
@@ -822,11 +900,6 @@
                 if ( d_data->resizeMode == Stretch )
                     stretchSelection( re->oldSize(), re->size() );
 
-                if ( d_data->rubberBandWidget )
-                    d_data->rubberBandWidget->resize( re->size() );
-
-                if ( d_data->trackerWidget )
-                    d_data->trackerWidget->resize( re->size() );
                 break;
             }
             case QEvent::Enter:
@@ -950,7 +1023,7 @@
 }
 
 /*!
-  Handle a mouse relase event for the observed widget.
+  Handle a mouse release event for the observed widget.
 
   \param mouseEvent Mouse event
 
@@ -1075,7 +1148,7 @@
 /*!
   Passes an event to the state machine and executes the resulting
   commands. Append and Move commands use the current position
-  of the cursor (QCursor::pos()).
+  of the cursor ( QCursor::pos() ).
 
   \param event Event
 */
@@ -1204,7 +1277,7 @@
 }
 
 /*!
-   Reset the state machine and terminate (end(false)) the selection
+   Reset the state machine and terminate ( end(false) ) the selection
 */
 void QwtPicker::reset()
 {
@@ -1216,7 +1289,7 @@
 }
 
 /*!
-  Append a point to the selection and update rubberband and tracker.
+  Append a point to the selection and update rubber band and tracker.
   The appended() signal is emitted.
 
   \param pos Additional point
@@ -1286,11 +1359,11 @@
 }
 
 /*!
-  \brief Validate and fixup the selection
+  \brief Validate and fix up the selection
 
   Accepts all selections unmodified
 
-  \param selection Selection to validate and fixup
+  \param selection Selection to validate and fix up
   \return true, when accepted, false otherwise
 */
 bool QwtPicker::accept( QPolygon &selection ) const
@@ -1397,13 +1470,14 @@
     return path;
 }
 
-//! Update the state of rubberband and tracker label
+//! Update the state of rubber band and tracker label
 void QwtPicker::updateDisplay()
 {
     QWidget *w = parentWidget();
 
     bool showRubberband = false;
     bool showTracker = false;
+
     if ( w && w->isVisible() && d_data->enabled )
     {
         if ( rubberBand() != NoRubberBand && isActive() &&
@@ -1415,52 +1489,89 @@
         if ( trackerMode() == AlwaysOn ||
             ( trackerMode() == ActiveOnly && isActive() ) )
         {
-            if ( trackerPen() != Qt::NoPen )
+            if ( trackerPen() != Qt::NoPen 
+                && !trackerRect( QFont() ).isEmpty() )
+            {
                 showTracker = true;
+            }
         }
     }
 
-    QPointer<PickerWidget> &rw = d_data->rubberBandWidget;
+    QPointer< QwtPickerRubberband > &rw = d_data->rubberBandOverlay;
     if ( showRubberband )
     {
         if ( rw.isNull() )
         {
-            rw = new PickerWidget( this, w, PickerWidget::RubberBand );
+            rw = new QwtPickerRubberband( this, w );
             rw->setObjectName( "PickerRubberBand" );
             rw->resize( w->size() );
         }
-        rw->updateMask();
-        rw->update(); // Needed, when the mask doesn't change
+
+        if ( d_data->rubberBand <= RectRubberBand )
+            rw->setMaskMode( QwtWidgetOverlay::MaskHint );
+        else
+            rw->setMaskMode( QwtWidgetOverlay::AlphaMask );
+
+        rw->updateOverlay();
     }
     else
-        delete rw;
+    {
+        if ( d_data->openGL )
+        {
+            // Qt 4.8 crashes for a delete
+            if ( !rw.isNull() )
+            {
+                rw->hide();
+                rw->deleteLater();
+                rw = NULL;
+            }
+        }
+        else
+        {
+            delete rw;
+        }
+    }
 
-    QPointer<PickerWidget> &tw = d_data->trackerWidget;
+    QPointer< QwtPickerTracker > &tw = d_data->trackerOverlay;
     if ( showTracker )
     {
         if ( tw.isNull() )
         {
-            tw = new PickerWidget( this, w, PickerWidget::Text );
+            tw = new QwtPickerTracker( this, w );
             tw->setObjectName( "PickerTracker" );
             tw->resize( w->size() );
         }
         tw->setFont( d_data->trackerFont );
-        tw->updateMask();
-        tw->update(); // Needed, when the mask doesn't change
+        tw->updateOverlay();
     }
     else
-        delete tw;
+    {
+        if ( d_data->openGL )
+        {
+            // Qt 4.8 crashes for a delete
+            if ( !tw.isNull() )
+            {
+                tw->hide();
+                tw->deleteLater();
+                tw = NULL;
+            }
+        }
+        else
+        {
+            delete tw;
+        }
+    }
 }
 
-//! \return Widget displaying the rubberband
-const QWidget *QwtPicker::rubberBandWidget() const
+//! \return Overlay displaying the rubber band
+const QwtWidgetOverlay *QwtPicker::rubberBandOverlay() const
 {
-    return d_data->rubberBandWidget;
+    return d_data->rubberBandOverlay;
 }
 
-//! \return Widget displaying the tracker text
-const QWidget *QwtPicker::trackerWidget() const
+//! \return Overlay displaying the tracker text
+const QwtWidgetOverlay *QwtPicker::trackerOverlay() const
 {
-    return d_data->trackerWidget;
+    return d_data->trackerOverlay;
 }
 
Index: qwt_plot_zoomer.h
===================================================================
--- qwt_plot_zoomer.h	(revision 382)
+++ qwt_plot_zoomer.h	(working copy)
@@ -17,34 +17,70 @@
 /*!
   \brief QwtPlotZoomer provides stacked zooming for a plot widget
 
-  QwtPlotZoomer offers rubberband selections on the plot canvas,
-  translating the selected rectangles into plot coordinates and
-  adjusting the axes to them. Zooming can repeated as often as
-  possible, limited only by maxStackDepth() or minZoomSize().
-  Each rectangle is pushed on a stack.
+  QwtPlotZoomer selects rectangles from user inputs ( mouse or keyboard )
+  translates them into plot coordinates and adjusts the axes to them.
+  The selection is supported by a rubber band and optionally by displaying
+  the coordinates of the current mouse position.
 
-  Zoom rectangles can be selected depending on selectionFlags() using the
-  mouse or keyboard (QwtEventPattern, QwtPickerMachine).
-  QwtEventPattern::MouseSelect3,QwtEventPattern::KeyUndo,
-  or QwtEventPattern::MouseSelect6,QwtEventPattern::KeyRedo
-  walk up and down the zoom stack.
-  QwtEventPattern::MouseSelect2 or QwtEventPattern::KeyHome unzoom to
-  the initial size.
+  Zooming can be repeated as often as possible, limited only by 
+  maxStackDepth() or minZoomSize().  Each rectangle is pushed on a stack.
 
+  The default setting how to select rectangles is 
+  a QwtPickerDragRectMachine with the following bindings:
+
+  - QwtEventPattern::MouseSelect1\n
+    The first point of the zoom rectangle is selected by a mouse press, 
+    the second point from the position, where the mouse is released.
+
+  - QwtEventPattern::KeySelect1\n
+    The first key press selects the first, the second key press
+    selects the second point.
+
+  - QwtEventPattern::KeyAbort\n
+    Discard the selection in the state, where the first point
+    is selected.
+
+  To traverse the zoom stack the following bindings are used:
+
+  - QwtEventPattern::MouseSelect3, QwtEventPattern::KeyUndo\n
+    Zoom out one position on the zoom stack
+    
+  - QwtEventPattern::MouseSelect6, QwtEventPattern::KeyRedo\n
+    Zoom in one position on the zoom stack
+
+  - QwtEventPattern::MouseSelect2, QwtEventPattern::KeyHome\n
+    Zoom to the zoom base
+
+  The setKeyPattern() and setMousePattern() functions can be used
+  to configure the zoomer actions. The following example 
+  shows, how to configure the 'I' and 'O' keys for zooming in and out 
+  one position on the zoom stack. The "Home" key is used to 
+  "unzoom" the plot.
+
+  \code
+   zoomer = new QwtPlotZoomer( plot );
+   zoomer->setKeyPattern( QwtEventPattern::KeyRedo, Qt::Key_I, Qt::ShiftModifier );
+   zoomer->setKeyPattern( QwtEventPattern::KeyUndo, Qt::Key_O, Qt::ShiftModifier );
+   zoomer->setKeyPattern( QwtEventPattern::KeyHome, Qt::Key_Home );
+  \endcode
+
   QwtPlotZoomer is tailored for plots with one x and y axis, but it is
-  allowed to attach a second QwtPlotZoomer for the other axes.
+  allowed to attach a second QwtPlotZoomer ( without rubber band and tracker )
+  for the other axes.
 
   \note The realtime example includes an derived zoomer class that adds
         scrollbars to the plot canvas.
+
+  \sa QwtPlotPanner, QwtPlotMagnifier
 */
 
 class QWT_EXPORT QwtPlotZoomer: public QwtPlotPicker
 {
     Q_OBJECT
 public:
-    explicit QwtPlotZoomer( QwtPlotCanvas *, bool doReplot = true );
+    explicit QwtPlotZoomer( QWidget *, bool doReplot = true );
     explicit QwtPlotZoomer( int xAxis, int yAxis,
-                            QwtPlotCanvas *, bool doReplot = true );
+                            QWidget *, bool doReplot = true );
 
     virtual ~QwtPlotZoomer();
 
Index: qwt_abstract_scale.h
===================================================================
--- qwt_abstract_scale.h	(revision 382)
+++ qwt_abstract_scale.h	(working copy)
@@ -11,6 +11,7 @@
 #define QWT_ABSTRACT_SCALE_H
 
 #include "qwt_global.h"
+#include <qwidget.h>
 
 class QwtScaleEngine;
 class QwtAbstractScaleDraw;
@@ -19,26 +20,50 @@
 class QwtInterval;
 
 /*!
-  \brief An abstract base class for classes containing a scale
+  \brief An abstract base class for widgets having a scale
 
-  QwtAbstractScale is used to provide classes with a QwtScaleDraw,
-  and a QwtScaleDiv. The QwtScaleDiv might be set explicitely
-  or calculated by a QwtScaleEngine.
+  The scale of an QwtAbstractScale is determined by a QwtScaleDiv
+  definition, that contains the boundaries and the ticks of the scale.
+  The scale is painted using a QwtScaleDraw object.
+
+  The scale division might be assigned explicitly - but usually
+  it is calculated from the boundaries using a QwtScaleEngine. 
+
+  The scale engine also decides the type of transformation of the scale 
+  ( linear, logarithmic ... ).
 */
 
-class QWT_EXPORT QwtAbstractScale
+class QWT_EXPORT QwtAbstractScale: public QWidget
 {
+    Q_OBJECT
+
+    Q_PROPERTY( double lowerBound READ lowerBound WRITE setLowerBound )
+    Q_PROPERTY( double upperBound READ upperBound WRITE setUpperBound )
+
+    Q_PROPERTY( int scaleMaxMajor READ scaleMaxMajor WRITE setScaleMaxMajor )
+    Q_PROPERTY( int scaleMaxMinor READ scaleMaxMinor WRITE setScaleMaxMinor )
+
+    Q_PROPERTY( double scaleStepSize READ scaleStepSize WRITE setScaleStepSize )
+
 public:
-    QwtAbstractScale();
+    QwtAbstractScale( QWidget *parent = NULL );
     virtual ~QwtAbstractScale();
 
-    void setScale( double vmin, double vmax, double step = 0.0 );
-    void setScale( const QwtInterval &, double step = 0.0 );
+    void setScale( double lowerBound, double upperBound );
+    void setScale( const QwtInterval & );
     void setScale( const QwtScaleDiv & );
 
-    void setAutoScale();
-    bool autoScale() const;
+    const QwtScaleDiv& scaleDiv() const;
 
+    void setLowerBound( double value );
+    double lowerBound() const;
+
+    void setUpperBound( double value );
+    double upperBound() const;
+
+    void setScaleStepSize( double stepSize );
+    double scaleStepSize() const;
+
     void setScaleMaxMajor( int ticks );
     int scaleMaxMinor() const;
 
@@ -49,12 +74,22 @@
     const QwtScaleEngine *scaleEngine() const;
     QwtScaleEngine *scaleEngine();
 
+    int transform( double ) const;
+    double invTransform( int ) const;
+
+    bool isInverted() const;
+
+    double minimum() const;
+    double maximum() const;
+
     const QwtScaleMap &scaleMap() const;
 
 protected:
-    void rescale( double vmin, double vmax, double step = 0.0 );
+    void rescale( double lowerBound, 
+        double upperBound, double stepSize );
 
     void setAbstractScaleDraw( QwtAbstractScaleDraw * );
+
     const QwtAbstractScaleDraw *abstractScaleDraw() const;
     QwtAbstractScaleDraw *abstractScaleDraw();
 
Index: qwt_plot_layout.h
===================================================================
--- qwt_plot_layout.h	(revision 382)
+++ qwt_plot_layout.h	(working copy)
@@ -19,6 +19,8 @@
   It is used by the QwtPlot widget to organize its internal widgets
   or by QwtPlot::print() to render its content to a QPaintDevice like
   a QPrinter, QPixmap/QImage or QSvgRenderer.
+
+  \sa QwtPlot::setPlotLayout()
 */
 
 class QWT_EXPORT QwtPlotLayout
@@ -83,16 +85,22 @@
 
     virtual void invalidate();
 
-    const QRectF &titleRect() const;
-    const QRectF &footerRect() const;
-    const QRectF &legendRect() const;
-    const QRectF &scaleRect( int axis ) const;
-    const QRectF &canvasRect() const;
+    QRectF titleRect() const;
+    QRectF footerRect() const;
+    QRectF legendRect() const;
+    QRectF scaleRect( int axis ) const;
+    QRectF canvasRect() const;
 
     class LayoutData;
 
 protected:
 
+    void setTitleRect( const QRectF & );
+    void setFooterRect( const QRectF & );
+    void setLegendRect( const QRectF & );
+    void setScaleRect( int axis, const QRectF & );
+    void setCanvasRect( const QRectF & );
+
     QRectF layoutLegend( Options options, const QRectF & ) const;
     QRectF alignLegend( const QRectF &canvasRect,
         const QRectF &legendRect ) const;
Index: qwt_plot_dict.cpp
===================================================================
--- qwt_plot_dict.cpp	(revision 382)
+++ qwt_plot_dict.cpp	(working copy)
@@ -63,7 +63,7 @@
    Constructor
 
    Auto deletion is enabled.
-   \sa setAutoDelete(), attachItem()
+   \sa setAutoDelete(), QwtPlotItem::attach()
 */
 QwtPlotDict::QwtPlotDict()
 {
@@ -74,8 +74,8 @@
 /*!
    Destructor
 
-   If autoDelete is on, all attached items will be deleted
-   \sa setAutoDelete(), autoDelete(), attachItem()
+   If autoDelete() is on, all attached items will be deleted
+   \sa setAutoDelete(), autoDelete(), QwtPlotItem::attach()
 */
 QwtPlotDict::~QwtPlotDict()
 {
@@ -89,7 +89,7 @@
    If Auto deletion is on all attached plot items will be deleted
    in the destructor of QwtPlotDict. The default value is on.
 
-   \sa autoDelete(), attachItem()
+   \sa autoDelete(), insertItem()
 */
 void QwtPlotDict::setAutoDelete( bool autoDelete )
 {
@@ -98,18 +98,30 @@
 
 /*!
    \return true if auto deletion is enabled
-   \sa setAutoDelete(), attachItem()
+   \sa setAutoDelete(), insertItem()
 */
 bool QwtPlotDict::autoDelete() const
 {
     return d_data->autoDelete;
 }
 
+/*!
+  Insert a plot item
+
+  \param item PlotItem
+  \sa removeItem()
+ */
 void QwtPlotDict::insertItem( QwtPlotItem *item )
 {
     d_data->itemList.insertItem( item );
 }
 
+/*!
+  Remove a plot item
+
+  \param item PlotItem
+  \sa insertItem()
+ */
 void QwtPlotDict::removeItem( QwtPlotItem *item )
 {
     d_data->itemList.removeItem( item );
@@ -157,6 +169,7 @@
 
 /*!
   \return List of all attached plot items of a specific type.
+  \param rtti See QwtPlotItem::RttiValues
   \sa QwtPlotItem::rtti()
 */
 QwtPlotItemList QwtPlotDict::itemList( int rtti ) const
Index: qwt_point_3d.h
===================================================================
--- qwt_point_3d.h	(revision 382)
+++ qwt_point_3d.h	(working copy)
@@ -102,7 +102,7 @@
 }
 
 /*!
-    Returns true if the point is null; otherwise returns false.
+    \return True if the point is null; otherwise returns false.
 
     A point is considered to be null if x, y and z-coordinates
     are equal to zero.
@@ -112,37 +112,37 @@
     return d_x == 0.0 && d_y == 0.0 && d_z == 0.0;
 }
 
-//! Returns the x-coordinate of the point.
+//! \return The x-coordinate of the point.
 inline double QwtPoint3D::x() const
 {
     return d_x;
 }
 
-//! Returns the y-coordinate of the point.
+//! \return The y-coordinate of the point.
 inline double QwtPoint3D::y() const
 {
     return d_y;
 }
 
-//! Returns the z-coordinate of the point.
+//! \return The z-coordinate of the point.
 inline double QwtPoint3D::z() const
 {
     return d_z;
 }
 
-//! Returns a reference to the x-coordinate of the point.
+//! \return A reference to the x-coordinate of the point.
 inline double &QwtPoint3D::rx()
 {
     return d_x;
 }
 
-//! Returns a reference to the y-coordinate of the point.
+//! \return A reference to the y-coordinate of the point.
 inline double &QwtPoint3D::ry()
 {
     return d_y;
 }
 
-//! Returns a reference to the z-coordinate of the point.
+//! \return A reference to the z-coordinate of the point.
 inline double &QwtPoint3D::rz()
 {
     return d_z;
@@ -167,20 +167,20 @@
 }
 
 /*!
-   Rounds 2D point, where the z coordinate is dropped.
+   \return 2D point, where the z coordinate is dropped.
 */
 inline QPointF QwtPoint3D::toPoint() const
 {
     return QPointF( d_x, d_y );
 }
 
-//! Returns true if this point and other are equal; otherwise returns false.
+//! \return True, if this point and other are equal; otherwise returns false.
 inline bool QwtPoint3D::operator==( const QwtPoint3D &other ) const
 {
     return ( d_x == other.d_x ) && ( d_y == other.d_y ) && ( d_z == other.d_z );
 }
 
-//! Returns true if this rect and other are different; otherwise returns false.
+//! \return True if this rect and other are different; otherwise returns false.
 inline bool QwtPoint3D::operator!=( const QwtPoint3D &other ) const
 {
     return !operator==( other );
Index: qwt_arrow_button.cpp
===================================================================
--- qwt_arrow_button.cpp	(revision 382)
+++ qwt_arrow_button.cpp	(working copy)
@@ -49,7 +49,7 @@
 
 /*!
   \param num Number of arrows
-  \param arrowType see Qt::ArowType in the Qt docs.
+  \param arrowType see Qt::ArrowType in the Qt docs.
   \param parent Parent widget
 */
 QwtArrowButton::QwtArrowButton( int num,
@@ -100,7 +100,7 @@
 }
 
 /*!
-  \return the bounding rect for the label
+  \return the bounding rectangle for the label
 */
 QRect QwtArrowButton::labelRect() const
 {
@@ -139,7 +139,7 @@
   \brief Draw the button label
 
   \param painter Painter
-  \sa The Qt Manual on QPushButton
+  \sa The Qt Manual for QPushButton
 */
 void QwtArrowButton::drawButtonLabel( QPainter *painter )
 {
@@ -207,7 +207,7 @@
 }
 
 /*!
-    Draw an arrow int a bounding rect
+    Draw an arrow int a bounding rectangle
 
     \param painter Painter
     \param r Rectangle where to paint the arrow
@@ -246,7 +246,8 @@
 
     painter->save();
 
-    painter->setPen( palette().color( QPalette::ButtonText ) );
+    painter->setRenderHint( QPainter::Antialiasing, true );
+    painter->setPen( Qt::NoPen );
     painter->setBrush( palette().brush( QPalette::ButtonText ) );
     painter->drawPolygon( pa );
 
@@ -287,7 +288,7 @@
 }
 
 /*!
-   Calculate the size for a arrow that fits into a rect of a given size
+   Calculate the size for a arrow that fits into a rectangle of a given size
 
    \param arrowType Arrow type
    \param boundingSize Bounding size
Index: qwt_point_polar.cpp
===================================================================
--- qwt_point_polar.cpp	(revision 382)
+++ qwt_point_polar.cpp	(working copy)
@@ -38,6 +38,8 @@
 /*!
    Convert and return values in Cartesian coordinates
 
+   \return Converted point in Cartesian coordinates
+
    \note Invalid or null points will be returned as QPointF(0.0, 0.0)
    \sa isValid(), isNull()
 */
@@ -53,12 +55,14 @@
 }
 
 /*!
-    Returns true if point1 is equal to point2; otherwise returns false.
+    \brief Compare 2 points
 
     Two points are equal to each other if radius and
     azimuth-coordinates are the same. Points are not equal, when
     the azimuth differs, but other.azimuth() == azimuth() % (2 * PI).
 
+    \return True if the point is equal to other; otherwise return false.
+
     \sa normalized()
 */
 bool QwtPointPolar::operator==( const QwtPointPolar &other ) const
@@ -67,12 +71,13 @@
 }
 
 /*!
-    Returns true if point1 is not equal to point2; otherwise returns false.
+    Compare 2 points
 
     Two points are equal to each other if radius and
     azimuth-coordinates are the same. Points are not equal, when
     the azimuth differs, but other.azimuth() == azimuth() % (2 * PI).
 
+    \return True if the point is not equal to other; otherwise return false.
     \sa normalized()
 */
 bool QwtPointPolar::operator!=( const QwtPointPolar &other ) const
@@ -85,6 +90,8 @@
 
    When the radius is < 0.0 it is set to 0.0. The azimuth is
    a value >= 0.0 and < 2 * M_PI.
+
+   \return Normalized point
 */
 QwtPointPolar QwtPointPolar::normalized() const
 {
